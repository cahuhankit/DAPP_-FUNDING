{"ast":null,"code":"export function countToggledBits(n) {\n  let count = 0;\n  while (n > BigInt(0)) {\n    if (n & BigInt(1)) ++count;\n    n >>= BigInt(1);\n  }\n  return count;\n}\nexport function computeNextFlags(flags, nextSize) {\n  const allowedMask = (BigInt(1) << BigInt(nextSize)) - BigInt(1);\n  const preservedFlags = flags & allowedMask;\n  let numMissingFlags = countToggledBits(flags - preservedFlags);\n  let nFlags = preservedFlags;\n  for (let mask = BigInt(1); mask <= allowedMask && numMissingFlags !== 0; mask <<= BigInt(1)) {\n    if (!(nFlags & mask)) {\n      nFlags |= mask;\n      --numMissingFlags;\n    }\n  }\n  return nFlags;\n}\nexport function computeTogglePositions(chars, toggleCase) {\n  const positions = [];\n  for (let idx = chars.length - 1; idx !== -1; --idx) {\n    if (toggleCase(chars[idx]) !== chars[idx]) positions.push(idx);\n  }\n  return positions;\n}\nexport function computeFlagsFromChars(untoggledChars, toggledChars, togglePositions) {\n  let flags = BigInt(0);\n  for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {\n    if (untoggledChars[togglePositions[idx]] !== toggledChars[togglePositions[idx]]) {\n      flags |= mask;\n    }\n  }\n  return flags;\n}\nexport function applyFlagsOnChars(chars, flags, togglePositions, toggleCase) {\n  for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {\n    if (flags & mask) chars[togglePositions[idx]] = toggleCase(chars[togglePositions[idx]]);\n  }\n}","map":{"version":3,"names":["countToggledBits","n","count","BigInt","computeNextFlags","flags","nextSize","allowedMask","preservedFlags","numMissingFlags","nFlags","mask","computeTogglePositions","chars","toggleCase","positions","idx","length","push","computeFlagsFromChars","untoggledChars","toggledChars","togglePositions","applyFlagsOnChars"],"sources":["C:/Users/ankit/Desktop/FUND/funding/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ToggleFlags.js"],"sourcesContent":["export function countToggledBits(n) {\n    let count = 0;\n    while (n > BigInt(0)) {\n        if (n & BigInt(1))\n            ++count;\n        n >>= BigInt(1);\n    }\n    return count;\n}\nexport function computeNextFlags(flags, nextSize) {\n    const allowedMask = (BigInt(1) << BigInt(nextSize)) - BigInt(1);\n    const preservedFlags = flags & allowedMask;\n    let numMissingFlags = countToggledBits(flags - preservedFlags);\n    let nFlags = preservedFlags;\n    for (let mask = BigInt(1); mask <= allowedMask && numMissingFlags !== 0; mask <<= BigInt(1)) {\n        if (!(nFlags & mask)) {\n            nFlags |= mask;\n            --numMissingFlags;\n        }\n    }\n    return nFlags;\n}\nexport function computeTogglePositions(chars, toggleCase) {\n    const positions = [];\n    for (let idx = chars.length - 1; idx !== -1; --idx) {\n        if (toggleCase(chars[idx]) !== chars[idx])\n            positions.push(idx);\n    }\n    return positions;\n}\nexport function computeFlagsFromChars(untoggledChars, toggledChars, togglePositions) {\n    let flags = BigInt(0);\n    for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {\n        if (untoggledChars[togglePositions[idx]] !== toggledChars[togglePositions[idx]]) {\n            flags |= mask;\n        }\n    }\n    return flags;\n}\nexport function applyFlagsOnChars(chars, flags, togglePositions, toggleCase) {\n    for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {\n        if (flags & mask)\n            chars[togglePositions[idx]] = toggleCase(chars[togglePositions[idx]]);\n    }\n}\n"],"mappings":"AAAA,OAAO,SAASA,gBAAgB,CAACC,CAAC,EAAE;EAChC,IAAIC,KAAK,GAAG,CAAC;EACb,OAAOD,CAAC,GAAGE,MAAM,CAAC,CAAC,CAAC,EAAE;IAClB,IAAIF,CAAC,GAAGE,MAAM,CAAC,CAAC,CAAC,EACb,EAAED,KAAK;IACXD,CAAC,KAAKE,MAAM,CAAC,CAAC,CAAC;EACnB;EACA,OAAOD,KAAK;AAChB;AACA,OAAO,SAASE,gBAAgB,CAACC,KAAK,EAAEC,QAAQ,EAAE;EAC9C,MAAMC,WAAW,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,IAAIA,MAAM,CAACG,QAAQ,CAAC,IAAIH,MAAM,CAAC,CAAC,CAAC;EAC/D,MAAMK,cAAc,GAAGH,KAAK,GAAGE,WAAW;EAC1C,IAAIE,eAAe,GAAGT,gBAAgB,CAACK,KAAK,GAAGG,cAAc,CAAC;EAC9D,IAAIE,MAAM,GAAGF,cAAc;EAC3B,KAAK,IAAIG,IAAI,GAAGR,MAAM,CAAC,CAAC,CAAC,EAAEQ,IAAI,IAAIJ,WAAW,IAAIE,eAAe,KAAK,CAAC,EAAEE,IAAI,KAAKR,MAAM,CAAC,CAAC,CAAC,EAAE;IACzF,IAAI,EAAEO,MAAM,GAAGC,IAAI,CAAC,EAAE;MAClBD,MAAM,IAAIC,IAAI;MACd,EAAEF,eAAe;IACrB;EACJ;EACA,OAAOC,MAAM;AACjB;AACA,OAAO,SAASE,sBAAsB,CAACC,KAAK,EAAEC,UAAU,EAAE;EACtD,MAAMC,SAAS,GAAG,EAAE;EACpB,KAAK,IAAIC,GAAG,GAAGH,KAAK,CAACI,MAAM,GAAG,CAAC,EAAED,GAAG,KAAK,CAAC,CAAC,EAAE,EAAEA,GAAG,EAAE;IAChD,IAAIF,UAAU,CAACD,KAAK,CAACG,GAAG,CAAC,CAAC,KAAKH,KAAK,CAACG,GAAG,CAAC,EACrCD,SAAS,CAACG,IAAI,CAACF,GAAG,CAAC;EAC3B;EACA,OAAOD,SAAS;AACpB;AACA,OAAO,SAASI,qBAAqB,CAACC,cAAc,EAAEC,YAAY,EAAEC,eAAe,EAAE;EACjF,IAAIjB,KAAK,GAAGF,MAAM,CAAC,CAAC,CAAC;EACrB,KAAK,IAAIa,GAAG,GAAG,CAAC,EAAEL,IAAI,GAAGR,MAAM,CAAC,CAAC,CAAC,EAAEa,GAAG,KAAKM,eAAe,CAACL,MAAM,EAAE,EAAED,GAAG,EAAEL,IAAI,KAAKR,MAAM,CAAC,CAAC,CAAC,EAAE;IAC3F,IAAIiB,cAAc,CAACE,eAAe,CAACN,GAAG,CAAC,CAAC,KAAKK,YAAY,CAACC,eAAe,CAACN,GAAG,CAAC,CAAC,EAAE;MAC7EX,KAAK,IAAIM,IAAI;IACjB;EACJ;EACA,OAAON,KAAK;AAChB;AACA,OAAO,SAASkB,iBAAiB,CAACV,KAAK,EAAER,KAAK,EAAEiB,eAAe,EAAER,UAAU,EAAE;EACzE,KAAK,IAAIE,GAAG,GAAG,CAAC,EAAEL,IAAI,GAAGR,MAAM,CAAC,CAAC,CAAC,EAAEa,GAAG,KAAKM,eAAe,CAACL,MAAM,EAAE,EAAED,GAAG,EAAEL,IAAI,KAAKR,MAAM,CAAC,CAAC,CAAC,EAAE;IAC3F,IAAIE,KAAK,GAAGM,IAAI,EACZE,KAAK,CAACS,eAAe,CAACN,GAAG,CAAC,CAAC,GAAGF,UAAU,CAACD,KAAK,CAACS,eAAe,CAACN,GAAG,CAAC,CAAC,CAAC;EAC7E;AACJ"},"metadata":{},"sourceType":"module"}