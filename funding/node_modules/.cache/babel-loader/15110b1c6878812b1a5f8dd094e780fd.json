{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getterParameters = exports.definitionToAbi = exports.isContractPayable = exports.mutability = exports.functionClass = exports.functionKind = exports.parameters = exports.valueDefinition = exports.keyDefinition = exports.baseDefinition = exports.rationalValue = exports.regularizeTypeIdentifier = exports.spliceLocation = exports.isSimpleConstant = exports.stackSize = exports.contractKind = exports.referenceType = exports.isReference = exports.isEnum = exports.isMapping = exports.isStruct = exports.staticLengthAsString = exports.staticLength = exports.isDynamicArray = exports.isArray = exports.decimalPlaces = exports.specifiedSize = exports.visibility = exports.typeId = exports.typeClassLongForm = exports.typeClass = exports.typeStringWithoutLocation = exports.typeString = exports.typeIdentifier = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:ast:utils\");\nconst Common = __importStar(require(\"../common\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst cloneDeep_1 = __importDefault(require(\"lodash/cloneDeep\"));\n/** @category Definition Reading */\nfunction typeIdentifier(definition) {\n  return definition.typeDescriptions.typeIdentifier;\n}\nexports.typeIdentifier = typeIdentifier;\n/** @category Definition Reading */\nfunction typeString(definition) {\n  return definition.typeDescriptions.typeString;\n}\nexports.typeString = typeString;\n/**\n * Returns the type string, but with location (if any) stripped off the end\n * @category Definition Reading\n */\nfunction typeStringWithoutLocation(definition) {\n  if (definition.nodeType === \"YulTypedName\") {\n    //for handling Yul variables\n    return \"bytes32\";\n  }\n  return typeString(definition).replace(/ (storage|memory|calldata)( slice)?$/, \"\");\n}\nexports.typeStringWithoutLocation = typeStringWithoutLocation;\n/**\n * returns basic type class for a variable definition node\n * e.g.:\n *  `t_uint256` becomes `uint`\n *  `t_struct$_Thing_$20_memory_ptr` becomes `struct`\n * @category Definition Reading\n */\nfunction typeClass(definition) {\n  if (definition.nodeType === \"YulTypedName\") {\n    //for handling Yul variables\n    return \"bytes\";\n  }\n  return typeIdentifier(definition).match(/t_([^$_0-9]+)/)[1];\n}\nexports.typeClass = typeClass;\n/**\n * similar to typeClass, but includes any numeric qualifiers\n * e.g.:\n * `t_uint256` becomes `uint256`\n * @category Definition Reading\n */\nfunction typeClassLongForm(definition) {\n  return typeIdentifier(definition).match(/t_([^$_]+)/)[1];\n}\nexports.typeClassLongForm = typeClassLongForm;\n/**\n * for user-defined types -- structs, enums, contracts\n * often you can get these from referencedDeclaration, but not\n * always\n * @category Definition Reading\n */\nfunction typeId(definition) {\n  debug(\"definition %O\", definition);\n  return parseInt(typeIdentifier(definition).match(/\\$(\\d+)(_(storage|memory|calldata)(_ptr(_slice)?)?)?$/)[1]);\n}\nexports.typeId = typeId;\n/**\n * For function types; returns internal or external\n * (not for use on other types! will cause an error!)\n * should only return \"internal\" or \"external\"\n * @category Definition Reading\n */\nfunction visibility(definition) {\n  return definition.typeName ? definition.typeName.visibility : definition.visibility;\n}\nexports.visibility = visibility;\n/**\n * e.g. uint48 -> 6\n * @return size in bytes for explicit type size, or `null` if not stated\n * @category Definition Reading\n */\nfunction specifiedSize(definition) {\n  if (definition.nodeType === \"YulTypedName\") {\n    return 32; //for handling Yul variables\n  }\n\n  let specified = typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/);\n  if (!specified) {\n    return null;\n  }\n  let num = parseInt(specified[1]);\n  switch (typeClass(definition)) {\n    case \"int\":\n    case \"uint\":\n    case \"fixed\":\n    case \"ufixed\":\n      return num / 8;\n    case \"bytes\":\n      return num;\n    default:\n      debug(\"Unknown type for size specification: %s\", typeIdentifier(definition));\n  }\n}\nexports.specifiedSize = specifiedSize;\n/**\n * for fixed-point types, obviously\n * @category Definition Reading\n */\nfunction decimalPlaces(definition) {\n  return parseInt(typeIdentifier(definition).match(/t_[a-z]+[0-9]+x([0-9]+)/)[1]);\n}\nexports.decimalPlaces = decimalPlaces;\n/** @category Definition Reading */\nfunction isArray(definition) {\n  return typeIdentifier(definition).match(/^t_array/) != null;\n}\nexports.isArray = isArray;\n/** @category Definition Reading */\nfunction isDynamicArray(definition) {\n  return isArray(definition) &&\n  //NOTE: we do this by parsing the type identifier, rather than by just\n  //checking the length field, because we might be using this on a faked-up\n  //definition\n  typeIdentifier(definition).match(/\\$dyn_(storage|memory|calldata)(_ptr(_slice)?)?$/) != null;\n}\nexports.isDynamicArray = isDynamicArray;\n/**\n * length of a statically sized array -- please only use for arrays\n * already verified to be static!\n * @category Definition Reading\n */\nfunction staticLength(definition) {\n  //NOTE: we do this by parsing the type identifier, rather than by just\n  //checking the length field, because we might be using this on a faked-up\n  //definition\n  return parseInt(staticLengthAsString(definition));\n}\nexports.staticLength = staticLength;\n/**\n * see staticLength for explanation\n * @category Definition Reading\n */\nfunction staticLengthAsString(definition) {\n  return typeIdentifier(definition).match(/\\$(\\d+)_(storage|memory|calldata)(_ptr(_slice)?)?$/)[1];\n}\nexports.staticLengthAsString = staticLengthAsString;\n/** @category Definition Reading */\nfunction isStruct(definition) {\n  return typeIdentifier(definition).match(/^t_struct/) != null;\n}\nexports.isStruct = isStruct;\n/** @category Definition Reading */\nfunction isMapping(definition) {\n  return typeIdentifier(definition).match(/^t_mapping/) != null;\n}\nexports.isMapping = isMapping;\n/** @category Definition Reading */\nfunction isEnum(definition) {\n  return typeIdentifier(definition).match(/^t_enum/) != null;\n}\nexports.isEnum = isEnum;\n/** @category Definition Reading */\nfunction isReference(definition) {\n  return typeIdentifier(definition).match(/_(memory|storage|calldata)(_ptr(_slice)?)?$/) != null;\n}\nexports.isReference = isReference;\n/**\n * note: only use this on things already verified to be references\n * @category Definition Reading\n */\nfunction referenceType(definition) {\n  return typeIdentifier(definition).match(/_([^_]+)(_ptr(_slice)?)?$/)[1];\n}\nexports.referenceType = referenceType;\n/**\n * only for contract types, obviously! will yield nonsense otherwise!\n * @category Definition Reading\n */\nfunction contractKind(definition) {\n  return typeString(definition).split(\" \")[0];\n}\nexports.contractKind = contractKind;\n/**\n * stack size, in words, of a given type\n * note: this function assumes that UDVTs only ever take up\n * a single word, which is currently true\n * @category Definition Reading\n */\nfunction stackSize(definition) {\n  if (typeClass(definition) === \"function\" && visibility(definition) === \"external\") {\n    return 2;\n  }\n  if (isReference(definition) && referenceType(definition) === \"calldata\") {\n    if (typeClass(definition) === \"string\" || typeClass(definition) === \"bytes\") {\n      return 2;\n    }\n    if (isDynamicArray(definition)) {\n      return 2;\n    }\n  }\n  return 1;\n}\nexports.stackSize = stackSize;\n/** @category Definition Reading */\nfunction isSimpleConstant(definition) {\n  const types = [\"stringliteral\", \"rational\"];\n  return types.includes(typeClass(definition));\n}\nexports.isSimpleConstant = isSimpleConstant;\n/**\n * definition: a storage reference definition\n * location: the location you want it to refer to instead\n * @category Definition Reading\n */\nfunction spliceLocation(definition, location) {\n  debug(\"definition %O\", definition);\n  return Object.assign(Object.assign({}, definition), {\n    typeDescriptions: Object.assign(Object.assign({}, definition.typeDescriptions), {\n      typeIdentifier: definition.typeDescriptions.typeIdentifier.replace(/_(storage|memory|calldata)(?=((_slice)?_ptr)?$)/, \"_\" + location)\n    })\n  });\n}\nexports.spliceLocation = spliceLocation;\n/**\n * adds \"_ptr\" on to the end of type identifiers that might need it; note that\n * this operates on identifiers, not definitions\n * @category Definition Reading\n */\nfunction regularizeTypeIdentifier(identifier) {\n  return identifier.replace(/(_(storage|memory|calldata))((_slice)?_ptr)?$/, \"$1_ptr\" //this used to use lookbehind for clarity, but Firefox...\n  //(see: https://github.com/trufflesuite/truffle/issues/3068 )\n  );\n}\n\nexports.regularizeTypeIdentifier = regularizeTypeIdentifier;\n/**\n * extract the actual numerical value from a node of type rational.\n * currently assumes result will be integer (currently returns BN)\n * @category Definition Reading\n */\nfunction rationalValue(definition) {\n  let identifier = typeIdentifier(definition);\n  let absoluteValue = identifier.match(/_(\\d+)_by_1$/)[1];\n  let isNegative = identifier.match(/_minus_/) != null;\n  return isNegative ? new bn_js_1.default(absoluteValue).neg() : new bn_js_1.default(absoluteValue);\n}\nexports.rationalValue = rationalValue;\n/** @category Definition Reading */\nfunction baseDefinition(definition) {\n  if (definition.typeName && definition.typeName.baseType) {\n    return definition.typeName.baseType;\n  }\n  if (definition.baseType) {\n    return definition.baseType;\n  }\n  //otherwise, we'll have to spoof it up ourselves\n  let baseIdentifier = typeIdentifier(definition).match(/^t_array\\$_(.*)_\\$/)[1];\n  //greedy match to extract everything from first to last dollar sign\n  // HACK - internal types for memory or storage also seem to be pointers\n  baseIdentifier = regularizeTypeIdentifier(baseIdentifier);\n  // another HACK - we get away with it because we're only using that one property\n  let result = (0, cloneDeep_1.default)(definition);\n  result.typeDescriptions.typeIdentifier = baseIdentifier;\n  return result;\n  //WARNING -- these hacks do *not* correctly handle all cases!\n  //they do, however, handle the cases we currently need.\n}\n\nexports.baseDefinition = baseDefinition;\n/**\n * for use for mappings and arrays only!\n * for arrays, fakes up a uint definition\n * @category Definition Reading\n */\nfunction keyDefinition(definition, scopes) {\n  let result;\n  switch (typeClass(definition)) {\n    case \"mapping\":\n      //first: is there a key type already there? if so just use that\n      if (definition.keyType) {\n        return definition.keyType;\n      }\n      if (definition.typeName && definition.typeName.keyType) {\n        return definition.typeName.keyType;\n      }\n      //otherwise: is there a referencedDeclaration? if so try using that\n      let baseDeclarationId = definition.referencedDeclaration;\n      debug(\"baseDeclarationId %d\", baseDeclarationId);\n      //if there's a referencedDeclaration, we'll use that\n      if (baseDeclarationId !== undefined) {\n        let baseDeclaration = scopes[baseDeclarationId].definition;\n        return baseDeclaration.keyType || baseDeclaration.typeName.keyType;\n      }\n      //otherwise, we'll need to perform some hackery, similarly to in baseDefinition;\n      //we'll have to spoof it up ourselves\n      let keyIdentifier = typeIdentifier(definition).match(/^t_mapping\\$_(.*?)_\\$_/)[1];\n      //use *non*-greedy match; note that if the key type could include\n      //the sequence \"_$_\", this could cause a problem, but they can't; the only\n      //valid key types that include dollar signs at all are user-defined types,\n      //which contain both \"$_\" and \"_$\" but never \"_$_\".\n      // HACK - internal types for memory or storage also seem to be pointers\n      keyIdentifier = regularizeTypeIdentifier(keyIdentifier);\n      let keyString = typeString(definition).match(/mapping\\((.*?) => .*\\)( storage)?$/)[1];\n      //use *non*-greedy match; note that if the key type could include\n      //\"=>\", this could cause a problem, but mappings are not allowed as key\n      //types, so this can't come up\n      // another HACK - we get away with it because we're only using that one property\n      result = (0, cloneDeep_1.default)(definition);\n      result.typeDescriptions = {\n        typeIdentifier: keyIdentifier,\n        typeString: keyString\n      };\n      return result;\n    case \"array\":\n      //HACK -- again we should get away with it because for a uint256 we don't\n      //really need to inspect the other properties\n      result = (0, cloneDeep_1.default)(definition);\n      result.typeDescriptions = {\n        typeIdentifier: \"t_uint256\",\n        typeString: \"uint256\"\n      };\n      return result;\n    default:\n      debug(\"unrecognized index access!\");\n  }\n}\nexports.keyDefinition = keyDefinition;\n/**\n * for use for mappings only!\n * @category Definition Reading\n */\nfunction valueDefinition(definition, scopes) {\n  let result;\n  //first: is there a value type already there? if so just use that\n  if (definition.valueType) {\n    return definition.valueType;\n  }\n  if (definition.typeName && definition.typeName.valueType) {\n    return definition.typeName.valueType;\n  }\n  //otherwise: is there a referencedDeclaration? if so try using that\n  let baseDeclarationId = definition.referencedDeclaration;\n  debug(\"baseDeclarationId %d\", baseDeclarationId);\n  //if there's a referencedDeclaration, we'll use that\n  if (baseDeclarationId !== undefined) {\n    let baseDeclaration = scopes[baseDeclarationId].definition;\n    return baseDeclaration.valueType || baseDeclaration.typeName.valueType;\n  }\n  //otherwise, we'll need to perform some hackery, similarly to in keyDefinition;\n  //we'll have to spoof it up ourselves\n  let valueIdentifier = typeIdentifier(definition).match(/^t_mapping\\$_.*?_\\$_(.*)_\\$/)[1];\n  //use *non*-greedy match on the key; note that if the key type could include\n  //the sequence \"_$_\", this could cause a problem, but they can't; the only\n  //valid key types that include dollar signs at all are user-defined types,\n  //which contain both \"$_\" and \"_$\" but never \"_$_\".\n  // HACK - internal types for memory or storage also seem to be pointers\n  valueIdentifier = regularizeTypeIdentifier(valueIdentifier);\n  let valueString = typeString(definition).match(/mapping\\(.*? => (.*)\\)( storage)?$/)[1];\n  //use *non*-greedy match; note that if the key type could include\n  //\"=>\", this could cause a problem, but mappings are not allowed as key\n  //types, so this can't come up\n  // another HACK - we get away with it because we're only using that one property\n  result = (0, cloneDeep_1.default)(definition);\n  result.typeDescriptions = {\n    typeIdentifier: valueIdentifier,\n    typeString: valueString\n  };\n  return result;\n}\nexports.valueDefinition = valueDefinition;\n/**\n * returns input parameters, then output parameters\n * NOTE: ONLY FOR VARIABLE DECLARATIONS OF FUNCTION TYPE\n * NOT FOR FUNCTION DEFINITIONS\n * @category Definition Reading\n */\nfunction parameters(definition) {\n  let typeObject = definition.typeName || definition;\n  if (typeObject.parameterTypes && typeObject.returnParameterTypes) {\n    return [typeObject.parameterTypes.parameters, typeObject.returnParameterTypes.parameters];\n  } else {\n    return undefined;\n  }\n}\nexports.parameters = parameters;\n/**\n * compatibility function, since pre-0.5.0 functions don't have node.kind\n * returns undefined if you don't put in a function node\n * @category Definition Reading\n */\nfunction functionKind(node) {\n  if (node.nodeType !== \"FunctionDefinition\") {\n    return undefined;\n  }\n  if (node.kind !== undefined) {\n    //if we're dealing with 0.5.x, we can just read node.kind\n    return node.kind;\n  }\n  //otherwise, we need this little shim\n  if (node.isConstructor) {\n    return \"constructor\";\n  }\n  return node.name === \"\" ? \"fallback\" : \"function\";\n}\nexports.functionKind = functionKind;\n//this is kind of a weird one, it exposes some Solidity internals.\n//for internal functions it'll return \"internal\".\n//for external functions it'll return \"external\".\n//for library functions it'll return \"delegatecall\".\n//and for builtin functions, it'll return an internal name for\n//that particular builtin function.\n//(there are more possibilities but I'm not going to list them all here)\nfunction functionClass(node) {\n  const match = typeIdentifier(node).match(/^t_function_([^_]+)_/);\n  return match ? match[1] : undefined;\n}\nexports.functionClass = functionClass;\n/**\n * similar compatibility function for mutability for pre-0.4.16 versions\n * returns undefined if you don't give it a FunctionDefinition or\n * VariableDeclaration\n * @category Definition Reading\n */\nfunction mutability(node) {\n  node = node.typeName || node;\n  if (node.nodeType !== \"FunctionDefinition\" && node.nodeType !== \"FunctionTypeName\") {\n    return undefined;\n  }\n  if (node.stateMutability !== undefined) {\n    //if we're dealing with 0.4.16 or later, we can just read node.stateMutability\n    return node.stateMutability;\n  }\n  //otherwise, we need this little shim\n  if (node.payable) {\n    return \"payable\";\n  }\n  if (node.constant) {\n    //yes, it means \"view\" even if you're looking at a variable declaration!\n    //old Solidity was weird!\n    return \"view\";\n  }\n  return \"nonpayable\";\n}\nexports.mutability = mutability;\n/**\n * takes a contract definition and asks, does it have a payable fallback\n * function?\n * @category Definition Reading\n */\nfunction isContractPayable(definition) {\n  return definition.nodes.some(node => node.nodeType === \"FunctionDefinition\" && (functionKind(node) === \"fallback\" || functionKind(node) === \"receive\") && mutability(node) === \"payable\");\n}\nexports.isContractPayable = isContractPayable;\n/**\n * the main function. just does some dispatch.\n * returns undefined on bad input\n */\nfunction definitionToAbi(node, referenceDeclarations) {\n  switch (node.nodeType) {\n    case \"FunctionDefinition\":\n      if (node.visibility === \"public\" || node.visibility === \"external\") {\n        return functionDefinitionToAbi(node, referenceDeclarations);\n      } else {\n        return undefined;\n      }\n    case \"EventDefinition\":\n      return eventDefinitionToAbi(node, referenceDeclarations);\n    case \"ErrorDefinition\":\n      return errorDefinitionToAbi(node, referenceDeclarations);\n    case \"VariableDeclaration\":\n      if (node.visibility === \"public\") {\n        return getterDefinitionToAbi(node, referenceDeclarations);\n      } else {\n        return undefined;\n      }\n    default:\n      return undefined;\n  }\n}\nexports.definitionToAbi = definitionToAbi;\n//note: not for FunctionTypeNames or VariableDeclarations\nfunction functionDefinitionToAbi(node, referenceDeclarations) {\n  let kind = functionKind(node);\n  let stateMutability = mutability(node);\n  let payable = stateMutability === \"payable\";\n  let inputs;\n  switch (kind) {\n    case \"function\":\n      let name = node.name;\n      let outputs = parametersToAbi(node.returnParameters.parameters, referenceDeclarations);\n      inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n      return {\n        type: \"function\",\n        name,\n        inputs,\n        outputs,\n        stateMutability\n      };\n    case \"constructor\":\n      inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n      //note: need to coerce because of mutability restrictions\n      return {\n        type: \"constructor\",\n        inputs,\n        stateMutability,\n        payable\n      };\n    case \"fallback\":\n      //note: need to coerce because of mutability restrictions\n      return {\n        type: \"fallback\",\n        stateMutability,\n        payable\n      };\n    case \"receive\":\n      //note: need to coerce because of mutability restrictions\n      return {\n        type: \"receive\",\n        stateMutability,\n        payable\n      };\n  }\n}\nfunction eventDefinitionToAbi(node, referenceDeclarations) {\n  let inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n  let name = node.name;\n  let anonymous = node.anonymous;\n  return {\n    type: \"event\",\n    inputs,\n    name,\n    anonymous\n  };\n}\nfunction errorDefinitionToAbi(node, referenceDeclarations) {\n  let inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n  let name = node.name;\n  return {\n    type: \"error\",\n    inputs,\n    name\n  };\n}\nfunction parametersToAbi(nodes, referenceDeclarations) {\n  return nodes.map(node => parameterToAbi(node, referenceDeclarations));\n}\n//NOTE: This function is only for types that could potentially go in the ABI!\n//(otherwise it could, say, loop infinitely)\n//currently it will only ever be called on those because it's only called from\n//definitionToAbi, which filters out any definitions that are not for\n//this that *actually* go in the ABI\n//if you want to expand it to handle those (by throwing an exception, say),\n//you'll need to give it a way to detect circularities\nfunction parameterToAbi(node, referenceDeclarations) {\n  let name = node.name; //may be the empty string... or even undefined for a base type\n  let components;\n  let internalType = typeStringWithoutLocation(node);\n  //is this an array? if so use separate logic\n  if (typeClass(node) === \"array\") {\n    let baseType = node.typeName ? node.typeName.baseType : node.baseType;\n    let baseAbi = parameterToAbi(baseType, referenceDeclarations);\n    let arraySuffix = isDynamicArray(node) ? `[]` : `[${staticLength(node)}]`;\n    const parameter = {\n      name,\n      type: baseAbi.type + arraySuffix,\n      components: baseAbi.components,\n      internalType\n    };\n    if (\"indexed\" in node) {\n      return Object.assign(Object.assign({}, parameter), {\n        indexed: node.indexed\n      });\n    } else {\n      return parameter;\n    }\n  }\n  let abiTypeString = toAbiType(node, referenceDeclarations);\n  //otherwise... is it a struct? if so we need to populate components\n  if (typeClass(node) === \"struct\") {\n    let id = typeId(node);\n    let referenceDeclaration = referenceDeclarations[id];\n    if (referenceDeclaration === undefined) {\n      let typeToDisplay = typeString(node);\n      throw new Common.UnknownUserDefinedTypeError(id.toString(), typeToDisplay);\n    }\n    components = parametersToAbi(referenceDeclaration.members, referenceDeclarations);\n  }\n  const parameter = {\n    name,\n    type: abiTypeString,\n    components,\n    internalType\n  };\n  if (\"indexed\" in node) {\n    return Object.assign(Object.assign({}, parameter), {\n      indexed: node.indexed\n    });\n  } else {\n    return parameter;\n  }\n}\n//note: this is only meant for non-array types that can go in the ABI\n//it returns how that type is notated in the ABI -- just the string,\n//to be clear, not components of tuples\n//again, NOT FOR ARRAYS\nfunction toAbiType(node, referenceDeclarations) {\n  let basicType = typeClassLongForm(node); //get that whole first segment!\n  switch (basicType) {\n    case \"contract\":\n      return \"address\";\n    case \"struct\":\n      return \"tuple\";\n    //the more detailed checking will be handled elsewhere\n    case \"enum\":\n      {\n        const referenceId = typeId(node);\n        const referenceDeclaration = referenceDeclarations[referenceId];\n        if (referenceDeclaration === undefined) {\n          const typeToDisplay = typeString(node);\n          throw new Common.UnknownUserDefinedTypeError(referenceId.toString(), typeToDisplay);\n        }\n        const numOptions = referenceDeclaration.members.length;\n        const bits = 8 * Math.ceil(Math.log2(numOptions) / 8);\n        return `uint${bits}`;\n      }\n    case \"userDefinedValueType\":\n      {\n        const referenceId = typeId(node);\n        const referenceDeclaration = referenceDeclarations[referenceId];\n        if (referenceDeclaration === undefined) {\n          const typeToDisplay = typeString(node);\n          throw new Common.UnknownUserDefinedTypeError(referenceId.toString(), typeToDisplay);\n        }\n        const underlyingType = referenceDeclaration.underlyingType;\n        return toAbiType(underlyingType, referenceDeclarations);\n      }\n    default:\n      return basicType;\n    //note that: int/uint/fixed/ufixed/bytes will have their size and such left on;\n    //address will have \"payable\" left off;\n    //external functions will be reduced to \"function\" (and internal functions shouldn't\n    //be passed in!)\n    //(mappings shouldn't be passed in either obviously)\n    //(nor arrays :P )\n  }\n}\n\nfunction getterDefinitionToAbi(node, referenceDeclarations) {\n  debug(\"getter node: %O\", node);\n  let name = node.name;\n  let {\n    inputs,\n    outputs\n  } = getterParameters(node, referenceDeclarations);\n  let inputsAbi = parametersToAbi(inputs, referenceDeclarations);\n  let outputsAbi = parametersToAbi(outputs, referenceDeclarations);\n  return {\n    type: \"function\",\n    name,\n    inputs: inputsAbi,\n    outputs: outputsAbi,\n    stateMutability: \"view\"\n  };\n}\n//how getter parameters work:\n//INPUT:\n//types other than arrays and mappings take no input.\n//array getters take uint256 input. mapping getters take input of their key type.\n//if arrays, mappings, stacked, then takes multiple inputs, in order from outside\n//to in.\n//These parameters are unnamed.\n//OUTPUT:\n//if base type (beneath mappings & arrays) is not a struct, returns that.\n//(This return parameter has no name -- it is *not* named for the variable!)\n//if it is a struct, returns multiple outputs, one for each member of the struct,\n//*except* arrays and mappings.  (And they have names, the names of the members.)\n//important note: inner structs within a struct are just returned, not\n//partially destructured like the outermost struct!  Yes, this is confusing.\nfunction getterParameters(node, referenceDeclarations) {\n  let baseNode = node.typeName || node;\n  let inputs = [];\n  while (typeClass(baseNode) === \"array\" || typeClass(baseNode) === \"mapping\") {\n    let keyNode = keyDefinition(baseNode); //note: if baseNode is an array, this spoofs up a uint256 definition\n    inputs.push(Object.assign(Object.assign({}, keyNode), {\n      name: \"\"\n    })); //again, getter input params have no name\n    switch (typeClass(baseNode)) {\n      case \"array\":\n        baseNode = baseNode.baseType;\n        break;\n      case \"mapping\":\n        baseNode = baseNode.valueType;\n        break;\n    }\n  }\n  //at this point, baseNode should hold the base type\n  //now we face the question: is it a struct?\n  if (typeClass(baseNode) === \"struct\") {\n    let id = typeId(baseNode);\n    let referenceDeclaration = referenceDeclarations[id];\n    if (referenceDeclaration === undefined) {\n      let typeToDisplay = typeString(baseNode);\n      throw new Common.UnknownUserDefinedTypeError(id.toString(), typeToDisplay);\n    }\n    let outputs = referenceDeclaration.members.filter(member => typeClass(member) !== \"array\" && typeClass(member) !== \"mapping\");\n    return {\n      inputs,\n      outputs\n    }; //no need to wash name!\n  } else {\n    //only one output; it's just the base node, with its name washed\n    return {\n      inputs,\n      outputs: [Object.assign(Object.assign({}, baseNode), {\n        name: \"\"\n      })]\n    };\n  }\n}\nexports.getterParameters = getterParameters;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA,MAAMA,KAAK,GAAG,mBAAW,EAAC,iBAAiB,CAAC;AAG5C;AAGA;AACA;AAEA;AACA,SAAgBC,cAAc,CAACC,UAAmB;EAChD,OAAOA,UAAU,CAACC,gBAAgB,CAACF,cAAc;AACnD;AAFAG;AAIA;AACA,SAAgBC,UAAU,CAACH,UAAmB;EAC5C,OAAOA,UAAU,CAACC,gBAAgB,CAACE,UAAU;AAC/C;AAFAD;AAIA;;;;AAIA,SAAgBE,yBAAyB,CAACJ,UAAmB;EAC3D,IAAIA,UAAU,CAACK,QAAQ,KAAK,cAAc,EAAE;IAC1C;IACA,OAAO,SAAS;;EAElB,OAAOF,UAAU,CAACH,UAAU,CAAC,CAACM,OAAO,CACnC,sCAAsC,EACtC,EAAE,CACH;AACH;AATAJ;AAWA;;;;;;;AAOA,SAAgBK,SAAS,CAACP,UAAmB;EAC3C,IAAIA,UAAU,CAACK,QAAQ,KAAK,cAAc,EAAE;IAC1C;IACA,OAAO,OAAO;;EAEhB,OAAON,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;AAC7D;AANAN;AAQA;;;;;;AAMA,SAAgBO,iBAAiB,CAACT,UAAmB;EACnD,OAAOD,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;AAC1D;AAFAN;AAIA;;;;;;AAMA,SAAgBQ,MAAM,CAACV,UAAmB;EACxCF,KAAK,CAAC,eAAe,EAAEE,UAAU,CAAC;EAClC,OAAOW,QAAQ,CACbZ,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CAC9B,uDAAuD,CACxD,CAAC,CAAC,CAAC,CACL;AACH;AAPAN;AASA;;;;;;AAMA,SAAgBU,UAAU,CAACZ,UAAmB;EAC5C,OACGA,UAAU,CAACa,QAAQ,GAChBb,UAAU,CAACa,QAAQ,CAACD,UAAU,GAC9BZ,UAAU,CAACY,UAAU;AAE7B;AANAV;AAQA;;;;;AAKA,SAAgBY,aAAa,CAACd,UAAmB;EAC/C,IAAIA,UAAU,CAACK,QAAQ,KAAK,cAAc,EAAE;IAC1C,OAAO,EAAE,CAAC,CAAC;;;EAEb,IAAIU,SAAS,GAAGhB,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CAAC,kBAAkB,CAAC;EAEpE,IAAI,CAACO,SAAS,EAAE;IACd,OAAO,IAAI;;EAGb,IAAIC,GAAG,GAAGL,QAAQ,CAACI,SAAS,CAAC,CAAC,CAAC,CAAC;EAEhC,QAAQR,SAAS,CAACP,UAAU,CAAC;IAC3B,KAAK,KAAK;IACV,KAAK,MAAM;IACX,KAAK,OAAO;IACZ,KAAK,QAAQ;MACX,OAAOgB,GAAG,GAAG,CAAC;IAEhB,KAAK,OAAO;MACV,OAAOA,GAAG;IAEZ;MACElB,KAAK,CACH,yCAAyC,EACzCC,cAAc,CAACC,UAAU,CAAC,CAC3B;EAAC;AAER;AA5BAE;AA8BA;;;;AAIA,SAAgBe,aAAa,CAACjB,UAAmB;EAC/C,OAAOW,QAAQ,CACbZ,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CAAC,yBAAyB,CAAC,CAAC,CAAC,CAAC,CAC/D;AACH;AAJAN;AAMA;AACA,SAAgBgB,OAAO,CAAClB,UAAmB;EACzC,OAAOD,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CAAC,UAAU,CAAC,IAAI,IAAI;AAC7D;AAFAN;AAIA;AACA,SAAgBiB,cAAc,CAACnB,UAAmB;EAChD,OACEkB,OAAO,CAAClB,UAAU,CAAC;EACnB;EACA;EACA;EACAD,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CAC9B,kDAAkD,CACnD,IAAI,IAAI;AAEb;AAVAN;AAYA;;;;;AAKA,SAAgBkB,YAAY,CAACpB,UAAmB;EAC9C;EACA;EACA;EACA,OAAOW,QAAQ,CAACU,oBAAoB,CAACrB,UAAU,CAAC,CAAC;AACnD;AALAE;AAOA;;;;AAIA,SAAgBmB,oBAAoB,CAACrB,UAAmB;EACtD,OAAOD,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CACrC,oDAAoD,CACrD,CAAC,CAAC,CAAC;AACN;AAJAN;AAMA;AACA,SAAgBoB,QAAQ,CAACtB,UAAmB;EAC1C,OAAOD,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CAAC,WAAW,CAAC,IAAI,IAAI;AAC9D;AAFAN;AAIA;AACA,SAAgBqB,SAAS,CAACvB,UAAmB;EAC3C,OAAOD,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CAAC,YAAY,CAAC,IAAI,IAAI;AAC/D;AAFAN;AAIA;AACA,SAAgBsB,MAAM,CAACxB,UAAmB;EACxC,OAAOD,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CAAC,SAAS,CAAC,IAAI,IAAI;AAC5D;AAFAN;AAIA;AACA,SAAgBuB,WAAW,CAACzB,UAAmB;EAC7C,OACED,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CAC9B,6CAA6C,CAC9C,IAAI,IAAI;AAEb;AANAN;AAQA;;;;AAIA,SAAgBwB,aAAa,CAAC1B,UAAmB;EAC/C,OAAOD,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CACrC,2BAA2B,CAC5B,CAAC,CAAC,CAAoB;AACzB;AAJAN;AAMA;;;;AAIA,SAAgByB,YAAY,CAAC3B,UAAmB;EAC9C,OAAOG,UAAU,CAACH,UAAU,CAAC,CAAC4B,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAwB;AACpE;AAFA1B;AAIA;;;;;;AAMA,SAAgB2B,SAAS,CAAC7B,UAAmB;EAC3C,IACEO,SAAS,CAACP,UAAU,CAAC,KAAK,UAAU,IACpCY,UAAU,CAACZ,UAAU,CAAC,KAAK,UAAU,EACrC;IACA,OAAO,CAAC;;EAEV,IAAIyB,WAAW,CAACzB,UAAU,CAAC,IAAI0B,aAAa,CAAC1B,UAAU,CAAC,KAAK,UAAU,EAAE;IACvE,IACEO,SAAS,CAACP,UAAU,CAAC,KAAK,QAAQ,IAClCO,SAAS,CAACP,UAAU,CAAC,KAAK,OAAO,EACjC;MACA,OAAO,CAAC;;IAEV,IAAImB,cAAc,CAACnB,UAAU,CAAC,EAAE;MAC9B,OAAO,CAAC;;;EAGZ,OAAO,CAAC;AACV;AAnBAE;AAqBA;AACA,SAAgB4B,gBAAgB,CAAC9B,UAAmB;EAClD,MAAM+B,KAAK,GAAG,CAAC,eAAe,EAAE,UAAU,CAAC;EAC3C,OAAOA,KAAK,CAACC,QAAQ,CAACzB,SAAS,CAACP,UAAU,CAAC,CAAC;AAC9C;AAHAE;AAKA;;;;;AAKA,SAAgB+B,cAAc,CAC5BjC,UAAmB,EACnBkC,QAAyB;EAEzBpC,KAAK,CAAC,eAAe,EAAEE,UAAU,CAAC;EAClC,uCACKA,UAAU;IAEbC,gBAAgB,kCACXD,UAAU,CAACC,gBAAgB;MAE9BF,cAAc,EAAEC,UAAU,CAACC,gBAAgB,CAACF,cAAc,CAACO,OAAO,CAChE,iDAAiD,EACjD,GAAG,GAAG4B,QAAQ;IACf;EAAA;AAGP;AAjBAhC;AAmBA;;;;;AAKA,SAAgBiC,wBAAwB,CAACC,UAAkB;EACzD,OAAOA,UAAU,CAAC9B,OAAO,CACvB,+CAA+C,EAC/C,QAAQ,CAAC;EACT;EAAA,CACD;AACH;;AANAJ;AAQA;;;;;AAKA,SAAgBmC,aAAa,CAACrC,UAAmB;EAC/C,IAAIoC,UAAU,GAAGrC,cAAc,CAACC,UAAU,CAAC;EAC3C,IAAIsC,aAAa,GAAWF,UAAU,CAAC5B,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;EAC/D,IAAI+B,UAAU,GAAYH,UAAU,CAAC5B,KAAK,CAAC,SAAS,CAAC,IAAI,IAAI;EAC7D,OAAO+B,UAAU,GAAG,IAAIC,eAAE,CAACF,aAAa,CAAC,CAACG,GAAG,EAAE,GAAG,IAAID,eAAE,CAACF,aAAa,CAAC;AACzE;AALApC;AAOA;AACA,SAAgBwC,cAAc,CAAC1C,UAAmB;EAChD,IAAIA,UAAU,CAACa,QAAQ,IAAIb,UAAU,CAACa,QAAQ,CAAC8B,QAAQ,EAAE;IACvD,OAAO3C,UAAU,CAACa,QAAQ,CAAC8B,QAAQ;;EAGrC,IAAI3C,UAAU,CAAC2C,QAAQ,EAAE;IACvB,OAAO3C,UAAU,CAAC2C,QAAQ;;EAG5B;EACA,IAAIC,cAAc,GAChB7C,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC;EAC3D;EAEA;EACAoC,cAAc,GAAGT,wBAAwB,CAACS,cAAc,CAAC;EAEzD;EACA,IAAIC,MAAM,GAAY,uBAAS,EAAC7C,UAAU,CAAC;EAC3C6C,MAAM,CAAC5C,gBAAgB,CAACF,cAAc,GAAG6C,cAAc;EACvD,OAAOC,MAAM;EAEb;EACA;AACF;;AAxBA3C;AA0BA;;;;;AAKA,SAAgB4C,aAAa,CAAC9C,UAAmB,EAAE+C,MAAe;EAChE,IAAIF,MAAe;EACnB,QAAQtC,SAAS,CAACP,UAAU,CAAC;IAC3B,KAAK,SAAS;MACZ;MACA,IAAIA,UAAU,CAACgD,OAAO,EAAE;QACtB,OAAOhD,UAAU,CAACgD,OAAO;;MAE3B,IAAIhD,UAAU,CAACa,QAAQ,IAAIb,UAAU,CAACa,QAAQ,CAACmC,OAAO,EAAE;QACtD,OAAOhD,UAAU,CAACa,QAAQ,CAACmC,OAAO;;MAGpC;MACA,IAAIC,iBAAiB,GAAGjD,UAAU,CAACkD,qBAAqB;MACxDpD,KAAK,CAAC,sBAAsB,EAAEmD,iBAAiB,CAAC;MAChD;MACA,IAAIA,iBAAiB,KAAKE,SAAS,EAAE;QACnC,IAAIC,eAAe,GAAGL,MAAM,CAACE,iBAAiB,CAAC,CAACjD,UAAU;QAC1D,OAAOoD,eAAe,CAACJ,OAAO,IAAII,eAAe,CAACvC,QAAQ,CAACmC,OAAO;;MAGpE;MACA;MACA,IAAIK,aAAa,GAAGtD,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CAClD,wBAAwB,CACzB,CAAC,CAAC,CAAC;MACJ;MACA;MACA;MACA;MAEA;MACA6C,aAAa,GAAGlB,wBAAwB,CAACkB,aAAa,CAAC;MAEvD,IAAIC,SAAS,GAAGnD,UAAU,CAACH,UAAU,CAAC,CAACQ,KAAK,CAC1C,oCAAoC,CACrC,CAAC,CAAC,CAAC;MACJ;MACA;MACA;MAEA;MACAqC,MAAM,GAAG,uBAAS,EAAC7C,UAAU,CAAC;MAC9B6C,MAAM,CAAC5C,gBAAgB,GAAG;QACxBF,cAAc,EAAEsD,aAAa;QAC7BlD,UAAU,EAAEmD;OACb;MACD,OAAOT,MAAM;IAEf,KAAK,OAAO;MACV;MACA;MACAA,MAAM,GAAG,uBAAS,EAAC7C,UAAU,CAAC;MAC9B6C,MAAM,CAAC5C,gBAAgB,GAAG;QACxBF,cAAc,EAAE,WAAW;QAC3BI,UAAU,EAAE;OACb;MACD,OAAO0C,MAAM;IACf;MACE/C,KAAK,CAAC,4BAA4B,CAAC;EAAC;AAE1C;AA7DAI;AA+DA;;;;AAIA,SAAgBqD,eAAe,CAACvD,UAAmB,EAAE+C,MAAe;EAClE,IAAIF,MAAe;EACnB;EACA,IAAI7C,UAAU,CAACwD,SAAS,EAAE;IACxB,OAAOxD,UAAU,CAACwD,SAAS;;EAE7B,IAAIxD,UAAU,CAACa,QAAQ,IAAIb,UAAU,CAACa,QAAQ,CAAC2C,SAAS,EAAE;IACxD,OAAOxD,UAAU,CAACa,QAAQ,CAAC2C,SAAS;;EAGtC;EACA,IAAIP,iBAAiB,GAAGjD,UAAU,CAACkD,qBAAqB;EACxDpD,KAAK,CAAC,sBAAsB,EAAEmD,iBAAiB,CAAC;EAChD;EACA,IAAIA,iBAAiB,KAAKE,SAAS,EAAE;IACnC,IAAIC,eAAe,GAAGL,MAAM,CAACE,iBAAiB,CAAC,CAACjD,UAAU;IAC1D,OAAOoD,eAAe,CAACI,SAAS,IAAIJ,eAAe,CAACvC,QAAQ,CAAC2C,SAAS;;EAGxE;EACA;EACA,IAAIC,eAAe,GAAG1D,cAAc,CAACC,UAAU,CAAC,CAACQ,KAAK,CACpD,6BAA6B,CAC9B,CAAC,CAAC,CAAC;EACJ;EACA;EACA;EACA;EAEA;EACAiD,eAAe,GAAGtB,wBAAwB,CAACsB,eAAe,CAAC;EAE3D,IAAIC,WAAW,GAAGvD,UAAU,CAACH,UAAU,CAAC,CAACQ,KAAK,CAC5C,oCAAoC,CACrC,CAAC,CAAC,CAAC;EACJ;EACA;EACA;EAEA;EACAqC,MAAM,GAAG,uBAAS,EAAC7C,UAAU,CAAC;EAC9B6C,MAAM,CAAC5C,gBAAgB,GAAG;IACxBF,cAAc,EAAE0D,eAAe;IAC/BtD,UAAU,EAAEuD;GACb;EACD,OAAOb,MAAM;AACf;AA9CA3C;AAgDA;;;;;;AAMA,SAAgByD,UAAU,CAAC3D,UAAmB;EAC5C,IAAI4D,UAAU,GAAG5D,UAAU,CAACa,QAAQ,IAAIb,UAAU;EAClD,IAAI4D,UAAU,CAACC,cAAc,IAAID,UAAU,CAACE,oBAAoB,EAAE;IAChE,OAAO,CACLF,UAAU,CAACC,cAAc,CAACF,UAAU,EACpCC,UAAU,CAACE,oBAAoB,CAACH,UAAU,CAC3C;GACF,MAAM;IACL,OAAOR,SAAS;;AAEpB;AAVAjD;AAYA;;;;;AAKA,SAAgB6D,YAAY,CAACC,IAAa;EACxC,IAAIA,IAAI,CAAC3D,QAAQ,KAAK,oBAAoB,EAAE;IAC1C,OAAO8C,SAAS;;EAElB,IAAIa,IAAI,CAACC,IAAI,KAAKd,SAAS,EAAE;IAC3B;IACA,OAAOa,IAAI,CAACC,IAAI;;EAElB;EACA,IAAID,IAAI,CAACE,aAAa,EAAE;IACtB,OAAO,aAAa;;EAEtB,OAAOF,IAAI,CAACG,IAAI,KAAK,EAAE,GAAG,UAAU,GAAG,UAAU;AACnD;AAbAjE;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAgBkE,aAAa,CAACJ,IAAa;EACzC,MAAMxD,KAAK,GAAGT,cAAc,CAACiE,IAAI,CAAC,CAACxD,KAAK,CAAC,sBAAsB,CAAC;EAChE,OAAOA,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAG2C,SAAS;AACrC;AAHAjD;AAKA;;;;;;AAMA,SAAgBmE,UAAU,CAACL,IAAa;EACtCA,IAAI,GAAGA,IAAI,CAACnD,QAAQ,IAAImD,IAAI;EAC5B,IACEA,IAAI,CAAC3D,QAAQ,KAAK,oBAAoB,IACtC2D,IAAI,CAAC3D,QAAQ,KAAK,kBAAkB,EACpC;IACA,OAAO8C,SAAS;;EAElB,IAAIa,IAAI,CAACM,eAAe,KAAKnB,SAAS,EAAE;IACtC;IACA,OAAOa,IAAI,CAACM,eAAe;;EAE7B;EACA,IAAIN,IAAI,CAACO,OAAO,EAAE;IAChB,OAAO,SAAS;;EAElB,IAAIP,IAAI,CAACQ,QAAQ,EAAE;IACjB;IACA;IACA,OAAO,MAAM;;EAEf,OAAO,YAAY;AACrB;AAtBAtE;AAwBA;;;;;AAKA,SAAgBuE,iBAAiB,CAACzE,UAAmB;EACnD,OAAOA,UAAU,CAAC0E,KAAK,CAACC,IAAI,CAC1BX,IAAI,IACFA,IAAI,CAAC3D,QAAQ,KAAK,oBAAoB,KACrC0D,YAAY,CAACC,IAAI,CAAC,KAAK,UAAU,IAAID,YAAY,CAACC,IAAI,CAAC,KAAK,SAAS,CAAC,IACvEK,UAAU,CAACL,IAAI,CAAC,KAAK,SAAS,CACjC;AACH;AAPA9D;AASA;;;;AAIA,SAAgB0E,eAAe,CAC7BZ,IAAa,EACba,qBAA+B;EAE/B,QAAQb,IAAI,CAAC3D,QAAQ;IACnB,KAAK,oBAAoB;MACvB,IAAI2D,IAAI,CAACpD,UAAU,KAAK,QAAQ,IAAIoD,IAAI,CAACpD,UAAU,KAAK,UAAU,EAAE;QAClE,OAAOkE,uBAAuB,CAACd,IAAI,EAAEa,qBAAqB,CAAC;OAC5D,MAAM;QACL,OAAO1B,SAAS;;IAEpB,KAAK,iBAAiB;MACpB,OAAO4B,oBAAoB,CAACf,IAAI,EAAEa,qBAAqB,CAAC;IAC1D,KAAK,iBAAiB;MACpB,OAAOG,oBAAoB,CAAChB,IAAI,EAAEa,qBAAqB,CAAC;IAC1D,KAAK,qBAAqB;MACxB,IAAIb,IAAI,CAACpD,UAAU,KAAK,QAAQ,EAAE;QAChC,OAAOqE,qBAAqB,CAACjB,IAAI,EAAEa,qBAAqB,CAAC;OAC1D,MAAM;QACL,OAAO1B,SAAS;;IAEpB;MACE,OAAOA,SAAS;EAAC;AAEvB;AAxBAjD;AA0BA;AACA,SAAS4E,uBAAuB,CAC9Bd,IAAa,EACba,qBAA+B;EAM/B,IAAIZ,IAAI,GAAGF,YAAY,CAACC,IAAI,CAAC;EAC7B,IAAIM,eAAe,GAAGD,UAAU,CAACL,IAAI,CAAC;EACtC,IAAIO,OAAO,GAAGD,eAAe,KAAK,SAAS;EAC3C,IAAIY,MAAM;EACV,QAAQjB,IAAI;IACV,KAAK,UAAU;MACb,IAAIE,IAAI,GAAGH,IAAI,CAACG,IAAI;MACpB,IAAIgB,OAAO,GAAGC,eAAe,CAC3BpB,IAAI,CAACqB,gBAAgB,CAAC1B,UAAU,EAChCkB,qBAAqB,CACtB;MACDK,MAAM,GAAGE,eAAe,CACtBpB,IAAI,CAACL,UAAU,CAACA,UAAU,EAC1BkB,qBAAqB,CACtB;MACD,OAAO;QACLS,IAAI,EAAE,UAAU;QAChBnB,IAAI;QACJe,MAAM;QACNC,OAAO;QACPb;OACD;IACH,KAAK,aAAa;MAChBY,MAAM,GAAGE,eAAe,CACtBpB,IAAI,CAACL,UAAU,CAACA,UAAU,EAC1BkB,qBAAqB,CACtB;MACD;MACA,OAA6B;QAC3BS,IAAI,EAAE,aAAa;QACnBJ,MAAM;QACNZ,eAAe;QACfC;OACD;IACH,KAAK,UAAU;MACb;MACA,OAA0B;QACxBe,IAAI,EAAE,UAAU;QAChBhB,eAAe;QACfC;OACD;IACH,KAAK,SAAS;MACZ;MACA,OAAyB;QACvBe,IAAI,EAAE,SAAS;QACfhB,eAAe;QACfC;OACD;EAAC;AAER;AAMA,SAASQ,oBAAoB,CAC3Bf,IAAa,EACba,qBAA+B;EAE/B,IAAIK,MAAM,GAAGE,eAAe,CAC1BpB,IAAI,CAACL,UAAU,CAACA,UAAkC,EAClDkB,qBAAqB,CACtB;EACD,IAAIV,IAAI,GAAGH,IAAI,CAACG,IAAI;EACpB,IAAIoB,SAAS,GAAGvB,IAAI,CAACuB,SAAS;EAC9B,OAAO;IACLD,IAAI,EAAE,OAAO;IACbJ,MAAM;IACNf,IAAI;IACJoB;GACD;AACH;AAEA,SAASP,oBAAoB,CAC3BhB,IAAa,EACba,qBAA+B;EAE/B,IAAIK,MAAM,GAAGE,eAAe,CAC1BpB,IAAI,CAACL,UAAU,CAACA,UAAU,EAC1BkB,qBAAqB,CACtB;EACD,IAAIV,IAAI,GAAGH,IAAI,CAACG,IAAI;EACpB,OAAO;IACLmB,IAAI,EAAE,OAAO;IACbJ,MAAM;IACNf;GACD;AACH;AAMA,SAASiB,eAAe,CACtBV,KAAU,EACVG,qBAA+B;EAE/B,OAAOH,KAAK,CAACc,GAAG,CAACxB,IAAI,IAAIyB,cAAc,CAACzB,IAAI,EAAEa,qBAAqB,CAAC,CAAC;AACvE;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASY,cAAc,CACrBzB,IAAO,EACPa,qBAA+B;EAE/B,IAAIV,IAAI,GAAGH,IAAI,CAACG,IAAI,CAAC,CAAC;EACtB,IAAIuB,UAA2B;EAC/B,IAAIC,YAAY,GAAWvF,yBAAyB,CAAC4D,IAAI,CAAC;EAC1D;EACA,IAAIzD,SAAS,CAACyD,IAAI,CAAC,KAAK,OAAO,EAAE;IAC/B,IAAIrB,QAAQ,GAAGqB,IAAI,CAACnD,QAAQ,GAAGmD,IAAI,CAACnD,QAAQ,CAAC8B,QAAQ,GAAGqB,IAAI,CAACrB,QAAQ;IACrE,IAAIiD,OAAO,GAAGH,cAAc,CAAC9C,QAAQ,EAAEkC,qBAAqB,CAAC;IAC7D,IAAIgB,WAAW,GAAG1E,cAAc,CAAC6C,IAAI,CAAC,GAAG,IAAI,GAAG,IAAI5C,YAAY,CAAC4C,IAAI,CAAC,GAAG;IACzE,MAAM8B,SAAS,GAAkB;MAC/B3B,IAAI;MACJmB,IAAI,EAAEM,OAAO,CAACN,IAAI,GAAGO,WAAW;MAChCH,UAAU,EAAEE,OAAO,CAACF,UAAU;MAC9BC;KACD;IAED,IAAI,SAAS,IAAI3B,IAAI,EAAE;MACrB,OAAO+B,gCACFD,SAAS;QACZE,OAAO,EAAEhC,IAAI,CAACgC;MAAO,EACN;KAClB,MAAM;MACL,OAAOF,SAAyB;;;EAGpC,IAAIG,aAAa,GAAGC,SAAS,CAAClC,IAAI,EAAEa,qBAAqB,CAAC;EAC1D;EACA,IAAItE,SAAS,CAACyD,IAAI,CAAC,KAAK,QAAQ,EAAE;IAChC,IAAImC,EAAE,GAAGzF,MAAM,CAACsD,IAAI,CAAC;IACrB,IAAIoC,oBAAoB,GAAGvB,qBAAqB,CAACsB,EAAE,CAAC;IACpD,IAAIC,oBAAoB,KAAKjD,SAAS,EAAE;MACtC,IAAIkD,aAAa,GAAGlG,UAAU,CAAC6D,IAAI,CAAC;MACpC,MAAM,IAAIsC,MAAM,CAACC,2BAA2B,CAC1CJ,EAAE,CAACK,QAAQ,EAAE,EACbH,aAAa,CACd;;IAEHX,UAAU,GAAGN,eAAe,CAC1BgB,oBAAoB,CAACK,OAAO,EAC5B5B,qBAAqB,CACtB;;EAGH,MAAMiB,SAAS,GAAkB;IAC/B3B,IAAI;IACJmB,IAAI,EAAEW,aAAa;IACnBP,UAAU;IACVC;GACD;EAED,IAAI,SAAS,IAAI3B,IAAI,EAAE;IACrB,OAAO+B,gCACFD,SAAS;MACZE,OAAO,EAAEhC,IAAI,CAACgC;IAAO,EACN;GAClB,MAAM;IACL,OAAOF,SAAyB;;AAEpC;AAEA;AACA;AACA;AACA;AACA,SAASI,SAAS,CAAClC,IAAa,EAAEa,qBAA+B;EAC/D,IAAI6B,SAAS,GAAGjG,iBAAiB,CAACuD,IAAI,CAAC,CAAC,CAAC;EACzC,QAAQ0C,SAAS;IACf,KAAK,UAAU;MACb,OAAO,SAAS;IAClB,KAAK,QAAQ;MACX,OAAO,OAAO;IAAE;IAClB,KAAK,MAAM;MAAE;QACX,MAAMC,WAAW,GAAGjG,MAAM,CAACsD,IAAI,CAAC;QAChC,MAAMoC,oBAAoB,GAAGvB,qBAAqB,CAAC8B,WAAW,CAAC;QAC/D,IAAIP,oBAAoB,KAAKjD,SAAS,EAAE;UACtC,MAAMkD,aAAa,GAAGlG,UAAU,CAAC6D,IAAI,CAAC;UACtC,MAAM,IAAIsC,MAAM,CAACC,2BAA2B,CAC1CI,WAAW,CAACH,QAAQ,EAAE,EACtBH,aAAa,CACd;;QAEH,MAAMO,UAAU,GAAGR,oBAAoB,CAACK,OAAO,CAACI,MAAM;QACtD,MAAMC,IAAI,GAAG,CAAC,GAAGC,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,IAAI,CAACL,UAAU,CAAC,GAAG,CAAC,CAAC;QACrD,OAAO,OAAOE,IAAI,EAAE;;IAEtB,KAAK,sBAAsB;MAAE;QAC3B,MAAMH,WAAW,GAAGjG,MAAM,CAACsD,IAAI,CAAC;QAChC,MAAMoC,oBAAoB,GAAGvB,qBAAqB,CAAC8B,WAAW,CAAC;QAC/D,IAAIP,oBAAoB,KAAKjD,SAAS,EAAE;UACtC,MAAMkD,aAAa,GAAGlG,UAAU,CAAC6D,IAAI,CAAC;UACtC,MAAM,IAAIsC,MAAM,CAACC,2BAA2B,CAC1CI,WAAW,CAACH,QAAQ,EAAE,EACtBH,aAAa,CACd;;QAEH,MAAMa,cAAc,GAAGd,oBAAoB,CAACc,cAAc;QAC1D,OAAOhB,SAAS,CAACgB,cAAc,EAAErC,qBAAqB,CAAC;;IAEzD;MACE,OAAO6B,SAAS;IAClB;IACA;IACA;IACA;IACA;IACA;EAAA;AAEJ;;AAEA,SAASzB,qBAAqB,CAC5BjB,IAAa,EACba,qBAA+B;EAE/B/E,KAAK,CAAC,iBAAiB,EAAEkE,IAAI,CAAC;EAC9B,IAAIG,IAAI,GAAGH,IAAI,CAACG,IAAI;EACpB,IAAI;IAAEe,MAAM;IAAEC;EAAO,CAAE,GAAGgC,gBAAgB,CAACnD,IAAI,EAAEa,qBAAqB,CAAC;EACvE,IAAIuC,SAAS,GAAGhC,eAAe,CAACF,MAAM,EAAEL,qBAAqB,CAAC;EAC9D,IAAIwC,UAAU,GAAGjC,eAAe,CAACD,OAAO,EAAEN,qBAAqB,CAAC;EAChE,OAAO;IACLS,IAAI,EAAE,UAAU;IAChBnB,IAAI;IACJe,MAAM,EAAEkC,SAAS;IACjBjC,OAAO,EAAEkC,UAAU;IACnB/C,eAAe,EAAE;GAClB;AACH;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAgB6C,gBAAgB,CAC9BnD,IAAa,EACba,qBAA+B;EAE/B,IAAIyC,QAAQ,GAAYtD,IAAI,CAACnD,QAAQ,IAAImD,IAAI;EAC7C,IAAIkB,MAAM,GAAc,EAAE;EAC1B,OAAO3E,SAAS,CAAC+G,QAAQ,CAAC,KAAK,OAAO,IAAI/G,SAAS,CAAC+G,QAAQ,CAAC,KAAK,SAAS,EAAE;IAC3E,IAAIC,OAAO,GAAGzE,aAAa,CAACwE,QAAQ,CAAC,CAAC,CAAC;IACvCpC,MAAM,CAACsC,IAAI,iCAAMD,OAAO;MAAEpD,IAAI,EAAE;IAAE,GAAG,CAAC,CAAC;IACvC,QAAQ5D,SAAS,CAAC+G,QAAQ,CAAC;MACzB,KAAK,OAAO;QACVA,QAAQ,GAAGA,QAAQ,CAAC3E,QAAQ;QAC5B;MACF,KAAK,SAAS;QACZ2E,QAAQ,GAAGA,QAAQ,CAAC9D,SAAS;QAC7B;IAAM;;EAGZ;EACA;EACA,IAAIjD,SAAS,CAAC+G,QAAQ,CAAC,KAAK,QAAQ,EAAE;IACpC,IAAInB,EAAE,GAAGzF,MAAM,CAAC4G,QAAQ,CAAC;IACzB,IAAIlB,oBAAoB,GAAGvB,qBAAqB,CAACsB,EAAE,CAAC;IACpD,IAAIC,oBAAoB,KAAKjD,SAAS,EAAE;MACtC,IAAIkD,aAAa,GAAGlG,UAAU,CAACmH,QAAQ,CAAC;MACxC,MAAM,IAAIhB,MAAM,CAACC,2BAA2B,CAC1CJ,EAAE,CAACK,QAAQ,EAAE,EACbH,aAAa,CACd;;IAEH,IAAIlB,OAAO,GAAGiB,oBAAoB,CAACK,OAAO,CAACgB,MAAM,CAC/CC,MAAM,IAAInH,SAAS,CAACmH,MAAM,CAAC,KAAK,OAAO,IAAInH,SAAS,CAACmH,MAAM,CAAC,KAAK,SAAS,CAC3E;IACD,OAAO;MAAExC,MAAM;MAAEC;IAAO,CAAE,CAAC,CAAC;GAC7B,MAAM;IACL;IACA,OAAO;MAAED,MAAM;MAAEC,OAAO,EAAE,iCAAMmC,QAAQ;QAAEnD,IAAI,EAAE;MAAE;IAAG,CAAE;;AAE3D;AAtCAjE","names":["debug","typeIdentifier","definition","typeDescriptions","exports","typeString","typeStringWithoutLocation","nodeType","replace","typeClass","match","typeClassLongForm","typeId","parseInt","visibility","typeName","specifiedSize","specified","num","decimalPlaces","isArray","isDynamicArray","staticLength","staticLengthAsString","isStruct","isMapping","isEnum","isReference","referenceType","contractKind","split","stackSize","isSimpleConstant","types","includes","spliceLocation","location","regularizeTypeIdentifier","identifier","rationalValue","absoluteValue","isNegative","bn_js_1","neg","baseDefinition","baseType","baseIdentifier","result","keyDefinition","scopes","keyType","baseDeclarationId","referencedDeclaration","undefined","baseDeclaration","keyIdentifier","keyString","valueDefinition","valueType","valueIdentifier","valueString","parameters","typeObject","parameterTypes","returnParameterTypes","functionKind","node","kind","isConstructor","name","functionClass","mutability","stateMutability","payable","constant","isContractPayable","nodes","some","definitionToAbi","referenceDeclarations","functionDefinitionToAbi","eventDefinitionToAbi","errorDefinitionToAbi","getterDefinitionToAbi","inputs","outputs","parametersToAbi","returnParameters","type","anonymous","map","parameterToAbi","components","internalType","baseAbi","arraySuffix","parameter","Object","indexed","abiTypeString","toAbiType","id","referenceDeclaration","typeToDisplay","Common","UnknownUserDefinedTypeError","toString","members","basicType","referenceId","numOptions","length","bits","Math","ceil","log2","underlyingType","getterParameters","inputsAbi","outputsAbi","baseNode","keyNode","push","filter","member"],"sourceRoot":"","sources":["../../../lib/ast/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}