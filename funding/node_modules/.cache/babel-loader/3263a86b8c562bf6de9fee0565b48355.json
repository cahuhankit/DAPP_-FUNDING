{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abifyReturndataDecoding = exports.abifyLogDecoding = exports.abifyCalldataDecoding = exports.abifyResult = exports.abifyType = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:abify\");\nconst Format = __importStar(require(\"./format\"));\nconst Common = __importStar(require(\"./common\"));\nconst Conversion = __importStar(require(\"./conversion\"));\n/** @category ABIfication */\nfunction abifyType(dataType, userDefinedTypes) {\n  switch (dataType.typeClass) {\n    //we only need to specially handle types that don't go in\n    //the ABI, or that have some information loss when going\n    //in the ABI\n    //note that we do need to handle arrays, due to recursion!\n    //First: types that do not go in the ABI\n    case \"mapping\":\n    case \"magic\":\n    case \"type\":\n    case \"options\":\n      return undefined;\n    //Next: address & contract, these can get handled together\n    case \"address\":\n    case \"contract\":\n      return {\n        typeClass: \"address\",\n        kind: \"general\",\n        typeHint: Format.Types.typeString(dataType)\n      };\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          return {\n            typeClass: \"function\",\n            visibility: \"external\",\n            kind: \"general\",\n            typeHint: Format.Types.typeString(dataType)\n          };\n        case \"internal\":\n          //these don't go in the ABI\n          return undefined;\n      }\n      break;\n    //to satisfy TypeScript\n    //the complex cases: struct & enum\n    case \"struct\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n        if (!fullType.memberTypes) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n        const memberTypes = fullType.memberTypes.map(_ref => {\n          let {\n            name,\n            type: memberType\n          } = _ref;\n          return {\n            name,\n            type: abifyType(memberType, userDefinedTypes)\n          };\n        });\n        return {\n          typeClass: \"tuple\",\n          typeHint: Format.Types.typeString(fullType),\n          memberTypes\n        };\n      }\n    case \"enum\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n        if (!fullType.options) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n        let numOptions = fullType.options.length;\n        let bits = 8 * Math.ceil(Math.log2(numOptions) / 8);\n        return {\n          typeClass: \"uint\",\n          bits,\n          typeHint: Format.Types.typeString(fullType)\n        };\n      }\n    case \"userDefinedValueType\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n        if (!fullType.underlyingType) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n        const abifiedUnderlying = abifyType(fullType.underlyingType, userDefinedTypes);\n        return Object.assign(Object.assign({}, abifiedUnderlying), {\n          typeHint: Format.Types.typeStringWithoutLocation(dataType)\n        });\n      }\n    //finally: arrays\n    case \"array\":\n      return Object.assign(Object.assign({}, dataType), {\n        typeHint: Format.Types.typeString(dataType),\n        baseType: abifyType(dataType.baseType, userDefinedTypes)\n      });\n    //default case: just leave as-is\n    default:\n      return dataType;\n  }\n}\nexports.abifyType = abifyType;\n/** @category ABIfication */\nfunction abifyResult(result, userDefinedTypes) {\n  switch (result.type.typeClass) {\n    case \"mapping\": //doesn't go in ABI\n    case \"magic\": //doesn't go in ABI\n    case \"type\":\n      //doesn't go in ABI\n      return undefined;\n    case \"address\":\n      //abify the type but leave the value alone\n      return Object.assign(Object.assign({}, result), {\n        type: abifyType(result.type, userDefinedTypes)\n      });\n    case \"contract\":\n      {\n        let coercedResult = result;\n        switch (coercedResult.kind) {\n          case \"value\":\n            return {\n              type: abifyType(result.type, userDefinedTypes),\n              kind: \"value\",\n              value: {\n                asAddress: coercedResult.value.address,\n                rawAsHex: coercedResult.value.rawAddress\n              }\n            };\n          case \"error\":\n            switch (coercedResult.error.kind) {\n              case \"ContractPaddingError\":\n                return {\n                  type: abifyType(result.type, userDefinedTypes),\n                  kind: \"error\",\n                  error: {\n                    kind: \"AddressPaddingError\",\n                    paddingType: coercedResult.error.paddingType,\n                    raw: coercedResult.error.raw\n                  }\n                };\n              default:\n                //other contract errors are generic errors!\n                //but TS doesn't know this so we coerce\n                return Object.assign(Object.assign({}, coercedResult), {\n                  type: abifyType(result.type, userDefinedTypes)\n                });\n            }\n        }\n        break; //to satisfy typescript\n      }\n\n    case \"function\":\n      switch (result.type.visibility) {\n        case \"external\":\n          {\n            let coercedResult = result;\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n          }\n        case \"internal\":\n          //these don't go in the ABI\n          return undefined;\n      }\n      break;\n    //to satisfy TypeScript\n    case \"struct\":\n      {\n        let coercedResult = result;\n        switch (coercedResult.kind) {\n          case \"value\":\n            if (coercedResult.reference !== undefined) {\n              return undefined; //no circular values in the ABI!\n            }\n\n            let abifiedMembers = coercedResult.value.map(_ref2 => {\n              let {\n                name,\n                value: member\n              } = _ref2;\n              return {\n                name,\n                value: abifyResult(member, userDefinedTypes)\n              };\n            });\n            return {\n              kind: \"value\",\n              type: abifyType(result.type, userDefinedTypes),\n              value: abifiedMembers\n            };\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes) //note: may throw exception\n            });\n        }\n      }\n\n    case \"userDefinedValueType\":\n      {\n        const coercedResult = result;\n        switch (coercedResult.kind) {\n          case \"value\":\n            return abifyResult(coercedResult.value, userDefinedTypes);\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n        }\n        break; //to satisfy TS :P\n      }\n\n    case \"enum\":\n      {\n        //NOTE: this is the one case where errors are converted to non-error values!!\n        //(other than recursively, I mean)\n        //be aware!\n        let coercedResult = result;\n        let uintType = abifyType(result.type, userDefinedTypes); //may throw exception\n        switch (coercedResult.kind) {\n          case \"value\":\n            return {\n              type: uintType,\n              kind: \"value\",\n              value: {\n                asBN: coercedResult.value.numericAsBN.clone()\n              }\n            };\n          case \"error\":\n            switch (coercedResult.error.kind) {\n              case \"EnumOutOfRangeError\":\n                return {\n                  type: uintType,\n                  kind: \"value\",\n                  value: {\n                    asBN: coercedResult.error.rawAsBN.clone()\n                  }\n                };\n              case \"EnumPaddingError\":\n                return {\n                  type: uintType,\n                  kind: \"error\",\n                  error: {\n                    kind: \"UintPaddingError\",\n                    paddingType: coercedResult.error.paddingType,\n                    raw: coercedResult.error.raw\n                  }\n                };\n              case \"EnumNotFoundDecodingError\":\n                let numericValue = coercedResult.error.rawAsBN.clone();\n                if (numericValue.bitLength() <= uintType.bits) {\n                  return {\n                    type: uintType,\n                    kind: \"value\",\n                    value: {\n                      asBN: numericValue\n                    }\n                  };\n                } else {\n                  return {\n                    type: uintType,\n                    kind: \"error\",\n                    error: {\n                      kind: \"UintPaddingError\",\n                      paddingType: \"left\",\n                      raw: Conversion.toHexString(numericValue)\n                    }\n                  };\n                }\n              default:\n                return {\n                  type: uintType,\n                  kind: \"error\",\n                  error: coercedResult.error\n                };\n            }\n        }\n      }\n    case \"array\":\n      {\n        let coercedResult = result;\n        switch (coercedResult.kind) {\n          case \"value\":\n            if (coercedResult.reference !== undefined) {\n              return undefined; //no circular values in the ABI!\n            }\n\n            let abifiedMembers = coercedResult.value.map(member => abifyResult(member, userDefinedTypes));\n            return {\n              kind: \"value\",\n              type: abifyType(result.type, userDefinedTypes),\n              value: abifiedMembers\n            };\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n        }\n      }\n    default:\n      return result;\n    //just coerce :-/\n  }\n}\n\nexports.abifyResult = abifyResult;\n/** @category ABIfication */\nfunction abifyCalldataDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n  switch (decoding.kind) {\n    case \"function\":\n    case \"constructor\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n          value: abifyResult(argument.value, userDefinedTypes)\n        }))\n      });\n    default:\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\"\n      });\n  }\n}\nexports.abifyCalldataDecoding = abifyCalldataDecoding;\n/** @category ABIfication */\nfunction abifyLogDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n  return Object.assign(Object.assign({}, decoding), {\n    decodingMode: \"abi\",\n    arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n      value: abifyResult(argument.value, userDefinedTypes)\n    }))\n  });\n}\nexports.abifyLogDecoding = abifyLogDecoding;\n/** @category ABIfication */\nfunction abifyReturndataDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n  switch (decoding.kind) {\n    case \"return\":\n    case \"revert\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n          value: abifyResult(argument.value, userDefinedTypes)\n        }))\n      });\n    case \"bytecode\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        immutables: undefined\n      });\n    default:\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\"\n      });\n  }\n}\nexports.abifyReturndataDecoding = abifyReturndataDecoding;","map":{"version":3,"mappings":"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","names":["debug","abifyType","dataType","userDefinedTypes","typeClass","undefined","kind","typeHint","Format","Types","typeString","visibility","fullType","memberTypes","typeToDisplay","Common","UnknownUserDefinedTypeError","id","map","name","type","memberType","options","numOptions","length","bits","Math","ceil","log2","underlyingType","abifiedUnderlying","typeStringWithoutLocation","baseType","exports","abifyResult","result","coercedResult","value","asAddress","address","rawAsHex","rawAddress","error","paddingType","raw","Object","reference","abifiedMembers","member","uintType","asBN","numericAsBN","clone","rawAsBN","numericValue","bitLength","Conversion","toHexString","abifyCalldataDecoding","decoding","decodingMode","arguments","argument","abifyLogDecoding","abifyReturndataDecoding","immutables"],"sourceRoot":"","sources":["../../lib/abify.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}