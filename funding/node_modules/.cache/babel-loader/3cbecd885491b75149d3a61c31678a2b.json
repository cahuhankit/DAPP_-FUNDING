{"ast":null,"code":"\"use strict\";\n\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.definitionToStoredType = exports.definitionToType = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:ast:import\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst Compiler = __importStar(require(\"../../compiler\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst import_1 = require(\"../../contexts/import\");\n//NOTE: the following function will *not* work for arbitrary nodes! It will,\n//however, work well enough for what we need.  I.e., it will:\n//1. work when given the actual variable definition as the node,\n//2. work when given an elementary type as the node,\n//3. work when given a user-defined type as the node,\n//4. produce something of the correct size in all cases.\n//Use beyond that is at your own risk!\n//NOTE: set forceLocation to *null* to force no location. leave it undefined\n//to not force a location.\nfunction definitionToType(definition, compilationId, compiler, forceLocation) {\n  let typeClass = Utils.typeClass(definition);\n  let typeHint = Utils.typeStringWithoutLocation(definition);\n  switch (typeClass) {\n    case \"bool\":\n      return {\n        typeClass,\n        typeHint\n      };\n    case \"address\":\n      {\n        switch (Compiler.Utils.solidityFamily(compiler)) {\n          case \"unknown\": //I guess?\n          case \"pre-0.5.0\":\n            return {\n              typeClass,\n              kind: \"general\",\n              typeHint\n            };\n          default:\n            return {\n              typeClass,\n              kind: \"specific\",\n              payable: Utils.typeIdentifier(definition) === \"t_address_payable\"\n            };\n        }\n        break; //to satisfy typescript\n      }\n\n    case \"uint\":\n      {\n        let bytes = Utils.specifiedSize(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          typeHint\n        };\n      }\n    case \"int\":\n      {\n        //typeScript won't let me group these for some reason\n        let bytes = Utils.specifiedSize(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          typeHint\n        };\n      }\n    case \"fixed\":\n      {\n        //typeScript won't let me group these for some reason\n        let bytes = Utils.specifiedSize(definition);\n        let places = Utils.decimalPlaces(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          places,\n          typeHint\n        };\n      }\n    case \"ufixed\":\n      {\n        let bytes = Utils.specifiedSize(definition);\n        let places = Utils.decimalPlaces(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          places,\n          typeHint\n        };\n      }\n    case \"string\":\n      {\n        if (forceLocation === null) {\n          return {\n            typeClass,\n            typeHint\n          };\n        }\n        let location = forceLocation || Utils.referenceType(definition);\n        return {\n          typeClass,\n          location,\n          typeHint\n        };\n      }\n    case \"bytes\":\n      {\n        let length = Utils.specifiedSize(definition);\n        if (length !== null) {\n          return {\n            typeClass,\n            kind: \"static\",\n            length,\n            typeHint\n          };\n        } else {\n          if (forceLocation === null) {\n            return {\n              typeClass,\n              kind: \"dynamic\",\n              typeHint\n            };\n          }\n          let location = forceLocation || Utils.referenceType(definition);\n          return {\n            typeClass,\n            kind: \"dynamic\",\n            location,\n            typeHint\n          };\n        }\n      }\n    case \"array\":\n      {\n        let baseDefinition = Utils.baseDefinition(definition);\n        let baseType = definitionToType(baseDefinition, compilationId, compiler, forceLocation);\n        let location = forceLocation || Utils.referenceType(definition);\n        if (Utils.isDynamicArray(definition)) {\n          if (forceLocation !== null) {\n            return {\n              typeClass,\n              baseType,\n              kind: \"dynamic\",\n              location,\n              typeHint\n            };\n          } else {\n            return {\n              typeClass,\n              baseType,\n              kind: \"dynamic\",\n              typeHint\n            };\n          }\n        } else {\n          let length = new bn_js_1.default(Utils.staticLengthAsString(definition));\n          if (forceLocation !== null) {\n            return {\n              typeClass,\n              baseType,\n              kind: \"static\",\n              length,\n              location,\n              typeHint\n            };\n          } else {\n            return {\n              typeClass,\n              baseType,\n              kind: \"static\",\n              length,\n              typeHint\n            };\n          }\n        }\n      }\n    case \"mapping\":\n      {\n        let keyDefinition = Utils.keyDefinition(definition);\n        //note that we can skip the scopes argument here! that's only needed when\n        //a general node, rather than a declaration, is being passed in\n        let keyType = definitionToType(keyDefinition, compilationId, compiler, null);\n        //suppress the location on the key type (it'll be given as memory but\n        //this is meaningless)\n        //also, we have to tell TypeScript ourselves that this will be an elementary\n        //type; it has no way of knowing that\n        debug(\"definition: %O\", definition);\n        let valueDefinition = Utils.valueDefinition(definition);\n        let valueType = definitionToType(valueDefinition, compilationId, compiler, forceLocation);\n        if (forceLocation === null) {\n          return {\n            typeClass,\n            keyType,\n            valueType\n          };\n        }\n        return {\n          typeClass,\n          keyType,\n          valueType,\n          location: \"storage\"\n        };\n      }\n    case \"function\":\n      {\n        //WARNING! This case will not work unless given the actual\n        //definition!  It should return something *roughly* usable, though.\n        let visibility = Utils.visibility(definition); //undefined if bad node\n        let mutability = Utils.mutability(definition); //undefined if bad node\n        let [inputParameters, outputParameters] = Utils.parameters(definition) || [[], []]; //HACK\n        //note: don't force a location on these! use the listed location!\n        let inputParameterTypes = inputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));\n        let outputParameterTypes = outputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));\n        switch (visibility) {\n          case \"internal\":\n            return {\n              typeClass,\n              visibility,\n              mutability,\n              inputParameterTypes,\n              outputParameterTypes\n            };\n          case \"external\":\n            return {\n              typeClass,\n              visibility,\n              kind: \"specific\",\n              mutability,\n              inputParameterTypes,\n              outputParameterTypes\n            };\n        }\n        break; //to satisfy typescript\n      }\n\n    case \"struct\":\n      {\n        let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);\n        let qualifiedName = typeHint.match(/struct (.*)/)[1];\n        let definingContractName;\n        let typeName;\n        if (qualifiedName.includes(\".\")) {\n          [definingContractName, typeName] = qualifiedName.split(\".\");\n        } else {\n          typeName = qualifiedName;\n          //leave definingContractName undefined\n        }\n\n        if (forceLocation === null) {\n          if (definingContractName) {\n            return {\n              typeClass,\n              kind: \"local\",\n              id,\n              typeName,\n              definingContractName\n            };\n          } else {\n            return {\n              typeClass,\n              kind: \"global\",\n              id,\n              typeName\n            };\n          }\n        }\n        let location = forceLocation || Utils.referenceType(definition);\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            location\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName,\n            location\n          };\n        }\n      }\n    case \"enum\":\n      {\n        let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);\n        let qualifiedName = typeHint.match(/enum (.*)/)[1];\n        let definingContractName;\n        let typeName;\n        if (qualifiedName.includes(\".\")) {\n          [definingContractName, typeName] = qualifiedName.split(\".\");\n        } else {\n          typeName = qualifiedName;\n          //leave definingContractName undefined\n        }\n\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName\n          };\n        }\n      }\n    case \"userDefinedValueType\":\n      {\n        let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);\n        let definingContractName;\n        let typeName;\n        if (typeHint.includes(\".\")) {\n          [definingContractName, typeName] = typeHint.split(\".\");\n        } else {\n          typeName = typeHint;\n          //leave definingContractName undefined\n        }\n\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName\n          };\n        }\n      }\n    case \"contract\":\n      {\n        let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);\n        let typeName = typeHint.match(/(contract|library|interface) (.*)/)[2];\n        //note: we use the type string rather than the type identifier\n        //in order to avoid having to deal with the underscore problem\n        let contractKind = Utils.contractKind(definition);\n        return {\n          typeClass,\n          kind: \"native\",\n          id,\n          typeName,\n          contractKind\n        };\n      }\n    case \"magic\":\n      {\n        let typeIdentifier = Utils.typeIdentifier(definition);\n        let variable = typeIdentifier.match(/^t_magic_(.*)$/)[1];\n        return {\n          typeClass,\n          variable\n        };\n      }\n  }\n}\nexports.definitionToType = definitionToType;\n//whereas the above takes variable definitions, this takes the actual type\n//definition\nfunction definitionToStoredType(definition, compilationId, compiler, referenceDeclarations) {\n  switch (definition.nodeType) {\n    case \"StructDefinition\":\n      {\n        const {\n          id,\n          typeName,\n          definingContractName,\n          definingContract\n        } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n        const memberTypes = definition.members.map(member => ({\n          name: member.name,\n          type: definitionToType(member, compilationId, compiler, null)\n        }));\n        if (definingContract) {\n          return {\n            typeClass: \"struct\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            memberTypes\n          };\n        } else {\n          return {\n            typeClass: \"struct\",\n            kind: \"global\",\n            id,\n            typeName,\n            memberTypes\n          };\n        }\n      }\n    case \"EnumDefinition\":\n      {\n        const {\n          id,\n          typeName,\n          definingContractName,\n          definingContract\n        } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n        const options = definition.members.map(member => member.name);\n        if (definingContract) {\n          return {\n            typeClass: \"enum\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            options\n          };\n        } else {\n          return {\n            typeClass: \"enum\",\n            kind: \"global\",\n            id,\n            typeName,\n            options\n          };\n        }\n      }\n    case \"UserDefinedValueTypeDefinition\":\n      {\n        const {\n          id,\n          typeName,\n          definingContractName,\n          definingContract\n        } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n        let underlyingType =\n        //we know it's that, TS doesn't\n        definitionToType(definition.underlyingType, compilationId, compiler, null); //final null doesn't matter here\n        if (definingContract) {\n          return {\n            typeClass: \"userDefinedValueType\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            underlyingType\n          };\n        } else {\n          return {\n            typeClass: \"userDefinedValueType\",\n            kind: \"global\",\n            id,\n            typeName,\n            underlyingType\n          };\n        }\n      }\n    case \"ContractDefinition\":\n      {\n        let id = (0, import_1.makeTypeId)(definition.id, compilationId);\n        let typeName = definition.name;\n        let contractKind = definition.contractKind;\n        let payable = Utils.isContractPayable(definition);\n        return {\n          typeClass: \"contract\",\n          kind: \"native\",\n          id,\n          typeName,\n          contractKind,\n          payable\n        };\n      }\n  }\n}\nexports.definitionToStoredType = definitionToStoredType;\nfunction getDefiningInfo(definition, compilationId, compiler, referenceDeclarations) {\n  const id = (0, import_1.makeTypeId)(definition.id, compilationId);\n  let definingContractName;\n  let typeName;\n  if (definition.canonicalName) {\n    if (definition.canonicalName.includes(\".\")) {\n      [definingContractName, typeName] = definition.canonicalName.split(\".\");\n    } else {\n      typeName = definition.canonicalName;\n    }\n  } else {\n    //due to a bug, in 0.8.8 UDVTs lack a canonicalName.\n    //so we'll set typeName based on name instead of canonicalName,\n    //and set definingContractName below based on definingContract.\n    //(this does mean that we'll mess up a bit if referenceDeclarations\n    //is not passed... but realistically that shouldn't come up?  really the\n    //same kind of hapepns for every type)\n    typeName = definition.name;\n  }\n  let definingContract = undefined;\n  ;\n  if (referenceDeclarations) {\n    let contractDefinition = Object.values(referenceDeclarations).find(node => node.nodeType === \"ContractDefinition\" && node.nodes.some(subNode => (0, import_1.makeTypeId)(subNode.id, compilationId) === id));\n    if (contractDefinition) {\n      definingContract = definitionToStoredType(contractDefinition, compilationId, compiler); //can skip reference declarations\n      if (!definingContractName) {\n        definingContractName = contractDefinition.name;\n      }\n    }\n  }\n  return {\n    definingContract,\n    definingContractName,\n    typeName,\n    id\n  };\n}","map":{"version":3,"mappings":"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","names":["debug","definitionToType","definition","compilationId","compiler","forceLocation","typeClass","Utils","typeHint","typeStringWithoutLocation","Compiler","solidityFamily","kind","payable","typeIdentifier","bytes","specifiedSize","bits","places","decimalPlaces","location","referenceType","length","baseDefinition","baseType","isDynamicArray","bn_js_1","staticLengthAsString","keyDefinition","keyType","valueDefinition","valueType","visibility","mutability","inputParameters","outputParameters","parameters","inputParameterTypes","map","parameter","outputParameterTypes","id","typeId","qualifiedName","match","definingContractName","typeName","includes","split","contractKind","variable","exports","definitionToStoredType","referenceDeclarations","nodeType","definingContract","getDefiningInfo","memberTypes","members","member","name","type","options","underlyingType","isContractPayable","canonicalName","undefined","contractDefinition","Object","values","find","node","nodes","some","subNode"],"sourceRoot":"","sources":["../../../../lib/ast/import/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}