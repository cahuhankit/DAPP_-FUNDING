{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.message = void 0;\n/**\n * @protected\n *\n * @packageDocumentation\n */\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:format:utils:exception\");\nconst Format = __importStar(require(\"../common\"));\nconst AstUtils = __importStar(require(\"../../ast/utils\"));\n//this function gives an error message\n//for those errors that are meant to possibly\n//be wrapped in a DecodingError and thrown\nfunction message(error) {\n  switch (error.kind) {\n    case \"UserDefinedTypeNotFoundError\":\n      let typeName = Format.Types.isContractDefinedType(error.type) ? error.type.definingContractName + \".\" + error.type.typeName : error.type.typeName;\n      return `Unknown ${error.type.typeClass} type ${typeName} of id ${error.type.id}`;\n    case \"UnsupportedConstantError\":\n      return `Unsupported constant type ${AstUtils.typeClass(error.definition)}`;\n    case \"UnusedImmutableError\":\n      return \"Cannot read unused immutable\";\n    case \"ReadErrorStack\":\n      return `Can't read stack from position ${error.from} to ${error.to}`;\n    case \"ReadErrorBytes\":\n      return `Can't read ${error.length} bytes from ${error.location} starting at ${error.start}`;\n    case \"ReadErrorStorage\":\n      if (error.range.length) {\n        return `Can't read ${error.range.length} bytes from storage starting at index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)}`;\n      } else {\n        return `Can't read storage from index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)} to index ${error.range.to.index} in ${slotAddressPrintout(error.range.to.slot)}`;\n      }\n    case \"StorageNotSuppliedError\":\n      return `Unknown storage at slot ${error.slot.toString()}`;\n    //note: not actually used at present\n    case \"CodeNotSuppliedError\":\n      return `Unknown code for address ${error.address}`;\n    //note: not actually used at present\n  }\n}\n\nexports.message = message;\nfunction slotAddressPrintout(slot) {\n  if (slot.key !== undefined && slot.path !== undefined) {\n    // mapping reference\n    let {\n      type: keyEncoding,\n      value: keyValue\n    } = keyInfoForPrinting(slot.key);\n    return \"keccak(\" + keyValue + \" as \" + keyEncoding + \", \" + slotAddressPrintout(slot.path) + \") + \" + slot.offset.toString();\n  } else if (slot.path !== undefined) {\n    const pathAddressPrintout = slotAddressPrintout(slot.path);\n    return slot.hashPath ? \"keccak(\" + pathAddressPrintout + \")\" + slot.offset.toString() : pathAddressPrintout + slot.offset.toString();\n  } else {\n    return slot.offset.toString();\n  }\n}\n//this is like the old toSoliditySha3Input, but for debugging purposes ONLY\n//it will NOT produce correct input to soliditySha3\n//please use mappingKeyAsHex instead if you wish to encode a mapping key.\nfunction keyInfoForPrinting(input) {\n  switch (input.type.typeClass) {\n    case \"uint\":\n      return {\n        type: \"uint\",\n        value: input.value.asBN.toString()\n      };\n    case \"int\":\n      return {\n        type: \"int\",\n        value: input.value.asBN.toString()\n      };\n    case \"fixed\":\n      return {\n        type: `fixed256x${input.type.places}`,\n        value: input.value.asBig.toString()\n      };\n    case \"ufixed\":\n      return {\n        type: `ufixed256x${input.type.places}`,\n        value: input.value.asBig.toString()\n      };\n    case \"bool\":\n      //this is the case that won't work as valid input to soliditySha3 :)\n      return {\n        type: \"uint\",\n        value: input.value.asBoolean.toString()\n      };\n    case \"bytes\":\n      switch (input.type.kind) {\n        case \"static\":\n          return {\n            type: \"bytes32\",\n            value: input.value.asHex\n          };\n        case \"dynamic\":\n          return {\n            type: \"bytes\",\n            value: input.value.asHex\n          };\n      }\n    case \"address\":\n      return {\n        type: \"address\",\n        value: input.value.asAddress\n      };\n    case \"string\":\n      let coercedInput = input;\n      switch (coercedInput.value.kind) {\n        case \"valid\":\n          return {\n            type: \"string\",\n            value: coercedInput.value.asString\n          };\n        case \"malformed\":\n          return {\n            type: \"bytes\",\n            value: coercedInput.value.asHex\n          };\n      }\n    //fixed and ufixed are skipped for now\n  }\n}","map":{"version":3,"mappings":"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","names":["debug","message","error","kind","typeName","Format","Types","isContractDefinedType","type","definingContractName","typeClass","id","AstUtils","definition","from","to","length","location","start","range","index","slotAddressPrintout","slot","toString","address","exports","key","undefined","path","keyEncoding","value","keyValue","keyInfoForPrinting","offset","pathAddressPrintout","hashPath","input","asBN","places","asBig","asBoolean","asHex","asAddress","coercedInput","asString"],"sourceRoot":"","sources":["../../../../lib/format/utils/exception.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}