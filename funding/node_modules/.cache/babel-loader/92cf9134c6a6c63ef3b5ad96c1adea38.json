{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.integerCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:integer\");\nconst Format = __importStar(require(\"../format\"));\nconst dispatch_1 = require(\"./dispatch\");\nconst errors_1 = require(\"./errors\");\nconst Conversion = __importStar(require(\"../conversion\"));\nconst Utils = __importStar(require(\"./utils\"));\nconst Messages = __importStar(require(\"./messages\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst big_js_1 = __importDefault(require(\"big.js\"));\nconst bytes_1 = require(\"./bytes\");\n//NOTE: all cases called \"integerFrom...\" also work for enums.\n//The cases labeled \"enumFrom...\" work only for enums.\n//there are no cases that work only for integers and not enums,\n//because we always want input for integers to also be valid for enums.\nconst integerFromStringCases = [integerFromIntegerString, enumFromNameString, integerFromScientificOrUnits, integerFromNegatedBaseString, integerFromStringFailureCase];\n//note: doesn't include UDVT case,\n//or error case\nconst integerFromWrappedValueCases = [integerFromCodecIntegerValue, integerFromCodecEnumValue, integerFromCodecDecimalValue];\nconst integerCasesBasic = [...integerFromStringCases, integerFromNumber, integerFromBoxedNumber, integerFromBoxedString, integerFromBigint, integerFromBN, integerFromBig, integerFromUint8ArrayLike, ...integerFromWrappedValueCases, integerFromCodecEnumError, integerFromCodecUdvtValue, integerFromOther //must go last!\n];\n\nexports.integerCases = [integerFromIntegerTypeValueInput, enumFromEnumTypeValueInput, ...integerCasesBasic];\nfunction* integerFromIntegerString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  if (input.trim() === \"\") {\n    //bigint accepts this but we shouldn't\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, dataType.typeClass === \"enum\" ? Messages.badEnumMessage : Messages.nonNumericMessage);\n  }\n  const stripped = Utils.removeUnderscoresNumeric(input);\n  let asBN;\n  try {\n    //we'll use BigInt to parse integer strings, as it's pretty good at it.\n    //Note that it accepts hex/octal/binary with prefixes 0x, 0o, 0b.\n    const asBigInt = BigInt(stripped);\n    asBN = Conversion.toBN(asBigInt);\n  } catch (_a) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input string was not an integer string\");\n  }\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\n//this case handles both scientific notation, and numbers with units\nfunction* integerFromScientificOrUnits(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  if (input.trim() === \"\") {\n    //the code below accepts this but we shouldn't\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1,\n    //only specificity 1 since it's already specificity 5 above\n    dataType.typeClass === \"enum\" ? Messages.badEnumMessage : Messages.nonNumericMessage);\n  }\n  const stripped = Utils.removeUnderscoresNoHex(input);\n  let [_, quantityString, unit] = stripped.match(/^(.*?)(|wei|gwei|shannon|finney|szabo|ether)\\s*$/i); //units will be case insensitive; note this always matches\n  quantityString = quantityString.trim(); //Big rejects whitespace, let's allow it\n  const unitPlacesTable = {\n    //we could accept all of web3's units here, but, that's a little much;\n    //we'll just accept the most common ones\n    \"\": 0,\n    wei: 0,\n    gwei: 9,\n    shannon: 9,\n    szabo: 12,\n    finney: 15,\n    ether: 18\n  };\n  let quantity;\n  try {\n    quantity = quantityString.match(/^\\s*$/) ? new big_js_1.default(1) //allow just \"ether\" e.g.\n    : new big_js_1.default(quantityString);\n  } catch (_a) {\n    quantity = null;\n  }\n  if (quantity === null) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string using scientific notation or units\");\n  }\n  const places = unitPlacesTable[unit.toLowerCase()];\n  const asBig = Conversion.shiftBigUp(quantity, places);\n  if (Conversion.countDecimalPlaces(asBig) !== 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, unit !== \"\" ? \"Input numeric value was not an integral number of wei\" : Messages.nonIntegerMessage);\n  }\n  const asBN = Conversion.toBN(asBig);\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromNegatedBaseString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  if (!input.match(/^\\s*-/)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a negated numeric string\");\n  }\n  const stripped = Utils.removeUnderscoresNumeric(input);\n  let positiveAsBN;\n  const [_, positiveString] = stripped.match(/^\\s*-(.*)$/);\n  try {\n    const positive = BigInt(positiveString);\n    positiveAsBN = Conversion.toBN(positive);\n  } catch (_a) {\n    positiveAsBN = null;\n  }\n  if (positiveAsBN === null || positiveString === \"\" || positiveString.match(/^(-|\\s)/)) {\n    //no double negation, no bare \"-\", and no space after the minus!\n    //(we do this as a string check, rather than checking if\n    //positiveAsBN is >=0, in order to prevent entering e.g. \"--\" or \"- 2\")\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.nonNumericMessage);\n  }\n  const asBN = positiveAsBN.neg();\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* enumFromNameString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  if (dataType.typeClass !== \"enum\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.nonNumericMessage);\n  }\n  const fullType = Format.Types.fullType(dataType, wrapOptions.userDefinedTypes);\n  const options = fullType.options;\n  const components = input.split(\".\");\n  const finalComponent = components[components.length - 1];\n  debug(\"components: %O\", components);\n  debug(\"dataType: %O\", dataType);\n  debug(\"options: %O\", options);\n  //the enum can be qualified.  if it's qualified, does the type match?\n  let matchingType;\n  switch (components.length) {\n    case 1:\n      //not qualified, automatically matches\n      matchingType = true;\n      break;\n    case 2:\n      //qualified by type name, does it match?\n      matchingType = components[0] === dataType.typeName;\n      break;\n    case 3:\n      //qualified by type name and contract name, does it match?\n      matchingType = dataType.kind === \"local\" && components[0] === dataType.definingContractName && components[1] === dataType.typeName;\n      break;\n    default:\n      //no valid reason to have 3 or more periods\n      //(and split cannot return an empty array)\n      matchingType = false;\n  }\n  debug(\"matchingType: %O\", matchingType);\n  const numeric = matchingType ? options.indexOf(finalComponent) : -1; //if type doesn't match, just indicate error\n  debug(\"numeric: %d\", numeric);\n  if (numeric === -1) {\n    //-1 comes from either our setting it manually above to indicate error,\n    //or from a failed indexOf call\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.badEnumMessage);\n  }\n  const asBN = new bn_js_1.default(numeric); //whew!\n  //now: unlike in every other case, we can skip validation!\n  //so let's just wrap and return!\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      numericAsBN: asBN,\n      name: finalComponent //we know it matches!\n    }\n  };\n}\n\nfunction* integerFromStringFailureCase(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, dataType.typeClass === \"enum\" ? Messages.badEnumMessage : Messages.nonNumericMessage);\n}\nfunction* integerFromBN(dataType, input, wrapOptions) {\n  if (!bn_js_1.default.isBN(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a BN\");\n  }\n  const asBN = input.clone();\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromBigint(dataType, input, wrapOptions) {\n  if (typeof input !== \"bigint\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a bigint\");\n  }\n  const asBN = Conversion.toBN(input);\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromNumber(dataType, input, wrapOptions) {\n  if (typeof input !== \"number\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a number\");\n  }\n  if (!Number.isInteger(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);\n  }\n  if (!Number.isSafeInteger(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonSafeMessage);\n  }\n  const asBN = new bn_js_1.default(input);\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromBig(dataType, input, wrapOptions) {\n  if (!Conversion.isBig(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Big\");\n  }\n  if (Conversion.countDecimalPlaces(input) !== 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);\n  }\n  const asBN = Conversion.toBN(input);\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromUint8ArrayLike(dataType, input, wrapOptions) {\n  if (!Utils.isUint8ArrayLike(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Uint8Array-like\");\n  }\n  //the next series of checks is delegated to a helper fn\n  (0, bytes_1.validateUint8ArrayLike)(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)\n  const asBN = Conversion.toBN(new Uint8Array(input)); //I am surprised TS accepts this!\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromBoxedNumber(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedNumber(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed number\");\n  }\n  //unbox and try again\n  return yield* integerFromNumber(dataType, input.valueOf(), wrapOptions);\n}\nfunction* integerFromBoxedString(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n  }\n  //unbox and try again\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, integerFromStringCases);\n}\nfunction* integerFromCodecIntegerValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"int\" && input.type.typeClass !== \"uint\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  if (!wrapOptions.loose && (input.type.typeClass !== dataType.typeClass || input.type.bits !== dataType.bits)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  const asBN = input.value.asBN.clone();\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromCodecDecimalValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"fixed\" && input.type.typeClass !== \"ufixed\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  if (!wrapOptions.loose) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  const asBN = Conversion.toBN(input.value.asBig);\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromCodecEnumValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"enum\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1,\n    //only specificity 1 due to EnumError case\n    Messages.errorResultMessage);\n  }\n  if (!wrapOptions.loose && (dataType.typeClass !== \"enum\" || input.type.id !== dataType.id)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  const asBN = input.value.numericAsBN.clone();\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromCodecEnumError(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"enum\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"error\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Wrapped result was a value rather than an error\");\n  }\n  if (!wrapOptions.loose && (dataType.typeClass !== \"enum\" || input.type.id !== dataType.id)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  const coercedInput = input;\n  //only one specific kind of error will be allowed\n  if (coercedInput.error.kind !== \"EnumOutOfRangeError\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  const asBN = coercedInput.error.rawAsBN.clone();\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromCodecUdvtValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"userDefinedValueType\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, integerFromWrappedValueCases);\n}\nfunction* integerFromIntegerTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n  if (!input.type.match(/^u?int\\d*$/)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, dataType.typeClass === \"enum\" ? 1 : 5,\n    //use specificity 5 when getting an integer (which have no alternative),\n    //but specificity 1 when getting an enum (which have enum type/value input also)\n    Messages.specifiedTypeMessage(input.type));\n  }\n  const [_, typeClass, bitsAsString] = input.type.match(/^(u?int)(\\d*)$/);\n  const bits = bitsAsString ? Number(bitsAsString) : 256; //defaults to 256\n  //(not using the WORD_SIZE constant due to fixed types bringing its applicability\n  //here into question)\n  const requiredTypeClass = dataType.typeClass !== \"enum\" ? dataType.typeClass : \"uint\"; //allow underlying uint type to work for enums\n  //(we handle \"enum\" given as type in a separate case below)\n  const requiredBits = dataType.typeClass !== \"enum\" ? dataType.bits : 8 * Math.ceil(Math.log2(Format.Types.fullType(dataType, wrapOptions.userDefinedTypes).options.length) / 8); //compute required bits for enum type (sorry)\n  if (requiredTypeClass !== typeClass || requiredBits !== bits) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n  //extract value & try again, with loose option turned on\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), integerCasesBasic);\n}\nfunction* enumFromEnumTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n  if (input.type !== \"enum\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, dataType.typeClass === \"enum\" ? 5 : 1,\n    //use specificity 5 when getting an enum (which will have also failed integer type/value input),\n    //but specificity 1 when getting an integer (to which this doesn't really apply)\n    Messages.specifiedTypeMessage(input.type));\n  }\n  if (dataType.typeClass !== \"enum\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n  //extract value & try again, with loose option turned on\n  //(we'll also coerce the type on this one since we know it's\n  //going to be an enum value :P )\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), integerCasesBasic);\n}\nfunction* integerFromOther(dataType, input, wrapOptions) {\n  const request = {\n    kind: \"integer\",\n    input\n  };\n  const response = yield request;\n  if (response.kind !== \"integer\") {\n    throw new errors_1.BadResponseTypeError(request, response);\n  }\n  if (response.value === null) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason || Messages.unrecognizedNumberMessage(dataType));\n  }\n  const asBN = Conversion.toBN(response.value);\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction validateAndWrap(dataType, asBN, wrapOptions, input //just for erroring\n) {\n  switch (dataType.typeClass) {\n    case \"uint\":\n      if (asBN.isNeg() || asBN.bitLength() > dataType.bits) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeMessage);\n      }\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asBN\n        }\n      };\n    case \"int\":\n      if (!asBN.isNeg() && asBN.bitLength() >= dataType.bits ||\n      //>= since signed\n      asBN.isNeg() && asBN.neg().subn(1).bitLength() >= dataType.bits\n      //bitLength doesn't work great for negatives so we do this instead\n      ) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeMessage);\n      }\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asBN\n        }\n      };\n    case \"enum\":\n      const fullType = Format.Types.fullType(dataType, wrapOptions.userDefinedTypes);\n      if (asBN.isNeg() || asBN.gten(fullType.options.length)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeEnumMessage);\n      }\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          numericAsBN: asBN,\n          name: fullType.options[asBN.toNumber()]\n        }\n      };\n  }\n}","map":{"version":3,"mappings":"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","names":["debug","integerFromStringCases","integerFromIntegerString","enumFromNameString","integerFromScientificOrUnits","integerFromNegatedBaseString","integerFromStringFailureCase","integerFromWrappedValueCases","integerFromCodecIntegerValue","integerFromCodecEnumValue","integerFromCodecDecimalValue","integerCasesBasic","integerFromNumber","integerFromBoxedNumber","integerFromBoxedString","integerFromBigint","integerFromBN","integerFromBig","integerFromUint8ArrayLike","integerFromCodecEnumError","integerFromCodecUdvtValue","integerFromOther","exports","integerFromIntegerTypeValueInput","enumFromEnumTypeValueInput","dataType","input","wrapOptions","errors_1","name","trim","typeClass","Messages","badEnumMessage","nonNumericMessage","stripped","Utils","removeUnderscoresNumeric","asBN","asBigInt","BigInt","Conversion","toBN","validateAndWrap","removeUnderscoresNoHex","_","quantityString","unit","match","unitPlacesTable","wei","gwei","shannon","szabo","finney","ether","quantity","big_js_1","places","toLowerCase","asBig","shiftBigUp","countDecimalPlaces","nonIntegerMessage","positiveAsBN","positiveString","positive","neg","fullType","Format","Types","userDefinedTypes","options","components","split","finalComponent","length","matchingType","typeName","kind","definingContractName","numeric","indexOf","bn_js_1","type","value","numericAsBN","isBN","clone","Number","isInteger","isSafeInteger","nonSafeMessage","isBig","isUint8ArrayLike","Uint8Array","isBoxedNumber","valueOf","isBoxedString","isWrappedResult","wrappedTypeMessage","errorResultMessage","loose","bits","id","coercedInput","error","rawAsBN","isTypeValueInput","specifiedTypeMessage","bitsAsString","requiredTypeClass","requiredBits","Math","ceil","log2","request","response","partiallyRecognized","reason","unrecognizedNumberMessage","isNeg","bitLength","outOfRangeMessage","subn","gten","outOfRangeEnumMessage","toNumber"],"sourceRoot":"","sources":["../../../lib/wrap/integer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}