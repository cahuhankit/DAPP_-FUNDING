{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeRevert = exports.decodeReturndata = exports.decodeEvent = exports.decodeCalldata = exports.decodeVariable = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:core\");\nconst Ast = __importStar(require(\"./ast\"));\nconst AbiData = __importStar(require(\"./abi-data\"));\nconst Topic = __importStar(require(\"./topic\"));\nconst Evm = __importStar(require(\"./evm\"));\nconst Contexts = __importStar(require(\"./contexts\"));\nconst abify_1 = require(\"./abify\");\nconst Conversion = __importStar(require(\"./conversion\"));\nconst errors_1 = require(\"./errors\");\nconst read_1 = __importDefault(require(\"./read\"));\nconst decode_1 = __importDefault(require(\"./decode\"));\nconst web3_utils_1 = __importDefault(require(\"web3-utils\"));\n/**\n * @Category Decoding\n */\nfunction* decodeVariable(definition, pointer, info, compilationId) {\n  let compiler = info.currentContext.compiler;\n  let dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n  return yield* (0, decode_1.default)(dataType, pointer, info); //no need to pass an offset\n}\n\nexports.decodeVariable = decodeVariable;\n/**\n * @Category Decoding\n */\nfunction* decodeCalldata(info, isConstructor //ignored if context! trust context instead if have\n) {\n  const context = info.currentContext;\n  if (context === null) {\n    //if we don't know the contract ID, we can't decode\n    if (isConstructor) {\n      return {\n        kind: \"create\",\n        decodingMode: \"full\",\n        bytecode: Conversion.toHexString(info.state.calldata),\n        interpretations: {}\n      };\n    } else {\n      return {\n        kind: \"unknown\",\n        decodingMode: \"full\",\n        data: Conversion.toHexString(info.state.calldata),\n        interpretations: {}\n      };\n    }\n  }\n  const contextHash = context.context;\n  const contractType = Contexts.Import.contextToType(context);\n  isConstructor = context.isConstructor;\n  const allocations = info.allocations.calldata;\n  let allocation;\n  let selector;\n  //first: is this a creation call?\n  if (isConstructor) {\n    allocation = (allocations.constructorAllocations[contextHash] || {\n      input: undefined\n    }).input;\n  } else {\n    //skipping any error-handling on this read, as a calldata read can't throw anyway\n    let rawSelector = yield* (0, read_1.default)({\n      location: \"calldata\",\n      start: 0,\n      length: Evm.Utils.SELECTOR_SIZE\n    }, info.state);\n    selector = Conversion.toHexString(rawSelector);\n    allocation = ((allocations.functionAllocations[contextHash] || {})[selector] || {\n      input: undefined\n    }).input;\n  }\n  if (allocation === undefined) {\n    let abiEntry = null;\n    if (info.state.calldata.length === 0) {\n      //to hell with reads, let's just be direct\n      abiEntry = context.fallbackAbi.receive || context.fallbackAbi.fallback;\n    } else {\n      abiEntry = context.fallbackAbi.fallback;\n    }\n    return {\n      kind: \"message\",\n      class: contractType,\n      abi: abiEntry,\n      data: Conversion.toHexString(info.state.calldata),\n      decodingMode: \"full\",\n      interpretations: {}\n    };\n  }\n  let decodingMode = allocation.allocationMode; //starts out this way, degrades to ABI if necessary\n  debug(\"calldata decoding mode: %s\", decodingMode);\n  //you can't map with a generator, so we have to do this map manually\n  let decodedArguments = [];\n  for (const argumentAllocation of allocation.arguments) {\n    let value;\n    let dataType = decodingMode === \"full\" ? argumentAllocation.type : (0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes);\n    try {\n      value = yield* (0, decode_1.default)(dataType, argumentAllocation.pointer, info, {\n        abiPointerBase: allocation.offset,\n        allowRetry: decodingMode === \"full\"\n      });\n    } catch (error) {\n      if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n        debug(\"problem! retrying as ABI\");\n        debug(\"error: %O\", error);\n        //if a retry happens, we've got to do several things in order to switch to ABI mode:\n        //1. mark that we're switching to ABI mode;\n        decodingMode = \"abi\";\n        //2. abify all previously decoded values;\n        decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n          value: (0, abify_1.abifyResult)(argumentDecoding.value, info.userDefinedTypes)\n        }));\n        //3. retry this particular decode in ABI mode.\n        //(no try/catch on this one because we can't actually handle errors here!\n        //not that they should be occurring)\n        value = yield* (0, decode_1.default)((0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes),\n        //type is now abified!\n        argumentAllocation.pointer, info, {\n          abiPointerBase: allocation.offset\n        });\n        //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n        //so we don't need to do anything special there.\n      } else {\n        //we shouldn't be getting other exceptions, but if we do, we don't know\n        //how to handle them, so uhhhh just rethrow I guess??\n        throw error;\n      }\n    }\n    const name = argumentAllocation.name;\n    decodedArguments.push(name //deliberate general falsiness test\n    ? {\n      name,\n      value\n    } : {\n      value\n    });\n  }\n  if (isConstructor) {\n    return {\n      kind: \"constructor\",\n      class: contractType,\n      arguments: decodedArguments,\n      abi: allocation.abi,\n      bytecode: Conversion.toHexString(info.state.calldata.slice(0, allocation.offset)),\n      decodingMode,\n      interpretations: {}\n    };\n  } else {\n    return {\n      kind: \"function\",\n      class: contractType,\n      abi: allocation.abi,\n      arguments: decodedArguments,\n      selector,\n      decodingMode,\n      interpretations: {}\n    };\n  }\n}\nexports.decodeCalldata = decodeCalldata;\n/**\n * @Category Decoding\n */\nfunction decodeEvent(info, address) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return function* () {\n    const allocations = info.allocations.event;\n    const extras = options.extras || \"off\";\n    let rawSelector;\n    let selector;\n    let contractAllocations; //for non-anonymous events\n    let libraryAllocations; //similar\n    let contractAnonymousAllocations;\n    let libraryAnonymousAllocations;\n    const topicsCount = info.state.eventtopics.length;\n    //yeah, it's not great to read directly from the state like this (bypassing read), but what are you gonna do?\n    if (allocations[topicsCount]) {\n      if (topicsCount > 0) {\n        rawSelector = yield* (0, read_1.default)({\n          location: \"eventtopic\",\n          topic: 0\n        }, info.state);\n        selector = Conversion.toHexString(rawSelector);\n        if (allocations[topicsCount].bySelector[selector]) {\n          ({\n            contract: contractAllocations,\n            library: libraryAllocations\n          } = allocations[topicsCount].bySelector[selector]);\n        } else {\n          debug(\"no allocations for that selector!\");\n          contractAllocations = {};\n          libraryAllocations = {};\n        }\n      } else {\n        //if we don't have a selector, it means we don't have any non-anonymous events\n        contractAllocations = {};\n        libraryAllocations = {};\n      }\n      //now: let's get our allocations for anonymous events\n      ({\n        contract: contractAnonymousAllocations,\n        library: libraryAnonymousAllocations\n      } = allocations[topicsCount].anonymous);\n    } else {\n      //if there's not even an allocation for the topics count, we can't\n      //decode; we could do this the honest way of setting all four allocation\n      //objects to {}, but let's just short circuit\n      debug(\"no allocations for that topic count!\");\n      return [];\n    }\n    let contractContext;\n    if (address !== null) {\n      //now: what contract are we (probably) dealing with? let's get its code to find out\n      const codeBytes = yield {\n        type: \"code\",\n        address\n      };\n      const codeAsHex = Conversion.toHexString(codeBytes);\n      contractContext = Contexts.Utils.findContext(info.contexts, codeAsHex);\n    } else {\n      contractContext = info.currentContext;\n    }\n    let possibleContractAllocations; //excludes anonymous events\n    let possibleContractAnonymousAllocations;\n    let possibleExtraAllocations; //excludes anonymous events\n    let possibleExtraAnonymousAllocations;\n    const emittingContextHash = (contractContext || {\n      context: undefined\n    }).context;\n    if (emittingContextHash) {\n      //if we found the contract, maybe it's from that contract\n      const contractAllocation = contractAllocations[emittingContextHash];\n      const contractAnonymousAllocation = contractAnonymousAllocations[emittingContextHash];\n      possibleContractAllocations = contractAllocation || [];\n      possibleContractAnonymousAllocations = contractAnonymousAllocation || [];\n      //also, we need to set up the extras (everything that's from a\n      //non-library contract but *not* this one)\n      possibleExtraAllocations = [].concat(...Object.entries(contractAllocations).filter(_ref => {\n        let [key, _] = _ref;\n        return key !== emittingContextHash;\n      }).map(_ref2 => {\n        let [_, value] = _ref2;\n        return value;\n      }));\n      possibleExtraAnonymousAllocations = [].concat(...Object.entries(contractAnonymousAllocations).filter(_ref3 => {\n        let [key, _] = _ref3;\n        return key !== emittingContextHash;\n      }).map(_ref4 => {\n        let [_, value] = _ref4;\n        return value;\n      }));\n    } else {\n      //if we couldn't determine the contract, well, we have to assume it's from a library\n      debug(\"couldn't find context\");\n      possibleContractAllocations = [];\n      possibleContractAnonymousAllocations = [];\n      //or it's an extra, which could be any of the contracts\n      possibleExtraAllocations = [].concat(...Object.values(contractAllocations));\n      possibleExtraAnonymousAllocations = [].concat(...Object.values(contractAnonymousAllocations));\n    }\n    //now we get all the library allocations!\n    const possibleLibraryAllocations = [].concat(...Object.values(libraryAllocations));\n    const possibleLibraryAnonymousAllocations = [].concat(...Object.values(libraryAnonymousAllocations));\n    //now we put it all together!\n    const possibleAllocations = possibleContractAllocations.concat(possibleLibraryAllocations);\n    const possibleAnonymousAllocations = possibleContractAnonymousAllocations.concat(possibleLibraryAnonymousAllocations);\n    const possibleAllocationsTotalMinusExtras = possibleAllocations.concat(possibleAnonymousAllocations);\n    //...and also there's the extras\n    const possibleExtraAllocationsTotal = possibleExtraAllocations.concat(possibleExtraAnonymousAllocations);\n    const possibleAllocationsTotal = possibleAllocationsTotalMinusExtras.concat([null],\n    //HACK: add sentinel value before the extras\n    possibleExtraAllocationsTotal);\n    //whew!\n    let decodings = [];\n    allocationAttempts: for (const allocation of possibleAllocationsTotal) {\n      debug(\"trying allocation: %O\", allocation);\n      //first: check for our sentinel value for extras (yeah, kind of HACKy)\n      if (allocation === null) {\n        switch (extras) {\n          case \"on\":\n            continue allocationAttempts;\n          //ignore the sentinel and continue\n          case \"off\":\n            break allocationAttempts;\n          //don't include extras; stop here\n          case \"necessary\":\n            //stop on the sentinel and exclude extras *unless* there are no decodings yet\n            if (decodings.length > 0) {\n              break allocationAttempts;\n            } else {\n              continue allocationAttempts;\n            }\n        }\n      }\n      //second: do a name check so we can skip decoding if name is wrong\n      //(this will likely be a more detailed check in the future)\n      if (options.name !== undefined && allocation.abi.name !== options.name) {\n        continue;\n      }\n      //now: the main part!\n      let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n      const contextHash = allocation.contextHash;\n      const attemptContext = info.contexts[contextHash];\n      const emittingContractType = Contexts.Import.contextToType(attemptContext);\n      const contractType = allocation.definedIn;\n      //you can't map with a generator, so we have to do this map manually\n      let decodedArguments = [];\n      for (const argumentAllocation of allocation.arguments) {\n        let value;\n        //if in full mode, use the allocation's listed data type.\n        //if in ABI mode, abify it before use.\n        let dataType = decodingMode === \"full\" ? argumentAllocation.type : (0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes);\n        try {\n          value = yield* (0, decode_1.default)(dataType, argumentAllocation.pointer, info, {\n            strictAbiMode: true,\n            allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n          });\n        } catch (error) {\n          if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n            //if a retry happens, we've got to do several things in order to switch to ABI mode:\n            //1. mark that we're switching to ABI mode;\n            decodingMode = \"abi\";\n            //2. abify all previously decoded values;\n            decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n              value: (0, abify_1.abifyResult)(argumentDecoding.value, info.userDefinedTypes)\n            }));\n            //3. retry this particular decode in ABI mode.\n            try {\n              value = yield* (0, decode_1.default)((0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes),\n              //type is now abified!\n              argumentAllocation.pointer, info, {\n                strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n                //retries no longer allowed, not that this has an effect\n              });\n            } catch (_) {\n              //if an error occurred on the retry, this isn't a valid decoding!\n              debug(\"rejected due to exception on retry\");\n              continue allocationAttempts;\n            }\n            //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n            //so we don't need to do anything special there.\n          } else {\n            //if any other sort of error occurred, this isn't a valid decoding!\n            debug(\"rejected due to exception on first try: %O\", error);\n            continue allocationAttempts;\n          }\n        }\n        const name = argumentAllocation.name;\n        const indexed = argumentAllocation.pointer.location === \"eventtopic\";\n        decodedArguments.push(name //deliberate general falsiness test\n        ? {\n          name,\n          indexed,\n          value\n        } : {\n          indexed,\n          value\n        });\n      }\n      if (!options.disableChecks) {\n        //OK, so, having decoded the result, the question is: does it reencode to the original?\n        //NOTE: we skip this check if disableChecks is passed! (it shouldn't be passed :P )\n        //first, we have to filter out the indexed arguments, and also get rid of the name information\n        const nonIndexedValues = decodedArguments.filter(argument => !argument.indexed).map(argument => argument.value);\n        //now, we can encode!\n        const reEncodedData = AbiData.Encode.encodeTupleAbi(nonIndexedValues, info.allocations.abi);\n        const encodedData = info.state.eventdata; //again, not great to read this directly, but oh well\n        //are they equal?\n        if (!Evm.Utils.equalData(reEncodedData, encodedData)) {\n          //if not, this allocation doesn't work\n          debug(\"rejected due to [non-indexed] mismatch\");\n          continue;\n        }\n      }\n      //one last check -- let's check that the indexed arguments match up, too\n      //(we won't skip this even if disableChecks was passed)\n      const indexedValues = decodedArguments.filter(argument => argument.indexed).map(argument => argument.value);\n      const reEncodedTopics = indexedValues.map(Topic.Encode.encodeTopic);\n      const encodedTopics = info.state.eventtopics;\n      //now: do *these* match?\n      const selectorAdjustment = allocation.anonymous ? 0 : 1;\n      for (let i = 0; i < reEncodedTopics.length; i++) {\n        if (!Evm.Utils.equalData(reEncodedTopics[i], encodedTopics[i + selectorAdjustment])) {\n          debug(\"rejected due to indexed mismatch\");\n          continue allocationAttempts;\n        }\n      }\n      //if we've made it here, the allocation works!  hooray!\n      debug(\"allocation accepted!\");\n      let decoding;\n      if (allocation.abi.anonymous) {\n        decoding = {\n          kind: \"anonymous\",\n          definedIn: contractType,\n          class: emittingContractType,\n          abi: allocation.abi,\n          arguments: decodedArguments,\n          decodingMode,\n          interpretations: {}\n        };\n      } else {\n        decoding = {\n          kind: \"event\",\n          definedIn: contractType,\n          class: emittingContractType,\n          abi: allocation.abi,\n          arguments: decodedArguments,\n          selector,\n          decodingMode,\n          interpretations: {}\n        };\n      }\n      decodings.push(decoding);\n      //if we've made this far (so this allocation works), and we were passed an\n      //ID, and it matches this ID, bail out & return this as the *only* decoding\n      if (options.id && allocation.id === options.id) {\n        return [decoding];\n      }\n    }\n    return decodings;\n  }();\n}\nexports.decodeEvent = decodeEvent;\nconst errorSelector = Conversion.toBytes(web3_utils_1.default.soliditySha3({\n  type: \"string\",\n  value: \"Error(string)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nconst panicSelector = Conversion.toBytes(web3_utils_1.default.soliditySha3({\n  type: \"string\",\n  value: \"Panic(uint256)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nconst defaultRevertAllocations = [{\n  kind: \"revert\",\n  allocationMode: \"full\",\n  selector: errorSelector,\n  abi: {\n    name: \"Error\",\n    type: \"error\",\n    inputs: [{\n      name: \"\",\n      type: \"string\",\n      internalType: \"string\"\n    }]\n  },\n  definedIn: null,\n  arguments: [{\n    name: \"\",\n    pointer: {\n      location: \"returndata\",\n      start: errorSelector.length,\n      length: Evm.Utils.WORD_SIZE\n    },\n    type: {\n      typeClass: \"string\",\n      typeHint: \"string\"\n    }\n  }]\n}, {\n  kind: \"revert\",\n  allocationMode: \"full\",\n  selector: panicSelector,\n  abi: {\n    name: \"Panic\",\n    type: \"error\",\n    inputs: [{\n      name: \"\",\n      type: \"uint256\",\n      internalType: \"uint256\"\n    }]\n  },\n  definedIn: null,\n  arguments: [{\n    name: \"\",\n    pointer: {\n      location: \"returndata\",\n      start: panicSelector.length,\n      length: Evm.Utils.WORD_SIZE\n    },\n    type: {\n      typeClass: \"uint\",\n      bits: Evm.Utils.WORD_SIZE * 8,\n      typeHint: \"uint256\"\n    }\n  }]\n}];\nconst defaultEmptyAllocations = [{\n  kind: \"failure\",\n  allocationMode: \"full\",\n  selector: new Uint8Array(),\n  arguments: []\n}, {\n  kind: \"selfdestruct\",\n  allocationMode: \"full\",\n  selector: new Uint8Array(),\n  arguments: []\n}];\n/**\n * If there are multiple possibilities, they're always returned in\n * the order: return, revert, returnmessage, failure, empty, bytecode, unknownbytecode\n * Moreover, within \"revert\", builtin ones are put above custom ones\n * @Category Decoding\n */\nfunction* decodeReturndata(info, successAllocation,\n//null here must be explicit\nstatus,\n//you can pass this to indicate that you know the status,\nid //useful when status = false\n) {\n  let possibleAllocations;\n  const selector = Conversion.toHexString(info.state.returndata.slice(0, 4));\n  const contextHash = (info.currentContext || {\n    context: \"\"\n  }).context; //HACK: \"\" is used to represent no context\n  const customRevertAllocations = ((info.allocations.returndata || {\n    [contextHash]: {}\n  })[contextHash] || {\n    [selector]: []\n  })[selector] || [];\n  if (successAllocation === null) {\n    possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations];\n  } else {\n    switch (successAllocation.kind) {\n      case \"return\":\n        possibleAllocations = [successAllocation, ...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations];\n        break;\n      case \"bytecode\":\n        possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations, successAllocation];\n        break;\n      case \"returnmessage\":\n        possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, successAllocation, ...defaultEmptyAllocations];\n        break;\n      //Other cases shouldn't happen so I'm leaving them to cause errors!\n    }\n  }\n\n  let decodings = [];\n  allocationAttempts: for (const allocation of possibleAllocations) {\n    debug(\"trying allocation: %O\", allocation);\n    //before we attempt to use this allocation, we check: does the selector match?\n    let encodedData = info.state.returndata; //again, not great to read this directly, but oh well\n    const encodedPrefix = encodedData.subarray(0, allocation.selector.length);\n    if (!Evm.Utils.equalData(encodedPrefix, allocation.selector)) {\n      continue;\n    }\n    encodedData = encodedData.subarray(allocation.selector.length); //slice off the selector for later\n    //also we check, does the status match?\n    if (status !== undefined) {\n      const successKinds = [\"return\", \"selfdestruct\", \"bytecode\", \"returnmessage\"];\n      const failKinds = [\"failure\", \"revert\"];\n      if (status) {\n        if (!successKinds.includes(allocation.kind)) {\n          continue;\n        }\n      } else {\n        if (!failKinds.includes(allocation.kind)) {\n          continue;\n        }\n      }\n    }\n    if (allocation.kind === \"bytecode\") {\n      //bytecode is special and can't really be integrated with the other cases.\n      //so it gets its own function.\n      const decoding = yield* decodeBytecode(info);\n      if (decoding) {\n        decodings.push(decoding);\n      }\n      continue;\n    }\n    if (allocation.kind === \"returnmessage\") {\n      //this kind is also special, though thankfully it's easier\n      const decoding = {\n        kind: \"returnmessage\",\n        status: true,\n        data: Conversion.toHexString(info.state.returndata),\n        decodingMode: allocation.allocationMode,\n        interpretations: {}\n      };\n      decodings.push(decoding);\n      continue;\n    }\n    let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n    //you can't map with a generator, so we have to do this map manually\n    let decodedArguments = [];\n    for (const argumentAllocation of allocation.arguments) {\n      let value;\n      //if in full mode, use the allocation's listed data type.\n      //if in ABI mode, abify it before use.\n      let dataType = decodingMode === \"full\" ? argumentAllocation.type : (0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes);\n      //now, let's decode!\n      try {\n        value = yield* (0, decode_1.default)(dataType, argumentAllocation.pointer, info, {\n          abiPointerBase: allocation.selector.length,\n          strictAbiMode: true,\n          allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n        });\n\n        debug(\"value on first try: %O\", value);\n      } catch (error) {\n        if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n          debug(\"retry!\");\n          //if a retry happens, we've got to do several things in order to switch to ABI mode:\n          //1. mark that we're switching to ABI mode;\n          decodingMode = \"abi\";\n          //2. abify all previously decoded values;\n          decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n            value: (0, abify_1.abifyResult)(argumentDecoding.value, info.userDefinedTypes)\n          }));\n          //3. retry this particular decode in ABI mode.\n          try {\n            value = yield* (0, decode_1.default)((0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes),\n            //type is now abified!\n            argumentAllocation.pointer, info, {\n              abiPointerBase: allocation.selector.length,\n              strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n              //retries no longer allowed, not that this has an effect\n            });\n\n            debug(\"value on retry: %O\", value);\n          } catch (_) {\n            //if an error occurred on the retry, this isn't a valid decoding!\n            debug(\"rejected due to exception on retry\");\n            continue allocationAttempts;\n          }\n          //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n          //so we don't need to do anything special there.\n        } else {\n          //if any other sort of error occurred, this isn't a valid decoding!\n          debug(\"rejected due to exception on first try: %O\", error);\n          continue allocationAttempts;\n        }\n      }\n      const name = argumentAllocation.name;\n      decodedArguments.push(name //deliberate general falsiness test\n      ? {\n        name,\n        value\n      } : {\n        value\n      });\n    }\n    //OK, so, having decoded the result, the question is: does it reencode to the original?\n    //first, we have to filter out the indexed arguments, and also get rid of the name information\n    debug(\"decodedArguments: %O\", decodedArguments);\n    const decodedArgumentValues = decodedArguments.map(argument => argument.value);\n    const reEncodedData = AbiData.Encode.encodeTupleAbi(decodedArgumentValues, info.allocations.abi);\n    //are they equal? note the selector has been stripped off encodedData!\n    if (!Evm.Utils.equalData(reEncodedData, encodedData)) {\n      //if not, this allocation doesn't work\n      debug(\"rejected due to mismatch\");\n      continue;\n    }\n    //if we've made it here, the allocation works!  hooray!\n    debug(\"allocation accepted!\");\n    let decoding;\n    switch (allocation.kind) {\n      case \"return\":\n        decoding = {\n          kind: \"return\",\n          status: true,\n          arguments: decodedArguments,\n          decodingMode,\n          interpretations: {}\n        };\n        break;\n      case \"revert\":\n        decoding = {\n          kind: \"revert\",\n          abi: allocation.abi,\n          definedIn: allocation.definedIn,\n          status: false,\n          arguments: decodedArguments,\n          decodingMode,\n          interpretations: {}\n        };\n        break;\n      case \"selfdestruct\":\n        decoding = {\n          kind: \"selfdestruct\",\n          status: true,\n          decodingMode,\n          interpretations: {}\n        };\n        break;\n      case \"failure\":\n        decoding = {\n          kind: \"failure\",\n          status: false,\n          decodingMode,\n          interpretations: {}\n        };\n        break;\n    }\n    decodings.push(decoding);\n    //if we've made this far (so this allocation works), and we were passed an\n    //ID, and it matches this ID, bail out & return this as the *only* decoding\n    if (id && allocation.kind === \"revert\" && allocation.id === id) {\n      return [decoding];\n    }\n  }\n  return decodings;\n}\nexports.decodeReturndata = decodeReturndata;\n//note: requires the bytecode to be in returndata, not code\nfunction* decodeBytecode(info) {\n  let decodingMode = \"full\"; //as always, degrade as necessary\n  const bytecode = Conversion.toHexString(info.state.returndata);\n  const context = Contexts.Utils.findContext(info.contexts, bytecode);\n  if (!context) {\n    return {\n      kind: \"unknownbytecode\",\n      status: true,\n      decodingMode: \"full\",\n      bytecode,\n      interpretations: {}\n    };\n  }\n  const contractType = Contexts.Import.contextToType(context);\n  //now: ignore original allocation (which we didn't even pass :) )\n  //and lookup allocation by context\n  const allocation = info.allocations.calldata.constructorAllocations[context.context].output;\n  debug(\"bytecode allocation: %O\", allocation);\n  //now: add immutables if applicable\n  let immutables;\n  if (allocation.immutables) {\n    immutables = [];\n    //NOTE: if we're in here, we can assume decodingMode === \"full\"\n    for (const variable of allocation.immutables) {\n      const dataType = variable.type; //we don't conditioning on decodingMode here because we know it\n      let value;\n      try {\n        value = yield* (0, decode_1.default)(dataType, variable.pointer, info, {\n          allowRetry: true,\n          strictAbiMode: true,\n          paddingMode: \"defaultOrZero\"\n        });\n      } catch (error) {\n        if (error instanceof errors_1.StopDecodingError && error.allowRetry) {\n          //we \"retry\" by... not bothering with immutables :P\n          //(but we do set the mode to ABI)\n          decodingMode = \"abi\";\n          immutables = undefined;\n          break;\n        } else {\n          //otherwise, this isn't a valid decoding I guess\n          return null;\n        }\n      }\n      immutables.push({\n        name: variable.name,\n        class: variable.definedIn,\n        value\n      });\n    }\n  }\n  let decoding = {\n    kind: \"bytecode\",\n    status: true,\n    decodingMode,\n    bytecode,\n    immutables,\n    class: contractType,\n    interpretations: {}\n  };\n  //finally: add address if applicable\n  if (allocation.delegatecallGuard) {\n    decoding.address = web3_utils_1.default.toChecksumAddress(bytecode.slice(4, 4 + 2 * Evm.Utils.ADDRESS_SIZE) //4 = \"0x73\".length\n    );\n  }\n\n  return decoding;\n}\n/**\n * Decodes the return data from a failed call.\n *\n * @param returndata The returned data, as a Uint8Array.\n * @return An array of possible decodings.  At the moment it's\n *   impossible for there to be more than one.  (If the call didn't actually\n *   fail, or failed in a nonstandard way, you may get no decodings at all, though!)\n *\n *   Decodings can either be decodings of revert messages, or decodings\n *   indicating that there was no revert message.  If somehow both were to be\n *   possible, they'd go in that order, although as mentioned, there (at least\n *   currently) isn't any way for that to occur.\n * @Category Decoding convenience\n */\nfunction decodeRevert(returndata) {\n  //coercing because TS doesn't know it'll finish in one go\n  return decodeReturndata({\n    allocations: {},\n    state: {\n      storage: {},\n      returndata\n    }\n  }, null, false).next().value;\n}\nexports.decodeRevert = decodeRevert;","map":{"version":3,"mappings":"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","names":["debug","decodeVariable","definition","pointer","info","compilationId","compiler","currentContext","dataType","Ast","Import","definitionToType","exports","decodeCalldata","isConstructor","context","kind","decodingMode","bytecode","Conversion","toHexString","state","calldata","interpretations","data","contextHash","contractType","Contexts","contextToType","allocations","allocation","selector","constructorAllocations","input","undefined","rawSelector","location","start","length","Evm","Utils","SELECTOR_SIZE","functionAllocations","abiEntry","fallbackAbi","receive","fallback","class","abi","allocationMode","decodedArguments","argumentAllocation","arguments","value","type","userDefinedTypes","abiPointerBase","offset","allowRetry","error","errors_1","map","argumentDecoding","Object","name","push","slice","decodeEvent","address","options","event","extras","contractAllocations","libraryAllocations","contractAnonymousAllocations","libraryAnonymousAllocations","topicsCount","eventtopics","topic","bySelector","contract","library","anonymous","contractContext","codeBytes","codeAsHex","findContext","contexts","possibleContractAllocations","possibleContractAnonymousAllocations","possibleExtraAllocations","possibleExtraAnonymousAllocations","emittingContextHash","contractAllocation","contractAnonymousAllocation","concat","entries","filter","key","_","values","possibleLibraryAllocations","possibleLibraryAnonymousAllocations","possibleAllocations","possibleAnonymousAllocations","possibleAllocationsTotalMinusExtras","possibleExtraAllocationsTotal","possibleAllocationsTotal","decodings","allocationAttempts","attemptContext","emittingContractType","definedIn","strictAbiMode","indexed","disableChecks","nonIndexedValues","argument","reEncodedData","AbiData","Encode","encodeTupleAbi","encodedData","eventdata","equalData","indexedValues","reEncodedTopics","Topic","encodeTopic","encodedTopics","selectorAdjustment","i","decoding","id","errorSelector","toBytes","web3_utils_1","soliditySha3","subarray","panicSelector","defaultRevertAllocations","inputs","internalType","WORD_SIZE","typeClass","typeHint","bits","defaultEmptyAllocations","Uint8Array","decodeReturndata","successAllocation","status","returndata","customRevertAllocations","encodedPrefix","successKinds","failKinds","includes","decodeBytecode","decodedArgumentValues","output","immutables","variable","paddingMode","delegatecallGuard","toChecksumAddress","ADDRESS_SIZE","decodeRevert","storage","next"],"sourceRoot":"","sources":["../../lib/core.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}