{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeString = exports.decodeBytes = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:bytes:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst errors_1 = require(\"../../errors\");\nconst utf8_1 = __importDefault(require(\"utf8\"));\nfunction decodeBytes(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    const {\n      state\n    } = info;\n    const {\n      strictAbiMode: strict\n    } = options; //if this is undefined it'll still be falsy so OK\n    let bytes;\n    try {\n      bytes = yield* (0, read_1.default)(pointer, state);\n    } catch (error) {\n      debug(\"segfault, pointer %o, state: %O\", pointer, state);\n      return (0, errors_1.handleDecodingError)(dataType, error, strict);\n    }\n    debug(\"type %O\", dataType);\n    debug(\"pointer %o\", pointer);\n    //note: this function does not check padding\n    switch (dataType.typeClass) {\n      case \"bytes\":\n        //we assume this is a dynamic bytestring!\n        //static ones should go to decodeBasic!\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: {\n            asHex: Conversion.toHexString(bytes)\n          }\n        };\n      case \"string\":\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodeString(bytes)\n        };\n    }\n  }();\n}\nexports.decodeBytes = decodeBytes;\nfunction decodeString(bytes) {\n  //the following line takes our UTF-8 string... and interprets each byte\n  //as a UTF-16 bytepair.  Yikes!  Fortunately, we have a library to repair that.\n  let badlyEncodedString = String.fromCharCode.apply(undefined, bytes);\n  try {\n    //this will throw an error if we have malformed UTF-8\n    let correctlyEncodedString = utf8_1.default.decode(badlyEncodedString);\n    //NOTE: we don't use node's builtin Buffer class to do the UTF-8 decoding\n    //here, because that handles malformed UTF-8 by means of replacement characters\n    //(U+FFFD).  That loses information.  So we use the utf8 package instead,\n    //and... well, see the catch block below.\n    return {\n      kind: \"valid\",\n      asString: correctlyEncodedString\n    };\n  } catch (_a) {\n    //we're going to ignore the precise error and just assume it's because\n    //the string was malformed (what else could it be?)\n    let hexString = Conversion.toHexString(bytes);\n    return {\n      kind: \"malformed\",\n      asHex: hexString\n    };\n  }\n}\nexports.decodeString = decodeString;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA,MAAMA,KAAK,GAAG,mBAAW,EAAC,oBAAoB,CAAC;AAE/C;AACA;AAKA;AACA;AAEA,SAAiBC,WAAW,CAC1BC,QAAiE,EACjEC,OAA4B,EAC5BC,IAAiB;EAAA,IACjBC,8EAA0B,EAAE;EAAA;IAE5B,MAAM;MAAEC;IAAK,CAAE,GAAGF,IAAI;IACtB,MAAM;MAAEG,aAAa,EAAEC;IAAM,CAAE,GAAGH,OAAO,CAAC,CAAC;IAE3C,IAAII,KAAiB;IACrB,IAAI;MACFA,KAAK,GAAG,OAAO,kBAAI,EAACN,OAAO,EAAEG,KAAK,CAAC;KACpC,CAAC,OAAOI,KAAK,EAAE;MACdV,KAAK,CAAC,iCAAiC,EAAEG,OAAO,EAAEG,KAAK,CAAC;MACxD,OAAO,gCAAmB,EAACJ,QAAQ,EAAEQ,KAAK,EAAEF,MAAM,CAAC;;IAGrDR,KAAK,CAAC,SAAS,EAAEE,QAAQ,CAAC;IAC1BF,KAAK,CAAC,YAAY,EAAEG,OAAO,CAAC;IAE5B;IAEA,QAAQD,QAAQ,CAACS,SAAS;MACxB,KAAK,OAAO;QACV;QACA;QACA,OAAO;UACLC,IAAI,EAAEV,QAAQ;UACdW,IAAI,EAAE,OAAgB;UACtBC,KAAK,EAAE;YACLC,KAAK,EAAEC,UAAU,CAACC,WAAW,CAACR,KAAK;;SAEtC;MAEH,KAAK,QAAQ;QACX,OAAO;UACLG,IAAI,EAAEV,QAAQ;UACdW,IAAI,EAAE,OAAgB;UACtBC,KAAK,EAAEI,YAAY,CAACT,KAAK;SAC1B;IAAC;EAER,CAAC;AAAA;AAzCDU;AA2CA,SAAgBD,YAAY,CAACT,KAAiB;EAC5C;EACA;EACA,IAAIW,kBAAkB,GAAGC,MAAM,CAACC,YAAY,CAACC,KAAK,CAACC,SAAS,EAAEf,KAAK,CAAC;EACpE,IAAI;IACF;IACA,IAAIgB,sBAAsB,GAAGC,cAAI,CAACC,MAAM,CAACP,kBAAkB,CAAC;IAC5D;IACA;IACA;IACA;IACA,OAAO;MACLP,IAAI,EAAE,OAAgB;MACtBe,QAAQ,EAAEH;KACX;GACF,CAAC,WAAM;IACN;IACA;IACA,IAAII,SAAS,GAAGb,UAAU,CAACC,WAAW,CAACR,KAAK,CAAC;IAC7C,OAAO;MACLI,IAAI,EAAE,WAAoB;MAC1BE,KAAK,EAAEc;KACR;;AAEL;AAxBAV","names":["debug","decodeBytes","dataType","pointer","info","options","state","strictAbiMode","strict","bytes","error","typeClass","type","kind","value","asHex","Conversion","toHexString","decodeString","exports","badlyEncodedString","String","fromCharCode","apply","undefined","correctlyEncodedString","utf8_1","decode","asString","hexString"],"sourceRoot":"","sources":["../../../../lib/bytes/decode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}