{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RepeatCompilationIdError = exports.NoProjectInfoError = exports.handleDecodingError = exports.StopDecodingError = exports.DecodingError = void 0;\nconst Format = __importStar(require(\"./format\"));\n//For when we need to throw an error, here's a wrapper class that extends Error.\n//Apologies about the confusing name, but I wanted something that would make\n//sense should it not be caught and thus accidentally exposed to the outside.\n/**\n * @hidden\n */\nclass DecodingError extends Error {\n  constructor(error) {\n    super(Format.Utils.Exception.message(error));\n    this.error = error;\n    this.name = \"DecodingError\";\n  }\n}\nexports.DecodingError = DecodingError;\n//used to stop decoding; like DecodingError, but used in contexts\n//where I don't expect it to be caught\n//NOTE: currently we don't actually check the type of a thrown error,\n//we just rely on context.  still, I think it makes sense to be a separate\n//type.\n/**\n * @hidden\n */\nclass StopDecodingError extends Error {\n  //when decoding in full mode, we allow an ABI-mode retry.  (if we were already in\n  //ABI mode, we give up.)\n  constructor(error, allowRetry) {\n    const message = `Stopping decoding: ${error.kind}`; //sorry about the bare-bones message,\n    //but again, users shouldn't actually see this, so I think this should suffice for now\n    super(message);\n    this.error = error;\n    this.allowRetry = Boolean(allowRetry);\n  }\n}\nexports.StopDecodingError = StopDecodingError;\n/**\n * @hidden\n */\nfunction handleDecodingError(dataType, error) {\n  let strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (error instanceof DecodingError) {\n    //expected error\n    if (strict) {\n      //strict mode -- stop decoding on errors\n      throw new StopDecodingError(error.error);\n    } else {\n      //nonstrict mode -- return an error result\n      return {\n        //I don't know why TS's inference is failing here and needs the coercion\n        type: dataType,\n        kind: \"error\",\n        error: error.error\n      };\n    }\n  } else {\n    //if it's *not* an expected error, we better not swallow it -- rethrow!\n    throw error;\n  }\n}\nexports.handleDecodingError = handleDecodingError;\n/**\n * This error indicates that the user attempted to instantiate a decoder\n * with no project information (by explicitly overriding the default).\n * @category Exception\n */\nclass NoProjectInfoError extends Error {\n  constructor() {\n    super(\"No project information specified.\");\n    this.name = \"NoProjectInfoError\";\n  }\n}\nexports.NoProjectInfoError = NoProjectInfoError;\n/**\n * This error indicates there was an attempt to add multiple compilations\n * with the same ID, or a compilation whose ID was already in use.\n */\nclass RepeatCompilationIdError extends Error {\n  constructor(ids) {\n    super(`Compilation id(s) ${ids.join(\", \")} repeated or already in use.`);\n    this.ids = ids;\n    this.name = \"RepeatCompilationIdError\";\n  }\n}\nexports.RepeatCompilationIdError = RepeatCompilationIdError;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AACA;AACA;;;AAGA,MAAaA,aAAc,SAAQC,KAAK;EAEtCC,YAAYC,KAAqC;IAC/C,KAAK,CAACC,MAAM,CAACC,KAAK,CAACC,SAAS,CAACC,OAAO,CAACJ,KAAK,CAAC,CAAC;IAC5C,IAAI,CAACA,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACK,IAAI,GAAG,eAAe;EAC7B;;AANFC;AASA;AACA;AACA;AACA;AACA;AACA;;;AAGA,MAAaC,iBAAkB,SAAQT,KAAK;EAG1C;EACA;EACAC,YAAYC,KAAiC,EAAEQ,UAAoB;IACjE,MAAMJ,OAAO,GAAG,sBAAsBJ,KAAK,CAACS,IAAI,EAAE,CAAC,CAAC;IACpD;IACA,KAAK,CAACL,OAAO,CAAC;IACd,IAAI,CAACJ,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACQ,UAAU,GAAGE,OAAO,CAACF,UAAU,CAAC;EACvC;;AAXFF;AAcA;;;AAGA,SAAgBK,mBAAmB,CACjCC,QAA2B,EAC3BZ,KAAU,EACa;EAAA,IAAvBa,6EAAkB,KAAK;EAEvB,IAAIb,KAAK,YAAYH,aAAa,EAAE;IAClC;IACA,IAAIgB,MAAM,EAAE;MACV;MACA,MAAM,IAAIN,iBAAiB,CAACP,KAAK,CAACA,KAAK,CAAC;KACzC,MAAM;MACL;MACA,OAAkC;QAChC;QACAc,IAAI,EAAEF,QAAQ;QACdH,IAAI,EAAE,OAAgB;QACtBT,KAAK,EAAEA,KAAK,CAACA;OACd;;GAEJ,MAAM;IACL;IACA,MAAMA,KAAK;;AAEf;AAvBAM;AAyBA;;;;;AAKA,MAAaS,kBAAmB,SAAQjB,KAAK;EAC3CC;IACE,KAAK,CAAC,mCAAmC,CAAC;IAC1C,IAAI,CAACM,IAAI,GAAG,oBAAoB;EAClC;;AAJFC;AAOA;;;;AAIA,MAAaU,wBAAyB,SAAQlB,KAAK;EAEjDC,YAAYkB,GAAa;IACvB,KAAK,CAAC,qBAAqBA,GAAG,CAACC,IAAI,CAAC,IAAI,CAAC,8BAA8B,CAAC;IACxE,IAAI,CAACD,GAAG,GAAGA,GAAG;IACd,IAAI,CAACZ,IAAI,GAAG,0BAA0B;EACxC;;AANFC","names":["DecodingError","Error","constructor","error","Format","Utils","Exception","message","name","exports","StopDecodingError","allowRetry","kind","Boolean","handleDecodingError","dataType","strict","type","NoProjectInfoError","RepeatCompilationIdError","ids","join"],"sourceRoot":"","sources":["../../lib/errors.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}