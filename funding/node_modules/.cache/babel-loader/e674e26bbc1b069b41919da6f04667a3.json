{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeTupleAbiWithSelector = exports.encodeTupleAbi = exports.encodeAbi = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:abi-data:encode\");\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst sum_1 = __importDefault(require(\"lodash/sum\"));\n//UGH -- it turns out TypeScript can't handle nested tagged unions\n//see: https://github.com/microsoft/TypeScript/issues/18758\n//so, I'm just going to have to throw in a bunch of type coercions >_>\n/**\n * @Category Encoding (low-level)\n */\nfunction encodeAbi(input, allocations) {\n  //errors can't be encoded\n  if (input.kind === \"error\") {\n    return undefined;\n  }\n  let bytes;\n  //TypeScript can at least infer in the rest of this that we're looking\n  //at a value, not an error!  But that's hardly enough...\n  switch (input.type.typeClass) {\n    case \"mapping\":\n    case \"magic\":\n    case \"type\":\n      //none of these can go in the ABI\n      return undefined;\n    case \"bytes\":\n      switch (input.type.kind) {\n        case \"static\":\n          return Basic.Encode.encodeBasic(input);\n        case \"dynamic\":\n          bytes = Bytes.Encode.encodeBytes(input);\n          return padAndPrependLength(bytes);\n      }\n    case \"string\":\n      bytes = Bytes.Encode.encodeBytes(input);\n      return padAndPrependLength(bytes);\n    case \"function\":\n      {\n        switch (input.type.visibility) {\n          case \"internal\":\n            return undefined;\n          //internal functions can't go in the ABI!\n          //Yes, technically we could defer to encodeBasic here, but,\n          //c'mon, that's not how the function's supposed to be used\n          case \"external\":\n            return Basic.Encode.encodeBasic(input);\n        }\n      }\n    //now for the serious cases\n    case \"array\":\n      {\n        let coercedInput = input;\n        if (coercedInput.reference !== undefined) {\n          return undefined; //circular values can't be encoded\n        }\n\n        let staticEncoding = encodeTupleAbi(coercedInput.value, allocations);\n        switch (input.type.kind) {\n          case \"static\":\n            return staticEncoding;\n          case \"dynamic\":\n            let encoded = new Uint8Array(Evm.Utils.WORD_SIZE + staticEncoding.length); //leave room for length\n            encoded.set(staticEncoding, Evm.Utils.WORD_SIZE); //again, leave room for length beforehand\n            let lengthBytes = Conversion.toBytes(coercedInput.value.length, Evm.Utils.WORD_SIZE);\n            encoded.set(lengthBytes); //and now we set the length\n            return encoded;\n        }\n      }\n    case \"struct\":\n      {\n        let coercedInput = input;\n        if (coercedInput.reference !== undefined) {\n          return undefined; //circular values can't be encoded\n        }\n\n        return encodeTupleAbi(coercedInput.value.map(_ref => {\n          let {\n            value\n          } = _ref;\n          return value;\n        }), allocations);\n      }\n    case \"tuple\":\n      //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n      //(That may not be apparent from this one line, but it's true)\n      //I'm writing it this way anyway for simplicity, to avoid rewriting the encoder\n      //However it may be worth revisiting this in the future if performance turns out to be a problem\n      return encodeTupleAbi(input.value.map(_ref2 => {\n        let {\n          value\n        } = _ref2;\n        return value;\n      }), allocations);\n    default:\n      return Basic.Encode.encodeBasic(input);\n  }\n}\nexports.encodeAbi = encodeAbi;\n/**\n * @Category Encoding (low-level)\n */\nfunction padAndPrependLength(bytes) {\n  let length = bytes.length;\n  let paddedLength = Evm.Utils.WORD_SIZE * Math.ceil(length / Evm.Utils.WORD_SIZE);\n  let encoded = new Uint8Array(Evm.Utils.WORD_SIZE + paddedLength);\n  encoded.set(bytes, Evm.Utils.WORD_SIZE); //start 32 in to leave room for the length beforehand\n  let lengthBytes = Conversion.toBytes(length, Evm.Utils.WORD_SIZE);\n  encoded.set(lengthBytes); //and now we set the length\n  return encoded;\n}\n/**\n * @Category Encoding (low-level)\n */\nfunction encodeTupleAbi(tuple, allocations) {\n  let elementEncodings = tuple.map(element => encodeAbi(element, allocations));\n  if (elementEncodings.some(element => element === undefined)) {\n    return undefined;\n  }\n  let elementSizeInfo = tuple.map(element => (0, allocate_1.abiSizeInfo)(element.type, allocations));\n  //heads and tails here are as discussed in the ABI docs;\n  //for a static type the head is the encoding and the tail is empty,\n  //for a dynamic type the head is the pointer and the tail is the encoding\n  let heads = [];\n  let tails = [];\n  //but first, we need to figure out where the first tail will start,\n  //by adding up the sizes of all the heads (we can easily do this in\n  //advance via elementSizeInfo, without needing to know the particular\n  //values of the heads)\n  let startOfNextTail = (0, sum_1.default)(elementSizeInfo.map(elementInfo => elementInfo.size));\n  for (let i = 0; i < tuple.length; i++) {\n    let head;\n    let tail;\n    if (!elementSizeInfo[i].dynamic) {\n      //static case\n      head = elementEncodings[i];\n      tail = new Uint8Array(); //empty array\n    } else {\n      //dynamic case\n      head = Conversion.toBytes(startOfNextTail, Evm.Utils.WORD_SIZE);\n      tail = elementEncodings[i];\n    }\n    heads.push(head);\n    tails.push(tail);\n    startOfNextTail += tail.length;\n  }\n  //finally, we need to concatenate everything together!\n  //since we're dealing with Uint8Arrays, we have to do this manually\n  let totalSize = startOfNextTail;\n  let encoded = new Uint8Array(totalSize);\n  let position = 0;\n  for (let head of heads) {\n    encoded.set(head, position);\n    position += head.length;\n  }\n  for (let tail of tails) {\n    encoded.set(tail, position);\n    position += tail.length;\n  }\n  return encoded;\n}\nexports.encodeTupleAbi = encodeTupleAbi;\n/**\n * @Category Encoding (low-level)\n */\nfunction encodeTupleAbiWithSelector(tuple, selector, allocations) {\n  const encodedTuple = encodeTupleAbi(tuple, allocations);\n  if (!encodedTuple) {\n    return undefined;\n  }\n  const encoded = new Uint8Array(selector.length + encodedTuple.length);\n  encoded.set(selector);\n  encoded.set(encodedTuple, selector.length);\n  return encoded;\n}\nexports.encodeTupleAbiWithSelector = encodeTupleAbiWithSelector;","map":{"version":3,"mappings":"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","names":["debug","encodeAbi","input","allocations","kind","undefined","bytes","type","typeClass","Basic","Encode","encodeBasic","Bytes","encodeBytes","padAndPrependLength","visibility","coercedInput","reference","staticEncoding","encodeTupleAbi","value","encoded","Uint8Array","Evm","Utils","WORD_SIZE","length","set","lengthBytes","Conversion","toBytes","map","exports","paddedLength","Math","ceil","tuple","elementEncodings","element","some","elementSizeInfo","heads","tails","startOfNextTail","elementInfo","size","i","head","tail","dynamic","push","totalSize","position","encodeTupleAbiWithSelector","selector","encodedTuple"],"sourceRoot":"","sources":["../../../../lib/abi-data/encode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}