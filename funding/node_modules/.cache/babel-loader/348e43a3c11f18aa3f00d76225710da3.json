{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEventAllocations = exports.getReturndataAllocations = exports.getCalldataAllocations = exports.abiSizeInfo = exports.getAbiAllocations = exports.FallbackOutputAllocation = exports.Utils = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:abi-data:allocate\");\nexports.Utils = __importStar(require(\"./utils\"));\nconst Import = __importStar(require(\"../import\"));\nconst AbiDataUtils = __importStar(require(\"../utils\"));\nconst web3_utils_1 = __importDefault(require(\"web3-utils\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst Common = __importStar(require(\"../../common\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Ast = __importStar(require(\"../../ast\"));\nconst import_1 = require(\"../../contexts/import\");\nconst Format = __importStar(require(\"../../format\"));\nconst partition_1 = __importDefault(require(\"lodash/partition\"));\nexports.FallbackOutputAllocation = {\n  kind: \"returnmessage\",\n  selector: new Uint8Array(),\n  allocationMode: \"full\"\n};\nfunction getAbiAllocations(userDefinedTypes) {\n  let allocations = {};\n  for (const dataType of Object.values(userDefinedTypes)) {\n    if (dataType.typeClass === \"struct\") {\n      try {\n        allocations = allocateStruct(dataType, userDefinedTypes, allocations);\n      } catch (_) {\n        //if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n        //note: a better way of handling this would probably be to *mark* it\n        //as failed rather than throwing an exception as that would lead to less\n        //recomputation, but this is simpler and I don't think the recomputation\n        //should really be a problem\n      }\n    }\n  }\n  return allocations;\n}\nexports.getAbiAllocations = getAbiAllocations;\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations) {\n  //NOTE: dataType here should be a *stored* type!\n  //it is up to the caller to take care of this\n  return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);\n}\n//note: we will still allocate circular structs, even though they're not allowed in the abi, because it's\n//not worth the effort to detect them.  However on mappings or internal functions, we'll vomit (allocate null)\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations) {\n  let start = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let dynamic = false;\n  //note that we will mutate the start argument also!\n  //don't allocate things that have already been allocated\n  if (parentId in existingAllocations) {\n    return existingAllocations;\n  }\n  let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n  let memberAllocations = [];\n  for (const member of members) {\n    let length;\n    let dynamicMember;\n    ({\n      size: length,\n      dynamic: dynamicMember,\n      allocations\n    } = abiSizeAndAllocate(member.type, userDefinedTypes, allocations));\n    //vomit on illegal types in calldata -- note the short-circuit!\n    if (length === undefined) {\n      allocations[parentId] = null;\n      return allocations;\n    }\n    let pointer = {\n      location: \"abi\",\n      start,\n      length\n    };\n    memberAllocations.push({\n      name: member.name,\n      type: member.type,\n      pointer\n    });\n    start += length;\n    dynamic = dynamic || dynamicMember;\n  }\n  allocations[parentId] = {\n    members: memberAllocations,\n    length: dynamic ? Evm.Utils.WORD_SIZE : start,\n    dynamic\n  };\n  return allocations;\n}\n//first return value is the actual size.\n//second return value is whether the type is dynamic\n//both will be undefined if type is a mapping or internal function\n//third return value is resulting allocations, INCLUDING the ones passed in\nfunction abiSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {\n  switch (dataType.typeClass) {\n    case \"bool\":\n    case \"address\":\n    case \"contract\":\n    case \"int\":\n    case \"uint\":\n    case \"fixed\":\n    case \"ufixed\":\n    case \"enum\":\n    case \"userDefinedValueType\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: false,\n        allocations: existingAllocations\n      };\n    case \"string\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: true,\n        allocations: existingAllocations\n      };\n    case \"bytes\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: dataType.kind === \"dynamic\",\n        allocations: existingAllocations\n      };\n    case \"mapping\":\n      return {\n        allocations: existingAllocations\n      };\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          return {\n            size: Evm.Utils.WORD_SIZE,\n            dynamic: false,\n            allocations: existingAllocations\n          };\n        case \"internal\":\n          return {\n            allocations: existingAllocations\n          };\n      }\n    case \"array\":\n      {\n        switch (dataType.kind) {\n          case \"dynamic\":\n            return {\n              size: Evm.Utils.WORD_SIZE,\n              dynamic: true,\n              allocations: existingAllocations\n            };\n          case \"static\":\n            if (dataType.length.isZero()) {\n              //arrays of length 0 are static regardless of base type\n              return {\n                size: 0,\n                dynamic: false,\n                allocations: existingAllocations\n              };\n            }\n            const {\n              size: baseSize,\n              dynamic,\n              allocations\n            } = abiSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);\n            return {\n              //WARNING!  The use of toNumber() here may throw an exception!\n              //I'm judging this OK since if you have arrays that large we have bigger problems :P\n              size: dataType.length.toNumber() * baseSize,\n              dynamic,\n              allocations\n            };\n        }\n      }\n    case \"struct\":\n      {\n        let allocations = existingAllocations;\n        let allocation = allocations[dataType.id];\n        if (allocation === undefined) {\n          //if we don't find an allocation, we'll have to do the allocation ourselves\n          const storedType = userDefinedTypes[dataType.id];\n          if (!storedType) {\n            throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n          }\n          allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n          allocation = allocations[storedType.id];\n        }\n        //having found our allocation, if it's not null, we can just look up its size and dynamicity\n        if (allocation !== null) {\n          return {\n            size: allocation.length,\n            dynamic: allocation.dynamic,\n            allocations\n          };\n        }\n        //if it is null, this type doesn't go in the abi\n        else {\n          return {\n            allocations\n          };\n        }\n      }\n    case \"tuple\":\n      {\n        //Warning! Yucky wasteful recomputation here!\n        let size = 0;\n        let dynamic = false;\n        //note that we don't just invoke allocateStruct here!\n        //why not? because it has no ID to store the result in!\n        //and we can't use a fake like -1 because there might be a recursive call to it,\n        //and then the results would overwrite each other\n        //I mean, we could do some hashing thing or something, but I think it's easier to just\n        //copy the logic in this one case (sorry)\n        for (let member of dataType.memberTypes) {\n          let {\n            size: memberSize,\n            dynamic: memberDynamic\n          } = abiSizeAndAllocate(member.type, userDefinedTypes, existingAllocations);\n          size += memberSize;\n          dynamic = dynamic || memberDynamic;\n        }\n        return {\n          size,\n          dynamic,\n          allocations: existingAllocations\n        };\n      }\n  }\n}\n//assumes you've already done allocation! don't use if you haven't!\n/**\n * @protected\n */\nfunction abiSizeInfo(dataType, allocations) {\n  let {\n    size,\n    dynamic\n  } = abiSizeAndAllocate(dataType, null, allocations);\n  //the above line should work fine... as long as allocation is already done!\n  //the middle argument, userDefinedTypes, is only needed during allocation\n  //again, this function is only for use if allocation is done, so it's safe to pass null here\n  return {\n    size,\n    dynamic\n  };\n}\nexports.abiSizeInfo = abiSizeInfo;\n//allocates an external call\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\n//NOTE: returns undefined if attempting to allocate a constructor but we don't have the\n//bytecode for the constructor\nfunction allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext) {\n  //first: determine the corresponding function node\n  //(simultaneously: determine the offset)\n  let node = undefined;\n  let inputParametersFull;\n  let outputParametersFull;\n  let inputParametersAbi;\n  let outputParametersAbi;\n  let offset; //refers to INPUT offset; output offset is always 0\n  debug(\"allocating calldata and returndata\");\n  switch (abiEntry.type) {\n    case \"constructor\":\n      if (!constructorContext) {\n        return undefined;\n      }\n      let rawLength = constructorContext.binary.length;\n      offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n      //for a constructor, we only want to search the particular contract\n      if (contractNode) {\n        node = contractNode.nodes.find(functionNode => AbiDataUtils.definitionMatchesAbi(\n        //note this needn't actually be a function node, but then it will\n        //return false (well, unless it's a getter node!)\n        abiEntry, functionNode, referenceDeclarations));\n      }\n      //if we can't find it, we'll handle this below\n      break;\n    case \"function\":\n      offset = Evm.Utils.SELECTOR_SIZE;\n      //search through base contracts, from most derived (left) to most base (right)\n      if (contractNode) {\n        const linearizedBaseContracts = contractNode.linearizedBaseContracts;\n        debug(\"linearized: %O\", linearizedBaseContracts);\n        node = findNodeAndContract(linearizedBaseContracts, referenceDeclarations, functionNode => AbiDataUtils.definitionMatchesAbi(abiEntry, functionNode, referenceDeclarations), contractNode).node; //may be undefined!  that's OK!\n        debug(\"found node: %o\", Boolean(node));\n      }\n      break;\n  }\n  //now: get the parameters (both full-mode & ABI)\n  if (node) {\n    switch (node.nodeType) {\n      case \"FunctionDefinition\":\n        //normal case\n        inputParametersFull = node.parameters.parameters;\n        outputParametersFull = node.returnParameters.parameters; //this exists even for constructors!\n        break;\n      case \"VariableDeclaration\":\n        //getter case\n        ({\n          inputs: inputParametersFull,\n          outputs: outputParametersFull\n        } = Ast.Utils.getterParameters(node, referenceDeclarations));\n        break;\n    }\n  } else {\n    inputParametersFull = undefined;\n    outputParametersFull = undefined;\n  }\n  inputParametersAbi = abiEntry.inputs;\n  switch (abiEntry.type) {\n    case \"function\":\n      outputParametersAbi = abiEntry.outputs;\n      break;\n    case \"constructor\":\n      //we just leave this empty for constructors\n      outputParametersAbi = [];\n      break;\n  }\n  //now: do the allocation!\n  let {\n    allocation: abiAllocationInput,\n    mode: inputMode\n  } = allocateDataArguments(inputParametersFull, inputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, offset);\n  let {\n    allocation: abiAllocationOutput,\n    mode: outputMode\n  } = allocateDataArguments(outputParametersFull, outputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler\n  //note no offset\n  );\n\n  debug(\"modes: %s in, %s out\", inputMode, outputMode);\n  //finally: transform the allocation appropriately\n  let inputArgumentsAllocation = abiAllocationInput.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"calldata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  let outputArgumentsAllocation = abiAllocationOutput.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"returndata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  let inputsAllocation = {\n    abi: abiEntry,\n    offset,\n    arguments: inputArgumentsAllocation,\n    allocationMode: inputMode\n  };\n  let outputsAllocation;\n  switch (abiEntry.type) {\n    case \"function\":\n      outputsAllocation = {\n        selector: new Uint8Array(),\n        arguments: outputArgumentsAllocation,\n        allocationMode: outputMode,\n        kind: \"return\"\n      };\n      break;\n    case \"constructor\":\n      outputsAllocation = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, outputMode);\n      break;\n  }\n  return {\n    input: inputsAllocation,\n    output: outputsAllocation\n  }; //TS chokes on this for some reason\n}\n//note: allocateEvent doesn't use this because it needs additional\n//handling for indexed parameters (maybe these can be unified in\n//the future though?)\nfunction allocateDataArguments(fullModeParameters, abiParameters, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let offset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  let allocationMode = fullModeParameters ? \"full\" : \"abi\"; //can degrade\n  let parameterTypes;\n  let abiAllocation;\n  if (allocationMode === \"full\") {\n    let id = \"-1\"; //fake ID that doesn't matter\n    parameterTypes = fullModeParameters.map(parameter => ({\n      name: parameter.name,\n      type: Ast.Import.definitionToType(parameter, compilationId, compiler) //if node is defined, compiler had also better be!\n    }));\n\n    debug(\"parameterTypes: %O\", parameterTypes);\n    //now: perform the allocation!\n    try {\n      abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n    } catch (_a) {\n      //if something goes wrong, switch to ABI mdoe\n      debug(\"falling back to ABI due to exception!\");\n      allocationMode = \"abi\";\n    }\n  }\n  if (allocationMode === \"abi\") {\n    //THIS IS DELIBERATELY NOT AN ELSE\n    //this is the ABI case.  we end up here EITHER\n    //if node doesn't exist, OR if something went wrong\n    //during allocation\n    let id = \"-1\"; //fake irrelevant ID\n    parameterTypes = abiParameters.map(parameter => ({\n      name: parameter.name,\n      type: Import.abiParameterToType(parameter)\n    }));\n    abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n  }\n  return {\n    allocation: abiAllocation,\n    mode: allocationMode\n  };\n}\n//allocates an event\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\nfunction allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let parameterTypes;\n  let nodeId;\n  let id;\n  //first: determine the corresponding event node\n  //search through base contracts, from most derived (right) to most base (left)\n  let node = undefined;\n  let definedIn = undefined;\n  let allocationMode = \"full\"; //degrade to abi as needed\n  debug(\"allocating ABI: %O\", abiEntry);\n  if (contractNode) {\n    //first: check same contract for the event\n    node = contractNode.nodes.find(eventNode => AbiDataUtils.definitionMatchesAbi(\n    //note this needn't actually be an event node, but then it will\n    //return false\n    abiEntry, eventNode, referenceDeclarations));\n    //if we found the node, great!  If not...\n    if (!node) {\n      debug(\"didn't find node in base contract...\");\n      //let's search for the node among the base contracts.\n      //but if we find it...\n      //[note: the following code is overcomplicated; it was used\n      //when we were trying to get the actual node, it's overcomplicated\n      //now that we're just determining its presence.  oh well]\n      let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n      linearizedBaseContractsMinusSelf.shift(); //remove self\n      debug(\"checking contracts: %o\", linearizedBaseContractsMinusSelf);\n      node = findNodeAndContract(linearizedBaseContractsMinusSelf, referenceDeclarations, eventNode => AbiDataUtils.definitionMatchesAbi(\n      //note this needn't actually be a event node, but then it will return false\n      abiEntry, eventNode, referenceDeclarations)\n      //don't pass deriveContractNode here, we're not checking the contract itself\n      ).node; //may be undefined! that's OK!\n      if (node) {\n        //...if we find the node in an ancestor, we\n        //deliberately *don't* allocate!  instead such cases\n        //will be handled during a later combination step\n        debug(\"bailing out for later handling!\");\n        debug(\"ABI: %O\", abiEntry);\n        return undefined;\n      }\n    }\n  }\n  //otherwise, leave node undefined\n  if (node) {\n    debug(\"found node\");\n    //if we found the node, let's also turn it into a type\n    definedIn = Ast.Import.definitionToStoredType(contractNode, compilationId, compiler); //can skip reference declarations argument here\n    //...and set the ID\n    id = (0, import_1.makeTypeId)(node.id, compilationId);\n  } else {\n    //if no node, have to fall back into ABI mode\n    debug(\"falling back to ABI because no node\");\n    allocationMode = \"abi\";\n  }\n  //now: construct the list of parameter types, attaching indexedness info\n  //and overall position (for later reconstruction)\n  let indexed;\n  let nonIndexed;\n  let abiAllocation; //the untransformed allocation for the non-indexed parameters\n  if (allocationMode === \"full\") {\n    nodeId = node.id.toString();\n    let parameters = node.parameters.parameters;\n    parameterTypes = parameters.map(definition => ({\n      //note: if node is defined, compiler had better be defined, too!\n      type: Ast.Import.definitionToType(definition, compilationId, compiler),\n      name: definition.name,\n      indexed: definition.indexed\n    }));\n    //now: split the list of parameters into indexed and non-indexed\n    [indexed, nonIndexed] = (0, partition_1.default)(parameterTypes, parameter => parameter.indexed);\n    try {\n      //now: perform the allocation for the non-indexed parameters!\n      abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair\n    } catch (_a) {\n      allocationMode = \"abi\";\n    }\n  }\n  if (allocationMode === \"abi\") {\n    //THIS IS DELIBERATELY NOT AN ELSE\n    nodeId = \"-1\"; //fake irrelevant ID\n    parameterTypes = abiEntry.inputs.map(abiParameter => ({\n      type: Import.abiParameterToType(abiParameter),\n      name: abiParameter.name,\n      indexed: abiParameter.indexed\n    }));\n    //now: split the list of parameters into indexed and non-indexed\n    [indexed, nonIndexed] = (0, partition_1.default)(parameterTypes, parameter => parameter.indexed);\n    //now: perform the allocation for the non-indexed parameters!\n    abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair\n  }\n  //now: transform the result appropriately\n  const nonIndexedArgumentsAllocation = abiAllocation.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"eventdata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  //now: allocate the indexed parameters\n  const startingTopic = abiEntry.anonymous ? 0 : 1; //if not anonymous, selector takes up topic 0\n  const indexedArgumentsAllocation = indexed.map((_ref, position) => {\n    let {\n      type,\n      name\n    } = _ref;\n    return {\n      type,\n      name,\n      pointer: {\n        location: \"eventtopic\",\n        topic: startingTopic + position\n      }\n    };\n  });\n  //finally: weave these back together\n  let argumentsAllocation = [];\n  for (let parameter of parameterTypes) {\n    let arrayToGrabFrom = parameter.indexed ? indexedArgumentsAllocation : nonIndexedArgumentsAllocation;\n    argumentsAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n  }\n  //...and return\n  return {\n    abi: abiEntry,\n    contextHash: undefined,\n    definedIn,\n    id,\n    arguments: argumentsAllocation,\n    allocationMode,\n    anonymous: abiEntry.anonymous\n  };\n}\nfunction allocateError(abiEntry, errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  //first: if we got passed just a node & no abi entry,\n  let id = undefined;\n  let definedIn = undefined;\n  let parametersFull = undefined;\n  const parametersAbi = abiEntry.inputs;\n  if (errorNode) {\n    //first, set parametersFull\n    parametersFull = errorNode.parameters.parameters;\n    //now, set id\n    id = (0, import_1.makeTypeId)(errorNode.id, compilationId);\n    //now, set definedIn\n    let contractNode = null;\n    for (const node of Object.values(referenceDeclarations)) {\n      if (node.nodeType === \"ContractDefinition\") {\n        if (node.nodes.some(subNode => subNode.id === errorNode.id)) {\n          contractNode = node;\n          break;\n        }\n      }\n      //if we didn't find it, then contractNode is null\n      //(and thus so will be definedIn)\n    }\n\n    if (contractNode === null) {\n      definedIn = null;\n    } else {\n      definedIn = Ast.Import.definitionToStoredType(contractNode, compilationId, compiler);\n    }\n  }\n  //otherwise, leave parametersFull, id, and definedIn undefined\n  const {\n    allocation: abiAllocation,\n    mode: allocationMode\n  } = allocateDataArguments(parametersFull, parametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, Evm.Utils.SELECTOR_SIZE //errors use a 4-byte selector\n  );\n  //finally: transform the allocation appropriately\n  const argumentsAllocation = abiAllocation.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"returndata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  const selector = Conversion.toBytes(AbiDataUtils.abiSelector(abiEntry));\n  return {\n    kind: \"revert\",\n    selector,\n    abi: abiEntry,\n    id,\n    definedIn,\n    arguments: argumentsAllocation,\n    allocationMode\n  };\n}\nfunction getCalldataAllocationsForContract(abi, contractNode, constructorContext, deployedContext, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let allocations = {\n    constructorAllocation: undefined,\n    //(if it doesn't then it will remain as default)\n    functionAllocations: {}\n  };\n  if (!abi) {\n    //if no ABI, can't do much!\n    allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n    return allocations;\n  }\n  for (let abiEntry of abi) {\n    if (AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry) || AbiDataUtils.abiEntryHasStorageParameters(abiEntry)) {\n      //the first of these conditions is a hack workaround for a Solidity bug.\n      //the second of these is because... seriously? we're not handling these\n      //(at least not for now!) (these only exist prior to Solidity 0.5.6,\n      //thankfully)\n      continue;\n    }\n    switch (abiEntry.type) {\n      case \"constructor\":\n        allocations.constructorAllocation = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n        debug(\"constructor alloc: %O\", allocations.constructorAllocation);\n        break;\n      case \"function\":\n        allocations.functionAllocations[AbiDataUtils.abiSelector(abiEntry)] = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n        break;\n      default:\n        //skip over fallback, error, and event\n        break;\n    }\n  }\n  if (!allocations.constructorAllocation) {\n    //set a default constructor allocation if we haven't allocated one yet\n    allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n    debug(\"default constructor alloc: %O\", allocations.constructorAllocation);\n  }\n  return allocations;\n}\nfunction defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext) {\n  if (!constructorContext) {\n    return undefined;\n  }\n  const rawLength = constructorContext.binary.length;\n  const offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n  const input = {\n    offset,\n    abi: AbiDataUtils.DEFAULT_CONSTRUCTOR_ABI,\n    arguments: [],\n    allocationMode: \"full\"\n  };\n  const output = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, \"full\"); //assume full, degrade as necessary\n  return {\n    input,\n    output\n  };\n}\n//note: context should be deployed context!\nfunction constructorOutputAllocation(context, contractNode, referenceDeclarations, allocationMode) {\n  if (!context) {\n    //just return a default abi mode result\n    return {\n      selector: new Uint8Array(),\n      allocationMode: \"abi\",\n      kind: \"bytecode\",\n      delegatecallGuard: false\n    };\n  }\n  const {\n    immutableReferences,\n    compilationId,\n    compiler,\n    contractKind,\n    binary\n  } = context;\n  let immutables;\n  if (allocationMode === \"full\" && immutableReferences) {\n    if (contractNode) {\n      debug(\"allocating immutables\");\n      immutables = [];\n      for (const [id, references] of Object.entries(immutableReferences)) {\n        if (references.length === 0) {\n          continue; //don't allocate immutables that don't exist\n        }\n\n        const astId = parseInt(id);\n        //get the corresponding variable node; potentially fail\n        const {\n          node: definition,\n          contract: definedIn\n        } = findNodeAndContract(contractNode.linearizedBaseContracts, referenceDeclarations, node => node.id === astId, contractNode);\n        if (!definition || definition.nodeType !== \"VariableDeclaration\") {\n          debug(\"didn't find definition for %d!\", astId);\n          allocationMode = \"abi\";\n          immutables = undefined;\n          break;\n        }\n        const definedInClass = Ast.Import.definitionToStoredType(definedIn, compilationId, compiler); //can skip reference declarations argument here\n        const dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n        immutables.push({\n          name: definition.name,\n          definedIn: definedInClass,\n          type: dataType,\n          pointer: {\n            location: \"returndata\",\n            start: references[0].start,\n            length: references[0].length\n          }\n        });\n      }\n    } else if (Object.entries(immutableReferences).length > 0) {\n      //if there are immutables, but no contract mode, go to abi mode\n      debug(\"immutables but no node!\");\n      allocationMode = \"abi\";\n    }\n  } else {\n    debug(\"no immutables\");\n  }\n  //now, is there a delegatecall guard?\n  let delegatecallGuard = false;\n  if (contractKind === \"library\") {\n    //note: I am relying on this being present!\n    //(also this part is a bit HACKy)\n    const pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n    const delegateCallGuardString = \"0x\" + pushAddressInstruction + \"..\".repeat(Evm.Utils.ADDRESS_SIZE);\n    if (binary.startsWith(delegateCallGuardString)) {\n      delegatecallGuard = true;\n    }\n  }\n  return {\n    selector: new Uint8Array(),\n    allocationMode,\n    kind: \"bytecode\",\n    immutables,\n    delegatecallGuard\n  };\n}\nfunction getCalldataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  let allocations = {\n    constructorAllocations: {},\n    functionAllocations: {}\n  };\n  for (let contract of contracts) {\n    const contractAllocations = getCalldataAllocationsForContract(contract.abi, contract.contractNode, contract.constructorContext, contract.deployedContext, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n    if (contract.constructorContext) {\n      allocations.constructorAllocations[contract.constructorContext.context] = contractAllocations.constructorAllocation;\n    }\n    if (contract.deployedContext) {\n      allocations.functionAllocations[contract.deployedContext.context] = contractAllocations.functionAllocations;\n      //set this up under both constructor *and* deployed! this is to handle\n      //constructor returndata decoding\n      allocations.constructorAllocations[contract.deployedContext.context] = contractAllocations.constructorAllocation;\n    }\n  }\n  return allocations;\n}\nexports.getCalldataAllocations = getCalldataAllocations;\nfunction getReturndataAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let useAst = Boolean(contractNode && contractNode.usedErrors);\n  if (useAst) {\n    const errorNodes = contractNode.usedErrors.map(errorNodeId => referenceDeclarations[errorNodeId]);\n    let abis;\n    try {\n      abis = errorNodes.map(errorNode => Ast.Utils.definitionToAbi(errorNode, referenceDeclarations));\n    } catch (_a) {\n      useAst = false;\n    }\n    if (useAst) {\n      //i.e. if the above operation succeeded\n      return contractNode.usedErrors.map(errorNodeId => referenceDeclarations[errorNodeId]).map((errorNode, index) => allocateError(abis[index], errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));\n    }\n  }\n  if (!useAst && abi) {\n    //deliberately *not* an else!\n    return abi.filter(abiEntry => abiEntry.type === \"error\").filter(abiEntry => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround\n    .map(abiEntry => allocateError(abiEntry, undefined, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));\n  }\n  //otherwise just return nothing\n  return [];\n}\nfunction getReturndataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  let allContexts = [].concat(...contracts.map(_ref2 => {\n    let {\n      deployedContext,\n      constructorContext\n    } = _ref2;\n    return [deployedContext, constructorContext];\n  })).filter(x => x) //filter out nonexistent contexts\n  .map(context => context.context);\n  allContexts.push(\"\"); //HACK: add fictional empty-string context to represent no-context\n  //holds allocations for a given context\n  let selfAllocations = {};\n  //holds allocations for *other* contexts\n  let additionalAllocations = {};\n  //now: process the allocations for each contract. we'll add each contract's\n  //allocations to *its* entries in allocations, and to every *other* entry\n  //in additionalAllocations.\n  for (const contract of contracts) {\n    const contractAllocations = getReturndataAllocationsForContract(contract.abi, contract.contractNode, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n    const contexts = [\n    //contexts for this contract\n    contract.deployedContext, contract.constructorContext].filter(x => x) //filter out nonexistent contexts\n    .map(context => context.context);\n    const otherContexts = allContexts.filter(\n    //contexts for all other contracts\n    contextHash => !contexts.includes(contextHash));\n    //add them to selfAllocations\n    for (const contextHash of contexts) {\n      selfAllocations[contextHash] = contractAllocations;\n    }\n    //add them to additionalAllocations\n    for (const contextHash of otherContexts) {\n      if (additionalAllocations[contextHash] === undefined) {\n        additionalAllocations[contextHash] = [];\n      }\n      additionalAllocations[contextHash] = additionalAllocations[contextHash].concat(contractAllocations);\n    }\n  }\n  let allocations = Object.assign({}, ...allContexts.map(contextHash => ({\n    [contextHash]: {}\n  })));\n  //now: perform coalescense!\n  for (const contract of contracts) {\n    //we're setting up contexts again, sorry >_>\n    const contexts = [\n    //contexts for this contract\n    contract.deployedContext, contract.constructorContext].filter(x => x) //filter out nonexistent contexts\n    .map(context => context.context);\n    for (const contextHash of contexts) {\n      allocations[contextHash] = coalesceReturndataAllocations(selfAllocations[contextHash] || [], additionalAllocations[contextHash] || []);\n      debug(\"allocations: %O\", allocations[contextHash]);\n    }\n  }\n  //...also coalesce the fake \"\" context\n  allocations[\"\"] = coalesceReturndataAllocations([], additionalAllocations[\"\"] || []);\n  debug(\"error allocations: %O\", allocations);\n  return allocations;\n}\nexports.getReturndataAllocations = getReturndataAllocations;\nfunction coalesceReturndataAllocations(selfAllocations, additionalAllocations) {\n  let bySelector = {};\n  //start with the additional allocations; we want to process\n  //the self allocations last, due to special handling of no-ID allocations there\n  for (const allocation of additionalAllocations) {\n    const signature = AbiDataUtils.abiSignature(allocation.abi);\n    const selector = web3_utils_1.default.soliditySha3({\n      type: \"string\",\n      value: signature\n    }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n    if (bySelector[selector]) {\n      //note: at this point, for any given signature, there should only be a\n      //no-ID allocation for that signature if it's the only one\n      if (allocation.id !== undefined) {\n        //delete anything with that signature but w/o an ID, or with this same ID\n        bySelector[selector] = bySelector[selector].filter(_ref3 => {\n          let {\n            abi,\n            id\n          } = _ref3;\n          return !(AbiDataUtils.abiSignature(abi) === signature && (id === undefined || id === allocation.id));\n        });\n        //add this allocation\n        bySelector[selector].push(allocation);\n      } else if (!bySelector[selector].some(_ref4 => {\n        let {\n          abi\n        } = _ref4;\n        return AbiDataUtils.abiSignature(abi) === signature;\n      })) {\n        //only add ID-less ones if there isn't anything of that signature already\n        bySelector[selector].push(allocation);\n      }\n    } else {\n      //if there's nothing there thus far, add it\n      bySelector[selector] = [allocation];\n    }\n  }\n  //now we're going to perform a modified version of this procedure for the self allocations:\n  //1. we're going to add to the front, not the back\n  //2. we can add an ID-less one even if there are already ones with IDs there\n  //(sorry for the copypaste)\n  for (const allocation of selfAllocations) {\n    const signature = AbiDataUtils.abiSignature(allocation.abi);\n    const selector = web3_utils_1.default.soliditySha3({\n      type: \"string\",\n      value: signature\n    }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n    if (bySelector[selector]) {\n      //delete anything with that signature but w/o an ID, or with this same ID\n      //(if this alloc has no ID, this will only delete ID-less ones :) )\n      bySelector[selector] = bySelector[selector].filter(_ref5 => {\n        let {\n          abi,\n          id\n        } = _ref5;\n        return !(AbiDataUtils.abiSignature(abi) === signature && (id === undefined || id === allocation.id));\n      });\n      //add this allocation to front, not back!\n      bySelector[selector].unshift(allocation);\n    } else {\n      //if there's nothing there thus far, add it\n      bySelector[selector] = [allocation];\n    }\n  }\n  return bySelector;\n}\nfunction getEventAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  if (!abi) {\n    //can't do much if no ABI!\n    return [];\n  }\n  return abi.filter(abiEntry => abiEntry.type === \"event\").filter(abiEntry => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround\n  .map(abiEntry => ({\n    selector: AbiDataUtils.abiSelector(abiEntry),\n    anonymous: abiEntry.anonymous,\n    topics: AbiDataUtils.topicsCount(abiEntry),\n    allocation: allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler)\n  }));\n  //note we do *not* filter out undefined allocations; we need these as placeholders\n}\n//WARNING: this function is full of hacks... sorry\nfunction getEventAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  let allowConstructorEvents = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  //first: do allocations for individual contracts\n  let individualAllocations = {};\n  let groupedAllocations = {};\n  let contextSwapMap = {}; //maps deployed to constructor & vice versa\n  let allocations = {};\n  for (const {\n    abi,\n    deployedContext,\n    constructorContext,\n    contractNode,\n    compilationId,\n    compiler\n  } of contracts) {\n    if (!deployedContext && !constructorContext && !contractNode) {\n      //we'll need *one* of these at least\n      continue;\n    }\n    const contractAllocations = getEventAllocationsForContract(abi, contractNode, referenceDeclarations[compilationId], userDefinedTypes, abiAllocations, compilationId, compiler);\n    const key = makeContractKey(deployedContext || constructorContext, contractNode ? contractNode.id : undefined, compilationId);\n    if (individualAllocations[key] === undefined) {\n      individualAllocations[key] = {};\n    }\n    for (const allocationTemporary of contractAllocations) {\n      //we'll use selector *even for anonymous* here, because it's just\n      //for determining what overrides what at this point\n      individualAllocations[key][allocationTemporary.selector] = {\n        context: deployedContext || constructorContext,\n        contractNode,\n        allocationTemporary,\n        compilationId\n      };\n    }\n    //also: set up the swap map\n    if (deployedContext && constructorContext) {\n      contextSwapMap[deployedContext.context] = constructorContext.context;\n      contextSwapMap[constructorContext.context] = deployedContext.context;\n    }\n  }\n  //now: put things together for inheritance\n  //note how we always put things in order from most derived to most base\n  for (let contextOrId in individualAllocations) {\n    groupedAllocations[contextOrId] = {};\n    for (let selector in individualAllocations[contextOrId]) {\n      let {\n        context,\n        contractNode,\n        allocationTemporary,\n        compilationId\n      } = individualAllocations[contextOrId][selector];\n      debug(\"allocationTemporary: %O\", allocationTemporary);\n      let allocationsTemporary = allocationTemporary.allocation ? [allocationTemporary] : []; //filter out undefined allocations\n      //first, copy from individual allocations\n      groupedAllocations[contextOrId][selector] = {\n        context,\n        contractNode,\n        allocationsTemporary\n      };\n      //if no contract node, that's all.  if there is...\n      if (contractNode) {\n        //...we have to do inheritance processing\n        debug(\"contract Id: %d\", contractNode.id);\n        debug(\"base contracts: %o\", contractNode.linearizedBaseContracts);\n        let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n        linearizedBaseContractsMinusSelf.shift(); //remove contract itself; only want ancestors\n        for (let baseId of linearizedBaseContractsMinusSelf) {\n          debug(\"checking baseId: %d\", baseId);\n          let baseNode = referenceDeclarations[compilationId][baseId];\n          if (!baseNode || baseNode.nodeType !== \"ContractDefinition\") {\n            debug(\"failed to find node for baseId: %d\", baseId);\n            break; //not a continue!\n            //if we can't find the base node, it's better to stop the loop,\n            //rather than continue to potentially erroneous things\n          }\n          //note: we're not actually going to *use* the baseNode here.\n          //we're just checking for whether we can *find* it\n          //why? because if we couldn't find it, that means that events defined in\n          //base contracts *weren't* skipped earlier, and so we shouldn't now add them in\n          let baseContractInfo = contracts.find(contractAllocationInfo => contractAllocationInfo.compilationId === compilationId && contractAllocationInfo.contractNode && contractAllocationInfo.contractNode.id === baseId);\n          if (!baseContractInfo) {\n            //similar to above... this failure case can happen when there are\n            //two contracts with the same name and you attempt to use the\n            //artifacts; say you have contracts A, B, and B', where A inherits\n            //from B, and B and B' have the same name, and B' is the one that\n            //gets the artifact; B will end up in reference declarations and so\n            //get found above, but it won't appear in contracts, causing the\n            //problem here.  Unfortunately I don't know any great way to handle this,\n            //so, uh, we treat it as a failure same as above.\n            debug(\"failed to find contract info for baseId: %d\", baseId);\n            break;\n          }\n          let baseContext = baseContractInfo.deployedContext || baseContractInfo.constructorContext;\n          let baseKey = makeContractKey(baseContext, baseId, compilationId);\n          if (individualAllocations[baseKey][selector] !== undefined) {\n            let baseAllocation = individualAllocations[baseKey][selector].allocationTemporary;\n            debug(\"(probably) pushing inherited alloc from baseId: %d\", baseId);\n            if (baseAllocation.allocation) {\n              //don't push undefined!\n              groupedAllocations[contextOrId][selector].allocationsTemporary.push(baseAllocation);\n            }\n          }\n        }\n      }\n    }\n  }\n  //finally: transform into final form & return,\n  //filtering out things w/o a context\n  for (let contractKey in groupedAllocations) {\n    if (!hasContext(contractKey)) {\n      continue;\n      //(this filters out ones that had no context and therefore were\n      //given by ID; we needed these at the previous stage but from\n      //here on they're irrelevant)\n    }\n\n    let contextHash = contextHashForKey(contractKey);\n    for (let selector in groupedAllocations[contextHash]) {\n      let {\n        allocationsTemporary,\n        context\n      } = groupedAllocations[contextHash][selector];\n      for (let {\n        anonymous,\n        topics,\n        allocation\n      } of allocationsTemporary) {\n        let contractKind = context.contractKind; //HACK: this is the wrong context, but libraries can't inherit, so it's OK\n        if (contractKind !== \"library\") {\n          contractKind = \"contract\"; //round off interfaces to being contracts for our purposes :P\n        }\n\n        allocation = Object.assign(Object.assign({}, allocation), {\n          contextHash\n        }); //the allocation's context hash at this point depends on where it was defined, but\n        //that's not what we want going in the final allocation table!\n        if (allocations[topics] === undefined) {\n          allocations[topics] = {\n            bySelector: {},\n            anonymous: {\n              contract: {},\n              library: {}\n            }\n          };\n        }\n        if (!anonymous) {\n          if (allocations[topics].bySelector[selector] === undefined) {\n            allocations[topics].bySelector[selector] = {\n              contract: {},\n              library: {}\n            };\n          }\n          //push the allocation (non-anonymous case)\n          if (allocations[topics].bySelector[selector][contractKind][contextHash] === undefined) {\n            allocations[topics].bySelector[selector][contractKind][contextHash] = [];\n          }\n          allocations[topics].bySelector[selector][contractKind][contextHash].push(allocation);\n          //...and push it in the swapped context too if that exists\n          //HACK: don't do this for libraries! library events are already\n          //considered always in play, so including them *twice* would cause\n          //problems... fortunately library constructors don't emit events!\n          if (allowConstructorEvents && contextHash in contextSwapMap && contractKind !== \"library\") {\n            const swappedHash = contextSwapMap[contextHash];\n            if (allocations[topics].bySelector[selector][contractKind][swappedHash] === undefined) {\n              allocations[topics].bySelector[selector][contractKind][swappedHash] = [];\n            }\n            allocations[topics].bySelector[selector][contractKind][swappedHash].push(allocation);\n          }\n        } else {\n          //push the allocation (anonymous case)\n          if (allocations[topics].anonymous[contractKind][contextHash] === undefined) {\n            allocations[topics].anonymous[contractKind][contextHash] = [];\n          }\n          allocations[topics].anonymous[contractKind][contextHash].push(allocation);\n          //...and push it in the swapped context too if that exists\n          //(and it's not a library, see above)\n          if (allowConstructorEvents && contextHash in contextSwapMap && contractKind !== \"library\") {\n            const swappedHash = contextSwapMap[contextHash];\n            if (allocations[topics].anonymous[contractKind][swappedHash] === undefined) {\n              allocations[topics].anonymous[contractKind][swappedHash] = [];\n            }\n            allocations[topics].anonymous[contractKind][swappedHash].push(allocation);\n          }\n        }\n      }\n    }\n  }\n  return allocations;\n}\nexports.getEventAllocations = getEventAllocations;\n//if derivedContractNode is passed, we check that before referenceDeclarations\nfunction findNodeAndContract(linearizedBaseContracts, referenceDeclarations, condition, derivedContractNode) {\n  const searchResult = linearizedBaseContracts.reduce((foundNodeAndContract, baseContractId) => {\n    if (foundNodeAndContract !== undefined) {\n      return foundNodeAndContract; //once we've found something, we don't need to keep looking\n    }\n\n    debug(\"searching contract %d\", baseContractId);\n    let baseContractNode = derivedContractNode && baseContractId === derivedContractNode.id ? derivedContractNode //skip the lookup if we already have the right node! this is to reduce errors from collision\n    : referenceDeclarations[baseContractId];\n    if (baseContractNode === undefined || baseContractNode.nodeType !== \"ContractDefinition\") {\n      debug(\"bad contract node!\");\n      return null; //return null rather than undefined so that this will propagate through\n      //(i.e. by returning null here we give up the search)\n      //(we don't want to continue due to possibility of grabbing the wrong override)\n    }\n\n    const node = baseContractNode.nodes.find(condition); //may be undefined! that's OK!\n    if (node) {\n      debug(\"found node: %o\", node);\n      return {\n        node,\n        contract: baseContractNode\n      };\n    } else {\n      return undefined;\n    }\n  }, undefined //start with no node found\n  );\n\n  return searchResult || {\n    node: undefined,\n    contract: undefined\n  };\n}\nfunction makeContractKey(context, id, compilationId) {\n  return context ? context.context : id + \":\" + compilationId; //HACK!\n}\n\nfunction hasContext(key) {\n  return key.startsWith(\"0x\"); //HACK!\n}\n\nfunction contextHashForKey(key) {\n  return hasContext(key) ? key //HACK!\n  : undefined;\n}","map":{"version":3,"mappings":"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","names":["debug","exports","kind","selector","Uint8Array","allocationMode","getAbiAllocations","userDefinedTypes","allocations","dataType","Object","values","typeClass","allocateStruct","_","existingAllocations","allocateMembers","id","memberTypes","parentId","members","start","dynamic","memberAllocations","member","length","dynamicMember","size","abiSizeAndAllocate","type","undefined","pointer","location","push","name","Evm","Utils","WORD_SIZE","visibility","isZero","baseSize","baseType","toNumber","allocation","storedType","Common","UnknownUserDefinedTypeError","Format","Types","typeString","memberSize","memberDynamic","abiSizeInfo","allocateCalldataAndReturndata","abiEntry","contractNode","referenceDeclarations","abiAllocations","compilationId","compiler","constructorContext","deployedContext","node","inputParametersFull","outputParametersFull","inputParametersAbi","outputParametersAbi","offset","rawLength","binary","nodes","find","functionNode","AbiDataUtils","definitionMatchesAbi","SELECTOR_SIZE","linearizedBaseContracts","findNodeAndContract","Boolean","nodeType","parameters","returnParameters","inputs","outputs","Ast","getterParameters","abiAllocationInput","mode","inputMode","allocateDataArguments","abiAllocationOutput","outputMode","inputArgumentsAllocation","map","outputArgumentsAllocation","inputsAllocation","abi","arguments","outputsAllocation","constructorOutputAllocation","input","output","fullModeParameters","abiParameters","parameterTypes","abiAllocation","parameter","Import","definitionToType","abiParameterToType","allocateEvent","nodeId","definedIn","eventNode","linearizedBaseContractsMinusSelf","slice","shift","definitionToStoredType","indexed","nonIndexed","toString","definition","abiParameter","nonIndexedArgumentsAllocation","startingTopic","anonymous","indexedArgumentsAllocation","position","topic","argumentsAllocation","arrayToGrabFrom","contextHash","allocateError","errorNode","parametersFull","parametersAbi","some","subNode","Conversion","toBytes","abiSelector","getCalldataAllocationsForContract","constructorAllocation","functionAllocations","defaultConstructorAllocation","abiEntryIsObviouslyIllTyped","abiEntryHasStorageParameters","DEFAULT_CONSTRUCTOR_ABI","context","delegatecallGuard","immutableReferences","contractKind","immutables","references","entries","astId","parseInt","contract","definedInClass","pushAddressInstruction","ADDRESS_SIZE","delegateCallGuardString","repeat","startsWith","getCalldataAllocations","contracts","constructorAllocations","contractAllocations","getReturndataAllocationsForContract","useAst","usedErrors","errorNodes","errorNodeId","abis","definitionToAbi","index","filter","getReturndataAllocations","allContexts","concat","x","selfAllocations","additionalAllocations","contexts","otherContexts","includes","assign","coalesceReturndataAllocations","bySelector","signature","abiSignature","web3_utils_1","soliditySha3","value","unshift","getEventAllocationsForContract","topics","topicsCount","getEventAllocations","allowConstructorEvents","individualAllocations","groupedAllocations","contextSwapMap","key","makeContractKey","allocationTemporary","contextOrId","allocationsTemporary","baseId","baseNode","baseContractInfo","contractAllocationInfo","baseContext","baseKey","baseAllocation","contractKey","hasContext","contextHashForKey","library","swappedHash","condition","derivedContractNode","searchResult","reduce","foundNodeAndContract","baseContractId","baseContractNode"],"sourceRoot":"","sources":["../../../../lib/abi-data/allocate/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}