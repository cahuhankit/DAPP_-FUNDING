{"ast":null,"code":"\"use strict\";\n\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeStorageReference = exports.decodeStorageReferenceByAddress = exports.decodeStorage = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:storage:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst errors_1 = require(\"../../errors\");\nfunction* decodeStorage(dataType, pointer, info) {\n  if (Format.Types.isReferenceType(dataType)) {\n    return yield* decodeStorageReference(dataType, pointer, info);\n  } else {\n    return yield* Basic.Decode.decodeBasic(dataType, pointer, info);\n  }\n}\nexports.decodeStorage = decodeStorage;\n//decodes storage at the address *read* from the pointer -- hence why this takes DataPointer rather than StoragePointer.\n//NOTE: ONLY for use with pointers to reference types!\n//Of course, pointers to value types don't exist in Solidity, so that warning is redundant, but...\nfunction* decodeStorageReferenceByAddress(dataType, pointer, info) {\n  const allocations = info.allocations.storage;\n  let rawValue;\n  try {\n    rawValue = yield* (0, read_1.default)(pointer, info.state);\n  } catch (error) {\n    return (0, errors_1.handleDecodingError)(dataType, error);\n  }\n  const startOffset = Conversion.toBN(rawValue);\n  let rawSize;\n  try {\n    rawSize = (0, allocate_1.storageSize)(dataType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n  } catch (error) {\n    return (0, errors_1.handleDecodingError)(dataType, error);\n  }\n  //we *know* the type being decoded must be sized in words, because it's a\n  //reference type, but TypeScript doesn't, so we'll have to use a type\n  //coercion\n  const size = rawSize.words;\n  //now, construct the storage pointer\n  const newPointer = {\n    location: \"storage\",\n    range: {\n      from: {\n        slot: {\n          offset: startOffset\n        },\n        index: 0\n      },\n      to: {\n        slot: {\n          offset: startOffset.addn(size - 1)\n        },\n        index: Evm.Utils.WORD_SIZE - 1\n      }\n    }\n  };\n  //dispatch to decodeStorageReference\n  return yield* decodeStorageReference(dataType, newPointer, info);\n}\nexports.decodeStorageReferenceByAddress = decodeStorageReferenceByAddress;\nfunction* decodeStorageReference(dataType, pointer, info) {\n  var data;\n  var length;\n  const {\n    state\n  } = info;\n  const allocations = info.allocations.storage;\n  switch (dataType.typeClass) {\n    case \"array\":\n      {\n        debug(\"storage array! %o\", pointer);\n        let lengthAsBN;\n        switch (dataType.kind) {\n          case \"dynamic\":\n            debug(\"dynamic array\");\n            debug(\"type %O\", dataType);\n            try {\n              data = yield* (0, read_1.default)(pointer, state);\n            } catch (error) {\n              return (0, errors_1.handleDecodingError)(dataType, error);\n            }\n            lengthAsBN = Conversion.toBN(data);\n            break;\n          case \"static\":\n            debug(\"static array\");\n            lengthAsBN = dataType.length;\n            break;\n        }\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_a) {\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN\n            }\n          };\n        }\n        debug(\"length %o\", length);\n        debug(\"about to determine baseSize\");\n        let baseSize;\n        try {\n          baseSize = (0, allocate_1.storageSize)(dataType.baseType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n        } catch (error) {\n          return (0, errors_1.handleDecodingError)(dataType, error);\n        }\n        debug(\"baseSize %o\", baseSize);\n        //we are going to make a list of child ranges, pushing them one by one onto\n        //this list, and then decode them; the first part will vary based on whether\n        //we're in the words case or the bytes case, the second will not\n        let ranges = [];\n        if (Utils.isWordsLength(baseSize)) {\n          //currentSlot will point to the start of the entry being decoded\n          let currentSlot = {\n            path: pointer.range.from.slot,\n            offset: new bn_js_1.default(0),\n            hashPath: dataType.kind === \"dynamic\"\n          };\n          for (let i = 0; i < length; i++) {\n            let childRange = {\n              from: {\n                slot: {\n                  path: currentSlot.path,\n                  offset: currentSlot.offset.clone(),\n                  hashPath: currentSlot.hashPath\n                },\n                index: 0\n              },\n              to: {\n                slot: {\n                  path: currentSlot.path,\n                  offset: currentSlot.offset.addn(baseSize.words - 1),\n                  hashPath: currentSlot.hashPath\n                },\n                index: Evm.Utils.WORD_SIZE - 1\n              }\n            };\n            ranges.push(childRange);\n            currentSlot.offset.iaddn(baseSize.words);\n          }\n        } else {\n          const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n          debug(\"perWord %d\", perWord);\n          //currentPosition will point to the start of the entry being decoded\n          //note we have baseSize.bytes <= Evm.Utils.WORD_SIZE\n          let currentPosition = {\n            slot: {\n              path: pointer.range.from.slot,\n              offset: new bn_js_1.default(0),\n              hashPath: dataType.kind === \"dynamic\"\n            },\n            index: Evm.Utils.WORD_SIZE - baseSize.bytes //note the starting index!\n          };\n\n          for (let i = 0; i < length; i++) {\n            let childRange = {\n              from: {\n                slot: {\n                  path: currentPosition.slot.path,\n                  offset: currentPosition.slot.offset.clone(),\n                  hashPath: currentPosition.slot.hashPath\n                },\n                index: currentPosition.index\n              },\n              length: baseSize.bytes\n            };\n            ranges.push(childRange);\n            currentPosition.index -= baseSize.bytes;\n            if (currentPosition.index < 0) {\n              currentPosition.slot.offset.iaddn(1);\n              currentPosition.index = Evm.Utils.WORD_SIZE - baseSize.bytes;\n            }\n          }\n        }\n        let decodedChildren = [];\n        for (let childRange of ranges) {\n          decodedChildren.push(yield* decodeStorage(dataType.baseType, {\n            location: \"storage\",\n            range: childRange\n          }, info));\n        }\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedChildren\n        };\n      }\n    case \"bytes\":\n    case \"string\":\n      {\n        try {\n          data = yield* (0, read_1.default)(pointer, state);\n        } catch (error) {\n          return (0, errors_1.handleDecodingError)(dataType, error);\n        }\n        let lengthByte = data[Evm.Utils.WORD_SIZE - 1];\n        if (lengthByte % 2 == 0) {\n          // string lives in word, length is last byte / 2\n          length = lengthByte / 2;\n          debug(\"in-word; length %o\", length);\n          return yield* Bytes.Decode.decodeBytes(dataType, {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: pointer.range.from.slot,\n                index: 0\n              },\n              to: {\n                slot: pointer.range.from.slot,\n                index: length - 1\n              }\n            }\n          }, info);\n        } else {\n          let lengthAsBN = Conversion.toBN(data).subn(1).divn(2);\n          try {\n            length = lengthAsBN.toNumber();\n          } catch (_b) {\n            return {\n              //again with the TS failures...\n              type: dataType,\n              kind: \"error\",\n              error: {\n                kind: \"OverlongArraysAndStringsNotImplementedError\",\n                lengthAsBN\n              }\n            };\n          }\n          debug(\"new-word, length %o\", length);\n          return yield* Bytes.Decode.decodeBytes(dataType, {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: {\n                  path: pointer.range.from.slot,\n                  offset: new bn_js_1.default(0),\n                  hashPath: true\n                },\n                index: 0\n              },\n              length\n            }\n          }, info);\n        }\n      }\n    case \"struct\":\n      {\n        const typeId = dataType.id;\n        const structAllocation = allocations[typeId];\n        if (!structAllocation) {\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: dataType\n            }\n          };\n        }\n        let decodedMembers = [];\n        const members = structAllocation.members;\n        for (let index = 0; index < members.length; index++) {\n          const memberAllocation = members[index];\n          const memberPointer = memberAllocation.pointer;\n          //the type system thinks memberPointer might also be a constant\n          //definition pointer.  However, structs can't contain constants,\n          //so *we* know it's not, and can safely coerce it.\n          debug(\"pointer %O\", pointer);\n          const childRange = {\n            from: {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: memberPointer.range.from.slot.offset.clone()\n                //note that memberPointer should have no path\n              },\n\n              index: memberPointer.range.from.index\n            },\n            to: {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: memberPointer.range.to.slot.offset.clone()\n                //note that memberPointer should have no path\n              },\n\n              index: memberPointer.range.to.index\n            }\n          };\n          let storedType = info.userDefinedTypes[typeId];\n          if (!storedType) {\n            return {\n              type: dataType,\n              kind: \"error\",\n              error: {\n                kind: \"UserDefinedTypeNotFoundError\",\n                type: dataType\n              }\n            };\n          }\n          let storedMemberType = storedType.memberTypes[index].type;\n          let memberType = Format.Types.specifyLocation(storedMemberType, \"storage\");\n          decodedMembers.push({\n            name: memberAllocation.name,\n            value: yield* decodeStorage(memberType, {\n              location: \"storage\",\n              range: childRange\n            }, info)\n          });\n        }\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedMembers\n        };\n      }\n    case \"mapping\":\n      {\n        debug(\"decoding mapping\");\n        const valueType = dataType.valueType;\n        let valueSize;\n        try {\n          valueSize = (0, allocate_1.storageSize)(valueType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n        } catch (error) {\n          return (0, errors_1.handleDecodingError)(dataType, error);\n        }\n        let decodedEntries = [];\n        const baseSlot = pointer.range.from.slot;\n        debug(\"baseSlot %o\", baseSlot);\n        debug(\"base slot address %o\", Utils.slotAddress(baseSlot));\n        const keySlots = info.mappingKeys.filter(_ref => {\n          let {\n            path\n          } = _ref;\n          return Utils.slotAddress(baseSlot).eq(Utils.slotAddress(path));\n        });\n        for (const {\n          key\n        } of keySlots) {\n          let valuePointer;\n          if (Utils.isWordsLength(valueSize)) {\n            valuePointer = {\n              location: \"storage\",\n              range: {\n                from: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: 0\n                },\n                to: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(valueSize.words - 1)\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              }\n            };\n          } else {\n            valuePointer = {\n              location: \"storage\",\n              range: {\n                from: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: Evm.Utils.WORD_SIZE - valueSize.bytes\n                },\n                to: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              }\n            };\n          }\n          decodedEntries.push({\n            key,\n            value: yield* decodeStorage(valueType, valuePointer, info)\n          });\n        }\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedEntries\n        };\n      }\n  }\n}\nexports.decodeStorageReference = decodeStorageReference;","map":{"version":3,"mappings":"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","names":["debug","decodeStorage","dataType","pointer","info","Format","Types","isReferenceType","decodeStorageReference","Basic","Decode","decodeBasic","exports","decodeStorageReferenceByAddress","allocations","storage","rawValue","state","error","startOffset","Conversion","toBN","rawSize","userDefinedTypes","currentContext","compiler","size","words","newPointer","location","range","from","slot","offset","index","to","addn","Evm","Utils","WORD_SIZE","data","length","typeClass","lengthAsBN","kind","toNumber","type","baseSize","baseType","ranges","isWordsLength","currentSlot","path","bn_js_1","hashPath","i","childRange","clone","push","iaddn","perWord","Math","floor","bytes","currentPosition","decodedChildren","value","lengthByte","Bytes","decodeBytes","subn","divn","typeId","id","structAllocation","decodedMembers","members","memberAllocation","memberPointer","storedType","storedMemberType","memberTypes","memberType","specifyLocation","name","valueType","valueSize","decodedEntries","baseSlot","slotAddress","keySlots","mappingKeys","filter","eq","key","valuePointer"],"sourceRoot":"","sources":["../../../../lib/storage/decode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}