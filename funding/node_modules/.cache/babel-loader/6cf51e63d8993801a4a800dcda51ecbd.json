{"ast":null,"code":"\"use strict\";\n\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeLiteral = exports.decodeStack = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:stack:decode\");\nconst AbiData = __importStar(require(\"../../abi-data\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Memory = __importStar(require(\"../../memory\"));\nconst Storage = __importStar(require(\"../../storage\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nfunction* decodeStack(dataType, pointer, info) {\n  let rawValue;\n  try {\n    rawValue = yield* (0, read_1.default)(pointer, info.state);\n  } catch (error) {\n    return (0, errors_1.handleDecodingError)(dataType, error);\n  }\n  const literalPointer = {\n    location: \"stackliteral\",\n    literal: rawValue\n  };\n  return yield* decodeLiteral(dataType, literalPointer, info);\n}\nexports.decodeStack = decodeStack;\nfunction* decodeLiteral(dataType, pointer, info) {\n  debug(\"type %O\", dataType);\n  debug(\"pointer %o\", pointer);\n  if (Format.Types.isReferenceType(dataType)) {\n    switch (dataType.location) {\n      case \"memory\":\n        //first: do we have a memory pointer? if so we can just dispatch to\n        //decodeMemoryReference\n        return yield* Memory.Decode.decodeMemoryReferenceByAddress(dataType, pointer, info);\n      case \"storage\":\n        //next: do we have a storage pointer (which may be a mapping)? if so, we can\n        //we dispatch to decodeStorageByAddress\n        return yield* Storage.Decode.decodeStorageReferenceByAddress(dataType, pointer, info);\n      case \"calldata\":\n        //next: do we have a calldata pointer?\n        //if it's a lookup type, it'll need special handling\n        if (dataType.typeClass === \"bytes\" || dataType.typeClass === \"string\" || dataType.typeClass === \"array\" && dataType.kind === \"dynamic\") {\n          const lengthAsBN = Conversion.toBN(pointer.literal.slice(Evm.Utils.WORD_SIZE));\n          const locationOnly = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);\n          return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, {\n            location: \"stackliteral\",\n            literal: locationOnly\n          }, info, {\n            abiPointerBase: 0,\n            lengthOverride: lengthAsBN\n          });\n        } else {\n          //multivalue case -- this case is straightforward\n          return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, pointer, info, {\n            abiPointerBase: 0 //let's be explicit\n          });\n        }\n    }\n  }\n  //next: do we have an external function?  these work differently on the stack\n  //than elsewhere, so we can't just pass it on to decodeBasic.\n  if (dataType.typeClass === \"function\" && dataType.visibility === \"external\") {\n    let address = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);\n    let selectorWord = pointer.literal.slice(-Evm.Utils.WORD_SIZE);\n    if (!Basic.Decode.checkPaddingLeft(address, Evm.Utils.ADDRESS_SIZE) || !Basic.Decode.checkPaddingLeft(selectorWord, Evm.Utils.SELECTOR_SIZE)) {\n      return {\n        type: dataType,\n        kind: \"error\",\n        error: {\n          kind: \"FunctionExternalStackPaddingError\",\n          rawAddress: Conversion.toHexString(address),\n          rawSelector: Conversion.toHexString(selectorWord)\n        }\n      };\n    }\n    let selector = selectorWord.slice(-Evm.Utils.SELECTOR_SIZE);\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: yield* Basic.Decode.decodeExternalFunction(address, selector, info)\n    };\n  }\n  //finally, if none of the above hold, we can just dispatch to decodeBasic.\n  //however, note that because we're on the stack, we use the permissive padding\n  //option so that errors won't result due to values with bad padding\n  //(of numeric or bytesN type, anyway)\n  return yield* Basic.Decode.decodeBasic(dataType, pointer, info, {\n    paddingMode: \"permissive\"\n  });\n}\nexports.decodeLiteral = decodeLiteral;","map":{"version":3,"mappings":"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","names":["debug","decodeStack","dataType","pointer","info","rawValue","state","error","literalPointer","location","literal","decodeLiteral","exports","Format","Types","isReferenceType","Memory","Decode","decodeMemoryReferenceByAddress","Storage","decodeStorageReferenceByAddress","typeClass","kind","lengthAsBN","Conversion","toBN","slice","Evm","Utils","WORD_SIZE","locationOnly","AbiData","decodeAbiReferenceByAddress","abiPointerBase","lengthOverride","visibility","address","selectorWord","Basic","checkPaddingLeft","ADDRESS_SIZE","SELECTOR_SIZE","type","rawAddress","toHexString","rawSelector","selector","value","decodeExternalFunction","decodeBasic","paddingMode"],"sourceRoot":"","sources":["../../../../lib/stack/decode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}