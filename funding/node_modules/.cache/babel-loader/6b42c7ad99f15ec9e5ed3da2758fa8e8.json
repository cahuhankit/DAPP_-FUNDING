{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.boolCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:bool\");\nconst dispatch_1 = require(\"./dispatch\");\nconst errors_1 = require(\"./errors\");\nconst Utils = __importStar(require(\"./utils\"));\nconst Messages = __importStar(require(\"./messages\"));\nconst boolCasesBasic = [boolFromBoolean, boolFromString, boolFromBoxedPrimitive, boolFromCodecBoolValue, boolFromCodecBoolError, boolFromCodecUdvtValue, boolFromCodecUdvtError, boolFromOther //must go last!\n];\n\nexports.boolCases = [boolFromTypeValueInput, ...boolCasesBasic];\nfunction* boolFromBoolean(dataType, input, wrapOptions) {\n  if (typeof input !== \"boolean\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boolean\");\n  }\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBoolean: input\n    }\n  };\n}\nfunction* boolFromString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  const lowerCasedInput = input.toLowerCase();\n  if (wrapOptions.strictBooleans && ![\"true\", \"false\", \"1\", \"0\"].includes(lowerCasedInput)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, \"Input was not 'true', 'false', '1', or '0'\");\n  }\n  //strings are true unless they're falsy or the case-insensitive strings \"false\" or \"0\"\n  const asBoolean = Boolean(input) && ![\"false\", \"0\"].includes(lowerCasedInput);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBoolean\n    }\n  };\n}\nfunction* boolFromBoxedPrimitive(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedPrimitive(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed primitive\");\n  }\n  //unbox and try again\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, exports.boolCases);\n}\nfunction* boolFromCodecBoolValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"bool\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1,\n    //only specificity 1 due to BoolError case\n    Messages.errorResultMessage);\n  }\n  const asBoolean = input.value.asBoolean;\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBoolean\n    }\n  };\n}\nfunction* boolFromCodecBoolError(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"bool\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"error\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a value rather than an error\");\n  }\n  //these two error types will be regarded as true\n  const allowedErrors = [\"BoolOutOfRangeError\", \"BoolPaddingError\"];\n  if (!allowedErrors.includes(input.error.kind)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBoolean: true\n    }\n  };\n}\nfunction* boolFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n  if (input.type !== \"bool\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n  //extract value & try again, disallowing type/value input\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), boolCasesBasic);\n}\nfunction* boolFromCodecUdvtValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"userDefinedValueType\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  return yield* boolFromCodecBoolValue(dataType, input.value, wrapOptions);\n}\nfunction* boolFromCodecUdvtError(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"userDefinedValueType\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"error\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a value rather than an error\");\n  }\n  //wrapped errors will have to be unwrapped, others can be rejected\n  if (input.error.kind !== \"WrappedError\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  return yield* boolFromCodecBoolError(dataType, input.error.error, wrapOptions);\n}\nfunction* boolFromOther(dataType, input, wrapOptions) {\n  //fallback case: just go by truthiness/falsiness\n  //(this case has to be last because there are various other\n  //cases we do not want to go by truthiness/falsiness!)\n  if (Utils.isWrappedResult(input)) {\n    //...except for these, which may error\n    //(note that we do this even when loose is on!)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n  }\n  if (Utils.isTypeValueInput(input)) {\n    //...and these, which also may error\n    //(note that we do this even when loose is on!)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a type/value pair\");\n  }\n  //...and also we don't do this case if strictBooleans is turned on\n  if (wrapOptions.strictBooleans) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was neither a boolean nor a boolean string\");\n  }\n  const asBoolean = Boolean(input);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBoolean\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["debug","boolCasesBasic","boolFromBoolean","boolFromString","boolFromBoxedPrimitive","boolFromCodecBoolValue","boolFromCodecBoolError","boolFromCodecUdvtValue","boolFromCodecUdvtError","boolFromOther","exports","boolFromTypeValueInput","dataType","input","wrapOptions","errors_1","name","type","kind","value","asBoolean","lowerCasedInput","toLowerCase","strictBooleans","includes","Boolean","Utils","isBoxedPrimitive","valueOf","isWrappedResult","typeClass","Messages","wrappedTypeMessage","errorResultMessage","allowedErrors","error","isTypeValueInput","specifiedTypeMessage","loose"],"sourceRoot":"","sources":["../../../lib/wrap/bool.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}