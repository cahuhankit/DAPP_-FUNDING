{"ast":null,"code":"const Reason = require(\"./reason\");\nconst handlers = require(\"./handlers\");\nconst utils = require(\"./utils\");\nconst override = {\n  timeoutMessage: \"not mined within\",\n  // Substring of timeout err fired by web3\n  defaultWeb3Error: \"please check your gas limit\",\n  // Substring of default Web3 error\n  defaultMaxBlocks: 50,\n  // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt(message) {\n    const hasReceipt = message && message.includes(\"{\");\n    message.includes(\"}\");\n    if (hasReceipt) {\n      const receiptString = \"{\" + message.split(\"{\")[1].trim();\n      try {\n        return JSON.parse(receiptString);\n      } catch (err) {\n        // ignore\n      }\n    }\n  },\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: async function (context, web3Error) {\n    const constructor = this;\n    let currentBlock = override.defaultMaxBlocks;\n\n    // Reject after attempting to get reason string if we shouldn't be waiting.\n    if (!handlers.ignoreTimeoutError(context, web3Error)) {\n      // We might have been routed here in web3 >= beta.34 by their own status check\n      // error. We want to extract the receipt, emit a receipt event\n      // and reject it ourselves.\n      const receipt = override.extractReceipt(web3Error.message);\n      if (receipt) {\n        await handlers.receipt(context, receipt);\n        return;\n      }\n\n      //set up gas for getting reason -- we want it to be a lot, but not infinite\n      const defaultGas = utils.bigNumberify(Math.floor(context.blockLimit / 2)).toHexString();\n\n      // This will run if there's a reason and no status field\n      // e.g: revert with reason ganache --vmErrorsOnRPCResponse=true\n      const reason = await Reason.get({\n        ...context.params,\n        gas: defaultGas\n      },\n      //don't be gas-limited here!\n      constructor.web3, constructor.interfaceAdapter);\n      if (reason) {\n        web3Error.reason = reason;\n        web3Error.message += ` -- Reason given: ${reason}.`;\n      }\n      return context.promiEvent.reject(web3Error);\n    }\n\n    // This will run every block from now until contract.timeoutBlocks\n    const listener = function (pollID) {\n      currentBlock++;\n      if (currentBlock > constructor.timeoutBlocks) {\n        clearInterval(pollID);\n        return;\n      }\n      constructor.interfaceAdapter.getTransactionReceipt(context.transactionHash).then(result => {\n        if (!result) return;\n\n        // make sure reporter receives tx receipt promievent\n        handlers.receipt(context, result);\n        result.contractAddress ? constructor.at(result.contractAddress).then(context.promiEvent.resolve).catch(context.promiEvent.reject) : constructor.promiEvent.resolve(result);\n      }).catch(err => {\n        clearInterval(pollID);\n        context.promiEvent.reject(err);\n      });\n    };\n\n    // Start polling\n    let currentPollingBlock = await constructor.interfaceAdapter.getBlockNumber();\n    const pollID = setInterval(async () => {\n      const newBlock = await constructor.interfaceAdapter.getBlockNumber();\n      if (newBlock > currentPollingBlock) {\n        currentPollingBlock = newBlock;\n        listener(pollID);\n      }\n    }, override.pollingInterval);\n  }\n};\nmodule.exports = override;","map":{"version":3,"names":["Reason","require","handlers","utils","override","timeoutMessage","defaultWeb3Error","defaultMaxBlocks","pollingInterval","extractReceipt","message","hasReceipt","includes","receiptString","split","trim","JSON","parse","err","start","context","web3Error","constructor","currentBlock","ignoreTimeoutError","receipt","defaultGas","bigNumberify","Math","floor","blockLimit","toHexString","reason","get","params","gas","web3","interfaceAdapter","promiEvent","reject","listener","pollID","timeoutBlocks","clearInterval","getTransactionReceipt","transactionHash","then","result","contractAddress","at","resolve","catch","currentPollingBlock","getBlockNumber","setInterval","newBlock","module","exports"],"sources":["C:/Users/ankit/Desktop/FUND/funding/node_modules/@truffle/contract/lib/override.js"],"sourcesContent":["const Reason = require(\"./reason\");\nconst handlers = require(\"./handlers\");\nconst utils = require(\"./utils\");\n\nconst override = {\n  timeoutMessage: \"not mined within\", // Substring of timeout err fired by web3\n  defaultWeb3Error: \"please check your gas limit\", // Substring of default Web3 error\n  defaultMaxBlocks: 50, // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt(message) {\n    const hasReceipt = message && message.includes(\"{\");\n    message.includes(\"}\");\n\n    if (hasReceipt) {\n      const receiptString = \"{\" + message.split(\"{\")[1].trim();\n      try {\n        return JSON.parse(receiptString);\n      } catch (err) {\n        // ignore\n      }\n    }\n  },\n\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: async function (context, web3Error) {\n    const constructor = this;\n    let currentBlock = override.defaultMaxBlocks;\n\n    // Reject after attempting to get reason string if we shouldn't be waiting.\n    if (!handlers.ignoreTimeoutError(context, web3Error)) {\n      // We might have been routed here in web3 >= beta.34 by their own status check\n      // error. We want to extract the receipt, emit a receipt event\n      // and reject it ourselves.\n      const receipt = override.extractReceipt(web3Error.message);\n      if (receipt) {\n        await handlers.receipt(context, receipt);\n        return;\n      }\n\n      //set up gas for getting reason -- we want it to be a lot, but not infinite\n      const defaultGas = utils\n        .bigNumberify(Math.floor(context.blockLimit / 2))\n        .toHexString();\n\n      // This will run if there's a reason and no status field\n      // e.g: revert with reason ganache --vmErrorsOnRPCResponse=true\n      const reason = await Reason.get(\n        { ...context.params, gas: defaultGas }, //don't be gas-limited here!\n        constructor.web3,\n        constructor.interfaceAdapter\n      );\n      if (reason) {\n        web3Error.reason = reason;\n        web3Error.message += ` -- Reason given: ${reason}.`;\n      }\n\n      return context.promiEvent.reject(web3Error);\n    }\n\n    // This will run every block from now until contract.timeoutBlocks\n    const listener = function (pollID) {\n      currentBlock++;\n\n      if (currentBlock > constructor.timeoutBlocks) {\n        clearInterval(pollID);\n        return;\n      }\n\n      constructor.interfaceAdapter\n        .getTransactionReceipt(context.transactionHash)\n        .then(result => {\n          if (!result) return;\n\n          // make sure reporter receives tx receipt promievent\n          handlers.receipt(context, result);\n          result.contractAddress\n            ? constructor\n                .at(result.contractAddress)\n                .then(context.promiEvent.resolve)\n                .catch(context.promiEvent.reject)\n            : constructor.promiEvent.resolve(result);\n        })\n        .catch(err => {\n          clearInterval(pollID);\n          context.promiEvent.reject(err);\n        });\n    };\n\n    // Start polling\n    let currentPollingBlock =\n      await constructor.interfaceAdapter.getBlockNumber();\n\n    const pollID = setInterval(async () => {\n      const newBlock = await constructor.interfaceAdapter.getBlockNumber();\n\n      if (newBlock > currentPollingBlock) {\n        currentPollingBlock = newBlock;\n        listener(pollID);\n      }\n    }, override.pollingInterval);\n  }\n};\n\nmodule.exports = override;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}