{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeContext = exports.normalizeContexts = exports.matchContext = exports.findContext = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:contexts:utils\");\nconst Evm = __importStar(require(\"../evm\"));\nconst Conversion = __importStar(require(\"../conversion\"));\nconst escapeRegExp_1 = __importDefault(require(\"lodash/escapeRegExp\"));\nconst cbor = __importStar(require(\"cbor\"));\nconst compile_common_1 = require(\"@truffle/compile-common\");\nconst Abi = __importStar(require(\"@truffle/abi-utils\"));\nconst AbiDataUtils = __importStar(require(\"../abi-data/utils\"));\nfunction findContext(contexts, binary) {\n  const matchingContexts = Object.values(contexts).filter(context => matchContext(context, binary));\n  //rather than just pick an arbitrary matching context, we're going\n  //to pick one that isn't a descendant of any of the others.\n  //(if there are multiple of *those*, then yeah it's arbitrary.)\n  const context = matchingContexts.find(descendant => !matchingContexts.some(ancestor => descendant.compilationId === ancestor.compilationId && descendant.linearizedBaseContracts && ancestor.contractId !== undefined && descendant.linearizedBaseContracts.slice(1).includes(ancestor.contractId)\n  //we do slice one because everything is an an ancestor of itself; we only\n  //care about *proper* ancestors\n  ));\n\n  return context || null;\n}\nexports.findContext = findContext;\nfunction matchContext(context, givenBinary) {\n  const {\n    binary,\n    compiler,\n    isConstructor\n  } = context;\n  const lengthDifference = givenBinary.length - binary.length;\n  //first: if it's not a constructor, and it's not Vyper,\n  //they'd better be equal in length.\n  //if it is a constructor, or is Vyper,\n  //the given binary must be at least as long,\n  //and the difference must be a multiple of 32 bytes (64 hex digits)\n  const additionalAllowed = isConstructor || compiler != undefined && compiler.name === \"vyper\";\n  if (!additionalAllowed && lengthDifference !== 0 || lengthDifference < 0 || lengthDifference % (2 * Evm.Utils.WORD_SIZE) !== 0) {\n    return false;\n  }\n  for (let i = 0; i < binary.length; i++) {\n    //note: using strings like arrays is kind of dangerous in general in JS,\n    //but everything here is ASCII so it's fine\n    //note that we need to compare case-insensitive, since Solidity will\n    //put addresses in checksum case in the compiled source\n    //(we don't actually need that second toLowerCase(), but whatever)\n    if (binary[i] !== \".\" && binary[i].toLowerCase() !== givenBinary[i].toLowerCase()) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.matchContext = matchContext;\nfunction normalizeContexts(contexts) {\n  //unfortunately, due to our current link references format, we can't\n  //really use the binary from the artifact directly -- neither for purposes\n  //of matching, nor for purposes of decoding internal functions.  So, we\n  //need to perform this normalization step on our contexts before using\n  //them.  Once we have truffle-db, this step should largely go away.\n  debug(\"normalizing contexts\");\n  //first, let's clone the input\n  //(let's do a 2-deep clone because we'll be altering binary & compiler)\n  let newContexts = Object.assign({}, ...Object.entries(contexts).map(_ref => {\n    let [contextHash, context] = _ref;\n    return {\n      [contextHash]: Object.assign({}, context)\n    };\n  }));\n  debug(\"contexts cloned\");\n  //next, we get all the library names and sort them descending by length.\n  //We're going to want to go in descending order of length so that we\n  //don't run into problems when one name is a substring of another.\n  //For simplicity, we'll exclude names of length <38, because we can\n  //handle these with our more general check for link references at the end\n  const fillerLength = 2 * Evm.Utils.ADDRESS_SIZE;\n  let names = Object.values(newContexts).filter(context => context.contractKind === \"library\").map(context => context.contractName).filter(name => name.length >= fillerLength - 3)\n  //the -3 is for 2 leading underscores and 1 trailing\n  .sort((name1, name2) => name2.length - name1.length);\n  debug(\"names sorted\");\n  //now, we need to turn all these names into regular expressions, because,\n  //unfortunately, str.replace() will only replace all if you use a /g regexp;\n  //note that because names may contain '$', we need to escape them\n  //(also we prepend \"__\" because that's the placeholder format)\n  let regexps = names.map(name => new RegExp((0, escapeRegExp_1.default)(\"__\" + name), \"g\"));\n  debug(\"regexps prepared\");\n  //having done so, we can do the replace for these names!\n  const replacement = \".\".repeat(fillerLength);\n  for (let regexp of regexps) {\n    for (let context of Object.values(newContexts)) {\n      context.binary = context.binary.replace(regexp, replacement);\n    }\n  }\n  debug(\"long replacements complete\");\n  //now we can do a generic replace that will catch all names of length\n  //<40, while also catching the Solidity compiler's link reference format\n  //as well as Truffle's.  Hooray!\n  const genericRegexp = new RegExp(\"_.{\" + (fillerLength - 2) + \"}_\", \"g\");\n  //we're constructing the regexp /_.{38}_/g, but I didn't want to use a\n  //literal 38 :P\n  for (let context of Object.values(newContexts)) {\n    context.binary = context.binary.replace(genericRegexp, replacement);\n  }\n  debug(\"short replacements complete\");\n  //now we must handle the delegatecall guard -- libraries' deployedBytecode will include\n  //0s in place of their own address instead of a link reference at the\n  //beginning, so we need to account for that too\n  const pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n  for (let context of Object.values(newContexts)) {\n    if (context.contractKind === \"library\" && !context.isConstructor) {\n      context.binary = context.binary.replace(\"0x\" + pushAddressInstruction + \"00\".repeat(Evm.Utils.ADDRESS_SIZE), \"0x\" + pushAddressInstruction + replacement);\n    }\n  }\n  debug(\"extra library replacements complete\");\n  //now let's handle immutable references\n  //(these are much nicer than link references due to not having to deal with the old format)\n  for (let context of Object.values(newContexts)) {\n    if (context.immutableReferences) {\n      for (let variable of Object.values(context.immutableReferences)) {\n        for (let {\n          start,\n          length\n        } of variable) {\n          //Goddammit TS\n          let lowerStringIndex = 2 + 2 * start;\n          let upperStringIndex = 2 + 2 * (start + length);\n          context.binary = context.binary.slice(0, lowerStringIndex) + \"..\".repeat(length) + context.binary.slice(upperStringIndex);\n        }\n      }\n    }\n  }\n  debug(\"immutables complete\");\n  //now: extract & decode all the cbor's.  we're going to use these for\n  //two different purposes, so let's just get them all upfront.\n  let cborInfos = {};\n  let decodedCbors = {};\n  //note: invalid cbor will be indicated in decodedCbors by the lack of an entry,\n  //*not* by undefined or null, since there exists cbor for those :P\n  for (const [contextHash, context] of Object.entries(newContexts)) {\n    const cborInfo = extractCborInfo(context.binary);\n    cborInfos[contextHash] = cborInfo;\n    if (cborInfo) {\n      try {\n        //note this *will* throw if there's data left over,\n        //which is what we want it to do\n        const decoded = cbor.decodeFirstSync(cborInfo.cbor);\n        decodedCbors[contextHash] = decoded;\n      } catch (_a) {\n        //just don't add it\n      }\n    }\n  }\n  debug(\"intial cbor processing complete\");\n  //now: if a context lacks a compiler, but a version can be found in the\n  //cbor, add it.\n  for (let [contextHash, context] of Object.entries(newContexts)) {\n    if (!context.compiler && contextHash in decodedCbors) {\n      context.compiler = detectCompilerInfo(decodedCbors[contextHash]);\n    }\n  }\n  debug(\"versions complete\");\n  //one last step: where there's CBOR with a metadata hash, we'll allow the\n  //CBOR to vary, aside from the length (note: ideally here we would *only*\n  //dot-out the metadata hash part of the CBOR, but, well, it's not worth the\n  //trouble to detect that; doing that could potentially get pretty involved)\n  //note that if the code isn't Solidity, that's fine -- we just won't get\n  //valid CBOR and will not end up adding to our list of regular expressions\n  const externalCborInfos = Object.entries(cborInfos).filter(_ref2 => {\n    let [contextHash, _cborInfo] = _ref2;\n    return contextHash in decodedCbors && isObjectWithHash(decodedCbors[contextHash]);\n  }).map(_ref3 => {\n    let [_contextHash, cborInfo] = _ref3;\n    return cborInfo;\n  });\n  const cborRegexps = externalCborInfos.map(cborInfo => ({\n    input: new RegExp(cborInfo.cborSegment, \"g\"),\n    output: \"..\".repeat(cborInfo.cborLength) + cborInfo.cborLengthHex\n  }));\n  //HACK: we will replace *every* occurrence of *every* external CBOR occurring\n  //in *every* context, in order to cover created contracts (including if there\n  //are multiple or recursive ones)\n  for (let context of Object.values(newContexts)) {\n    for (let {\n      input,\n      output\n    } of cborRegexps) {\n      context.binary = context.binary.replace(input, output);\n    }\n  }\n  debug(\"external wildcards complete\");\n  //finally, return this mess!\n  return newContexts;\n}\nexports.normalizeContexts = normalizeContexts;\n//returns cbor info if cbor section is found, null if it is not.\n//note that it does not account for Vyper 0.3.4's idiosyncratic format\n//and so will return null on that.  but that's OK, because Vyper 0.3.4's\n//CBOR section is always fixed, so there isn't a need to normalize it here\nfunction extractCborInfo(binary) {\n  debug(\"extracting cbor segement of %s\", binary);\n  const lastTwoBytes = binary.slice(2).slice(-2 * 2); //2 bytes * 2 for hex\n  //the slice(2) there may seem unnecessary; it's to handle the possibility that the contract\n  //has less than two bytes in its bytecode (that won't happen with Solidity, but let's be\n  //certain)\n  if (lastTwoBytes.length < 2 * 2) {\n    return null; //don't try to handle this case!\n  }\n\n  const cborLength = parseInt(lastTwoBytes, 16);\n  const cborEnd = binary.length - 2 * 2;\n  const cborStart = cborEnd - cborLength * 2;\n  //sanity check\n  if (cborStart < 2) {\n    //\"0x\"\n    return null; //don't try to handle this case!\n  }\n\n  const cbor = binary.slice(cborStart, cborEnd);\n  return {\n    cborStart,\n    cborLength,\n    cborEnd,\n    cborLengthHex: lastTwoBytes,\n    cbor,\n    cborSegment: cbor + lastTwoBytes\n  };\n}\nfunction isObjectWithHash(decoded) {\n  if (typeof decoded !== \"object\" || decoded === null) {\n    return false;\n  }\n  //cbor sometimes returns maps and sometimes objects,\n  //so let's make things consistent by converting to a map\n  //(actually, is this true? borc did this, I think cbor\n  //does too, but I haven't checked recently)\n  if (!(decoded instanceof Map)) {\n    decoded = new Map(Object.entries(decoded));\n  }\n  const hashKeys = [\"bzzr0\", \"bzzr1\", \"ipfs\"];\n  return hashKeys.some(key => decoded.has(key));\n}\n//returns undefined if no valid compiler info detected\n//(if it detects solc but no version, it will not return\n//a partial result, just undefined)\nfunction detectCompilerInfo(decoded) {\n  if (typeof decoded !== \"object\" || decoded === null) {\n    return undefined;\n  }\n  //cbor sometimes returns maps and sometimes objects,\n  //so let's make things consistent by converting to a map\n  //(although see note above?)\n  if (!(decoded instanceof Map)) {\n    decoded = new Map(Object.entries(decoded));\n  }\n  if (!decoded.has(\"solc\")) {\n    //return undefined if the solc version field is not present\n    //(this occurs if version <0.5.9)\n    //currently no other language attaches cbor info, so, yeah\n    return undefined;\n  }\n  const rawVersion = decoded.get(\"solc\");\n  if (typeof rawVersion === \"string\") {\n    //for prerelease versions, the version is stored as a string.\n    return {\n      name: \"solc\",\n      version: rawVersion\n    };\n  } else if (rawVersion instanceof Uint8Array && rawVersion.length === 3) {\n    //for release versions, it's stored as a bytestring of length 3, with the\n    //bytes being major, minor, patch. so we just join them with \".\" to form\n    //a version string (although it's missing precise commit & etc).\n    return {\n      name: \"solc\",\n      version: rawVersion.join(\".\")\n    };\n  } else {\n    //return undefined on anything else\n    return undefined;\n  }\n}\nfunction makeContext(contract, node, compilation) {\n  let isConstructor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const abi = Abi.normalize(contract.abi);\n  const bytecode = isConstructor ? contract.bytecode : contract.deployedBytecode;\n  const binary = compile_common_1.Shims.NewToLegacy.forBytecode(bytecode);\n  const hash = Conversion.toHexString(Evm.Utils.keccak256({\n    type: \"string\",\n    value: binary\n  }));\n  debug(\"hash: %s\", hash);\n  const fallback = abi.find(abiEntry => abiEntry.type === \"fallback\") || null; //TS is failing at inference here\n  const receive = abi.find(abiEntry => abiEntry.type === \"receive\") || null; //and here\n  return {\n    context: hash,\n    contractName: contract.contractName,\n    binary,\n    contractId: node ? node.id : undefined,\n    linearizedBaseContracts: node ? node.linearizedBaseContracts : undefined,\n    contractKind: contractKind(contract, node),\n    immutableReferences: isConstructor ? undefined : contract.immutableReferences,\n    isConstructor,\n    abi: AbiDataUtils.computeSelectors(abi),\n    payable: AbiDataUtils.abiHasPayableFallback(abi),\n    fallbackAbi: {\n      fallback,\n      receive\n    },\n    compiler: compilation.compiler || contract.compiler,\n    compilationId: compilation.id\n  };\n}\nexports.makeContext = makeContext;\n//attempts to determine if the given contract is a library or not\nfunction contractKind(contract, node) {\n  //first: if we have a node, use its listed contract kind\n  if (node) {\n    return node.contractKind;\n  }\n  //next: check the contract kind field on the contract object itself, if it exists.\n  //however this isn't implemented yet so we'll skip it.\n  //next: if we have no direct info on the contract kind, but we do\n  //have the deployed bytecode, we'll use a HACK:\n  //we'll assume it's an ordinary contract, UNLESS its deployed bytecode begins with\n  //PUSH20 followed by 20 0s, in which case we'll assume it's a library\n  //(note: this will fail to detect libraries from before Solidity 0.4.20)\n  if (contract.deployedBytecode) {\n    const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode);\n    const pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n    const libraryString = \"0x\" + pushAddressInstruction + \"00\".repeat(Evm.Utils.ADDRESS_SIZE);\n    return deployedBytecode.startsWith(libraryString) ? \"library\" : \"contract\";\n  }\n  //finally, in the absence of anything to go on, we'll assume it's an ordinary contract\n  return \"contract\";\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA,MAAMA,KAAK,GAAG,mBAAW,EAAC,sBAAsB,CAAC;AAEjD;AAGA;AAGA;AACA;AACA;AACA;AAEA;AAEA,SAAgBC,WAAW,CACzBC,QAAkB,EAClBC,MAAc;EAEd,MAAMC,gBAAgB,GAAGC,MAAM,CAACC,MAAM,CAACJ,QAAQ,CAAC,CAACK,MAAM,CAACC,OAAO,IAC7DC,YAAY,CAACD,OAAO,EAAEL,MAAM,CAAC,CAC9B;EACD;EACA;EACA;EACA,MAAMK,OAAO,GAAGJ,gBAAgB,CAACM,IAAI,CACnCC,UAAU,IACR,CAACP,gBAAgB,CAACQ,IAAI,CACpBC,QAAQ,IACNF,UAAU,CAACG,aAAa,KAAKD,QAAQ,CAACC,aAAa,IACnDH,UAAU,CAACI,uBAAuB,IAClCF,QAAQ,CAACG,UAAU,KAAKC,SAAS,IACjCN,UAAU,CAACI,uBAAuB,CAC/BG,KAAK,CAAC,CAAC,CAAC,CACRC,QAAQ,CAACN,QAAQ,CAACG,UAAU;EACjC;EACA;EAAA,CACD,CACJ;;EACD,OAAOR,OAAO,IAAI,IAAI;AACxB;AAzBAY;AA2BA,SAAgBX,YAAY,CAACD,OAAgB,EAAEa,WAAmB;EAChE,MAAM;IAAElB,MAAM;IAAEmB,QAAQ;IAAEC;EAAa,CAAE,GAAGf,OAAO;EACnD,MAAMgB,gBAAgB,GAAGH,WAAW,CAACI,MAAM,GAAGtB,MAAM,CAACsB,MAAM;EAC3D;EACA;EACA;EACA;EACA;EACA,MAAMC,iBAAiB,GACrBH,aAAa,IAAKD,QAAQ,IAAIL,SAAS,IAAIK,QAAQ,CAACK,IAAI,KAAK,OAAQ;EACvE,IACG,CAACD,iBAAiB,IAAIF,gBAAgB,KAAK,CAAC,IAC7CA,gBAAgB,GAAG,CAAC,IACpBA,gBAAgB,IAAI,CAAC,GAAGI,GAAG,CAACC,KAAK,CAACC,SAAS,CAAC,KAAK,CAAC,EAClD;IACA,OAAO,KAAK;;EAEd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5B,MAAM,CAACsB,MAAM,EAAEM,CAAC,EAAE,EAAE;IACtC;IACA;IACA;IACA;IACA;IACA,IACE5B,MAAM,CAAC4B,CAAC,CAAC,KAAK,GAAG,IACjB5B,MAAM,CAAC4B,CAAC,CAAC,CAACC,WAAW,EAAE,KAAKX,WAAW,CAACU,CAAC,CAAC,CAACC,WAAW,EAAE,EACxD;MACA,OAAO,KAAK;;;EAGhB,OAAO,IAAI;AACb;AA/BAZ;AAiCA,SAAgBa,iBAAiB,CAAC/B,QAAkB;EAClD;EACA;EACA;EACA;EACA;EAEAF,KAAK,CAAC,sBAAsB,CAAC;EAE7B;EACA;EACA,IAAIkC,WAAW,GAAa7B,MAAM,CAAC8B,MAAM,CACvC,EAAE,EACF,GAAG9B,MAAM,CAAC+B,OAAO,CAAClC,QAAQ,CAAC,CAACmC,GAAG,CAAC;IAAA,IAAC,CAACC,WAAW,EAAE9B,OAAO,CAAC;IAAA,OAAM;MAC3D,CAAC8B,WAAW,GAACjC,kBAAOG,OAAO;KAC5B;EAAA,CAAC,CAAC,CACJ;EAEDR,KAAK,CAAC,iBAAiB,CAAC;EAExB;EACA;EACA;EACA;EACA;EACA,MAAMuC,YAAY,GAAG,CAAC,GAAGX,GAAG,CAACC,KAAK,CAACW,YAAY;EAC/C,IAAIC,KAAK,GAAGpC,MAAM,CAACC,MAAM,CAAC4B,WAAW,CAAC,CACnC3B,MAAM,CAACC,OAAO,IAAIA,OAAO,CAACkC,YAAY,KAAK,SAAS,CAAC,CACrDL,GAAG,CAAC7B,OAAO,IAAIA,OAAO,CAACmC,YAAY,CAAC,CACpCpC,MAAM,CAACoB,IAAI,IAAIA,IAAI,CAACF,MAAM,IAAIc,YAAY,GAAG,CAAC;EAC/C;EAAA,CACCK,IAAI,CAAC,CAACC,KAAK,EAAEC,KAAK,KAAKA,KAAK,CAACrB,MAAM,GAAGoB,KAAK,CAACpB,MAAM,CAAC;EAEtDzB,KAAK,CAAC,cAAc,CAAC;EAErB;EACA;EACA;EACA;EACA,IAAI+C,OAAO,GAAGN,KAAK,CAACJ,GAAG,CAACV,IAAI,IAAI,IAAIqB,MAAM,CAAC,0BAAY,EAAC,IAAI,GAAGrB,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;EAE3E3B,KAAK,CAAC,kBAAkB,CAAC;EAEzB;EACA,MAAMiD,WAAW,GAAG,GAAG,CAACC,MAAM,CAACX,YAAY,CAAC;EAC5C,KAAK,IAAIY,MAAM,IAAIJ,OAAO,EAAE;IAC1B,KAAK,IAAIvC,OAAO,IAAIH,MAAM,CAACC,MAAM,CAAC4B,WAAW,CAAC,EAAE;MAC9C1B,OAAO,CAACL,MAAM,GAAGK,OAAO,CAACL,MAAM,CAACiD,OAAO,CAACD,MAAM,EAAEF,WAAW,CAAC;;;EAIhEjD,KAAK,CAAC,4BAA4B,CAAC;EAEnC;EACA;EACA;EACA,MAAMqD,aAAa,GAAG,IAAIL,MAAM,CAAC,KAAK,IAAIT,YAAY,GAAG,CAAC,CAAC,GAAG,IAAI,EAAE,GAAG,CAAC;EACxE;EACA;EACA,KAAK,IAAI/B,OAAO,IAAIH,MAAM,CAACC,MAAM,CAAC4B,WAAW,CAAC,EAAE;IAC9C1B,OAAO,CAACL,MAAM,GAAGK,OAAO,CAACL,MAAM,CAACiD,OAAO,CAACC,aAAa,EAAEJ,WAAW,CAAC;;EAGrEjD,KAAK,CAAC,6BAA6B,CAAC;EACpC;EACA;EACA;EACA,MAAMsD,sBAAsB,GAAG,CAAC,IAAI,GAAG1B,GAAG,CAACC,KAAK,CAACW,YAAY,GAAG,CAAC,EAAEe,QAAQ,CACzE,EAAE,CACH,CAAC,CAAC;EACH,KAAK,IAAI/C,OAAO,IAAIH,MAAM,CAACC,MAAM,CAAC4B,WAAW,CAAC,EAAE;IAC9C,IAAI1B,OAAO,CAACkC,YAAY,KAAK,SAAS,IAAI,CAAClC,OAAO,CAACe,aAAa,EAAE;MAChEf,OAAO,CAACL,MAAM,GAAGK,OAAO,CAACL,MAAM,CAACiD,OAAO,CACrC,IAAI,GAAGE,sBAAsB,GAAG,IAAI,CAACJ,MAAM,CAACtB,GAAG,CAACC,KAAK,CAACW,YAAY,CAAC,EACnE,IAAI,GAAGc,sBAAsB,GAAGL,WAAW,CAC5C;;;EAILjD,KAAK,CAAC,qCAAqC,CAAC;EAE5C;EACA;EACA,KAAK,IAAIQ,OAAO,IAAIH,MAAM,CAACC,MAAM,CAAC4B,WAAW,CAAC,EAAE;IAC9C,IAAI1B,OAAO,CAACgD,mBAAmB,EAAE;MAC/B,KAAK,IAAIC,QAAQ,IAAIpD,MAAM,CAACC,MAAM,CAACE,OAAO,CAACgD,mBAAmB,CAAC,EAAE;QAC/D,KAAK,IAAI;UAAEE,KAAK;UAAEjC;QAAM,CAAE,IACxBgC,QAAQ,EACP;UACD;UACA,IAAIE,gBAAgB,GAAG,CAAC,GAAG,CAAC,GAAGD,KAAK;UACpC,IAAIE,gBAAgB,GAAG,CAAC,GAAG,CAAC,IAAIF,KAAK,GAAGjC,MAAM,CAAC;UAC/CjB,OAAO,CAACL,MAAM,GACZK,OAAO,CAACL,MAAM,CAACe,KAAK,CAAC,CAAC,EAAEyC,gBAAgB,CAAC,GACzC,IAAI,CAACT,MAAM,CAACzB,MAAM,CAAC,GACnBjB,OAAO,CAACL,MAAM,CAACe,KAAK,CAAC0C,gBAAgB,CAAC;;;;;EAMhD5D,KAAK,CAAC,qBAAqB,CAAC;EAE5B;EACA;EACA,IAAI6D,SAAS,GAAwC,EAAE;EACvD,IAAIC,YAAY,GAAmC,EAAE;EACrD;EACA;EAEA,KAAK,MAAM,CAACxB,WAAW,EAAE9B,OAAO,CAAC,IAAIH,MAAM,CAAC+B,OAAO,CAACF,WAAW,CAAC,EAAE;IAChE,MAAM6B,QAAQ,GAAGC,eAAe,CAACxD,OAAO,CAACL,MAAM,CAAC;IAChD0D,SAAS,CAACvB,WAAW,CAAC,GAAGyB,QAAQ;IACjC,IAAIA,QAAQ,EAAE;MACZ,IAAI;QACF;QACA;QACA,MAAME,OAAO,GAAQC,IAAI,CAACC,eAAe,CAACJ,QAAQ,CAACG,IAAI,CAAC;QACxDJ,YAAY,CAACxB,WAAW,CAAC,GAAG2B,OAAO;OACpC,CAAC,WAAM;QACN;MAAA;;;EAKNjE,KAAK,CAAC,iCAAiC,CAAC;EAExC;EACA;EACA,KAAK,IAAI,CAACsC,WAAW,EAAE9B,OAAO,CAAC,IAAIH,MAAM,CAAC+B,OAAO,CAACF,WAAW,CAAC,EAAE;IAC9D,IAAI,CAAC1B,OAAO,CAACc,QAAQ,IAAIgB,WAAW,IAAIwB,YAAY,EAAE;MACpDtD,OAAO,CAACc,QAAQ,GAAG8C,kBAAkB,CAACN,YAAY,CAACxB,WAAW,CAAC,CAAC;;;EAIpEtC,KAAK,CAAC,mBAAmB,CAAC;EAE1B;EACA;EACA;EACA;EACA;EACA;EACA,MAAMqE,iBAAiB,GAAGhE,MAAM,CAAC+B,OAAO,CAACyB,SAAS,CAAC,CAChDtD,MAAM,CACL;IAAA,IAAC,CAAC+B,WAAW,EAAEgC,SAAS,CAAC;IAAA,OACvBhC,WAAW,IAAIwB,YAAY,IAC3BS,gBAAgB,CAACT,YAAY,CAACxB,WAAW,CAAC,CAAC;EAAA,EAC9C,CACAD,GAAG,CAAC;IAAA,IAAC,CAACmC,YAAY,EAAET,QAAQ,CAAC;IAAA,OAAKA,QAAQ;EAAA,EAAC;EAC9C,MAAMU,WAAW,GAAGJ,iBAAiB,CAAChC,GAAG,CAAC0B,QAAQ,KAAK;IACrDW,KAAK,EAAE,IAAI1B,MAAM,CAACe,QAAQ,CAACY,WAAW,EAAE,GAAG,CAAC;IAC5CC,MAAM,EAAE,IAAI,CAAC1B,MAAM,CAACa,QAAQ,CAACc,UAAU,CAAC,GAAGd,QAAQ,CAACe;GACrD,CAAC,CAAC;EACH;EACA;EACA;EACA,KAAK,IAAItE,OAAO,IAAIH,MAAM,CAACC,MAAM,CAAC4B,WAAW,CAAC,EAAE;IAC9C,KAAK,IAAI;MAAEwC,KAAK;MAAEE;IAAM,CAAE,IAAIH,WAAW,EAAE;MACzCjE,OAAO,CAACL,MAAM,GAAGK,OAAO,CAACL,MAAM,CAACiD,OAAO,CAACsB,KAAK,EAAEE,MAAM,CAAC;;;EAI1D5E,KAAK,CAAC,6BAA6B,CAAC;EAEpC;EACA,OAAOkC,WAAW;AACpB;AAvKAd;AAkLA;AACA;AACA;AACA;AACA,SAAS4C,eAAe,CAAC7D,MAAc;EACrCH,KAAK,CAAC,gCAAgC,EAAEG,MAAM,CAAC;EAC/C,MAAM4E,YAAY,GAAG5E,MAAM,CAACe,KAAK,CAAC,CAAC,CAAC,CAACA,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EACpD;EACA;EACA;EACA,IAAI6D,YAAY,CAACtD,MAAM,GAAG,CAAC,GAAG,CAAC,EAAE;IAC/B,OAAO,IAAI,CAAC,CAAC;;;EAEf,MAAMoD,UAAU,GAAWG,QAAQ,CAACD,YAAY,EAAE,EAAE,CAAC;EACrD,MAAME,OAAO,GAAG9E,MAAM,CAACsB,MAAM,GAAG,CAAC,GAAG,CAAC;EACrC,MAAMyD,SAAS,GAAGD,OAAO,GAAGJ,UAAU,GAAG,CAAC;EAC1C;EACA,IAAIK,SAAS,GAAG,CAAC,EAAE;IACjB;IACA,OAAO,IAAI,CAAC,CAAC;;;EAEf,MAAMhB,IAAI,GAAG/D,MAAM,CAACe,KAAK,CAACgE,SAAS,EAAED,OAAO,CAAC;EAC7C,OAAO;IACLC,SAAS;IACTL,UAAU;IACVI,OAAO;IACPH,aAAa,EAAEC,YAAY;IAC3Bb,IAAI;IACJS,WAAW,EAAET,IAAI,GAAGa;GACrB;AACH;AAEA,SAASR,gBAAgB,CAACN,OAAY;EACpC,IAAI,OAAOA,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,IAAI,EAAE;IACnD,OAAO,KAAK;;EAEd;EACA;EACA;EACA;EACA,IAAI,EAAEA,OAAO,YAAYkB,GAAG,CAAC,EAAE;IAC7BlB,OAAO,GAAG,IAAIkB,GAAG,CAAC9E,MAAM,CAAC+B,OAAO,CAAC6B,OAAO,CAAC,CAAC;;EAE5C,MAAMmB,QAAQ,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,CAAC;EAC3C,OAAOA,QAAQ,CAACxE,IAAI,CAACyE,GAAG,IAAIpB,OAAO,CAACqB,GAAG,CAACD,GAAG,CAAC,CAAC;AAC/C;AAEA;AACA;AACA;AACA,SAASjB,kBAAkB,CAACH,OAAY;EACtC,IAAI,OAAOA,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,IAAI,EAAE;IACnD,OAAOhD,SAAS;;EAElB;EACA;EACA;EACA,IAAI,EAAEgD,OAAO,YAAYkB,GAAG,CAAC,EAAE;IAC7BlB,OAAO,GAAG,IAAIkB,GAAG,CAAC9E,MAAM,CAAC+B,OAAO,CAAC6B,OAAO,CAAC,CAAC;;EAE5C,IAAI,CAACA,OAAO,CAACqB,GAAG,CAAC,MAAM,CAAC,EAAE;IACxB;IACA;IACA;IACA,OAAOrE,SAAS;;EAElB,MAAMsE,UAAU,GAAGtB,OAAO,CAACuB,GAAG,CAAC,MAAM,CAAC;EACtC,IAAI,OAAOD,UAAU,KAAK,QAAQ,EAAE;IAClC;IACA,OAAO;MACL5D,IAAI,EAAE,MAAM;MACZ8D,OAAO,EAAEF;KACV;GACF,MAAM,IAAIA,UAAU,YAAYG,UAAU,IAAIH,UAAU,CAAC9D,MAAM,KAAK,CAAC,EAAE;IACtE;IACA;IACA;IACA,OAAO;MACLE,IAAI,EAAE,MAAM;MACZ8D,OAAO,EAAEF,UAAU,CAACI,IAAI,CAAC,GAAG;KAC7B;GACF,MAAM;IACL;IACA,OAAO1E,SAAS;;AAEpB;AAEA,SAAgB2E,WAAW,CACzBC,QAA+B,EAC/BC,IAA6B,EAC7BC,WAAqC,EAChB;EAAA,IAArBxE,aAAa,uEAAG,KAAK;EAErB,MAAMyE,GAAG,GAAGC,GAAG,CAACC,SAAS,CAACL,QAAQ,CAACG,GAAG,CAAC;EACvC,MAAMG,QAAQ,GAAG5E,aAAa,GAC1BsE,QAAQ,CAACM,QAAQ,GACjBN,QAAQ,CAACO,gBAAgB;EAC7B,MAAMjG,MAAM,GAAWkG,sBAAK,CAACC,WAAW,CAACC,WAAW,CAACJ,QAAQ,CAAC;EAC9D,MAAMK,IAAI,GAAGC,UAAU,CAACC,WAAW,CACjC9E,GAAG,CAACC,KAAK,CAAC8E,SAAS,CAAC;IAClBC,IAAI,EAAE,QAAQ;IACdC,KAAK,EAAE1G;GACR,CAAC,CACH;EACDH,KAAK,CAAC,UAAU,EAAEwG,IAAI,CAAC;EACvB,MAAMM,QAAQ,GACOd,GAAG,CAACtF,IAAI,CAACqG,QAAQ,IAAIA,QAAQ,CAACH,IAAI,KAAK,UAAU,CAAC,IACrE,IAAI,CAAC,CAAC;EACR,MAAMI,OAAO,GACOhB,GAAG,CAACtF,IAAI,CAACqG,QAAQ,IAAIA,QAAQ,CAACH,IAAI,KAAK,SAAS,CAAC,IAAI,IAAI,CAAC,CAAC;EAC/E,OAAO;IACLpG,OAAO,EAAEgG,IAAI;IACb7D,YAAY,EAAEkD,QAAQ,CAAClD,YAAY;IACnCxC,MAAM;IACNa,UAAU,EAAE8E,IAAI,GAAGA,IAAI,CAACmB,EAAE,GAAGhG,SAAS;IACtCF,uBAAuB,EAAE+E,IAAI,GAAGA,IAAI,CAAC/E,uBAAuB,GAAGE,SAAS;IACxEyB,YAAY,EAAEA,YAAY,CAACmD,QAAQ,EAAEC,IAAI,CAAC;IAC1CtC,mBAAmB,EAAEjC,aAAa,GAC9BN,SAAS,GACT4E,QAAQ,CAACrC,mBAAmB;IAChCjC,aAAa;IACbyE,GAAG,EAAEkB,YAAY,CAACC,gBAAgB,CAACnB,GAAG,CAAC;IACvCoB,OAAO,EAAEF,YAAY,CAACG,qBAAqB,CAACrB,GAAG,CAAC;IAChDsB,WAAW,EAAE;MAAER,QAAQ;MAAEE;IAAO,CAAE;IAClC1F,QAAQ,EAAEyE,WAAW,CAACzE,QAAQ,IAAIuE,QAAQ,CAACvE,QAAQ;IACnDR,aAAa,EAAEiF,WAAW,CAACkB;GAC5B;AACH;AAxCA7F;AA0CA;AACA,SAASsB,YAAY,CACnBmD,QAA+B,EAC/BC,IAAkB;EAElB;EACA,IAAIA,IAAI,EAAE;IACR,OAAOA,IAAI,CAACpD,YAAY;;EAE1B;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAImD,QAAQ,CAACO,gBAAgB,EAAE;IAC7B,MAAMA,gBAAgB,GAAGC,sBAAK,CAACC,WAAW,CAACC,WAAW,CACpDV,QAAQ,CAACO,gBAAgB,CAC1B;IACD,MAAM9C,sBAAsB,GAAG,CAAC,IAAI,GAAG1B,GAAG,CAACC,KAAK,CAACW,YAAY,GAAG,CAAC,EAAEe,QAAQ,CACzE,EAAE,CACH,CAAC,CAAC;IACH,MAAMgE,aAAa,GACjB,IAAI,GAAGjE,sBAAsB,GAAG,IAAI,CAACJ,MAAM,CAACtB,GAAG,CAACC,KAAK,CAACW,YAAY,CAAC;IACrE,OAAO4D,gBAAgB,CAACoB,UAAU,CAACD,aAAa,CAAC,GAAG,SAAS,GAAG,UAAU;;EAE5E;EACA,OAAO,UAAU;AACnB","names":["debug","findContext","contexts","binary","matchingContexts","Object","values","filter","context","matchContext","find","descendant","some","ancestor","compilationId","linearizedBaseContracts","contractId","undefined","slice","includes","exports","givenBinary","compiler","isConstructor","lengthDifference","length","additionalAllowed","name","Evm","Utils","WORD_SIZE","i","toLowerCase","normalizeContexts","newContexts","assign","entries","map","contextHash","fillerLength","ADDRESS_SIZE","names","contractKind","contractName","sort","name1","name2","regexps","RegExp","replacement","repeat","regexp","replace","genericRegexp","pushAddressInstruction","toString","immutableReferences","variable","start","lowerStringIndex","upperStringIndex","cborInfos","decodedCbors","cborInfo","extractCborInfo","decoded","cbor","decodeFirstSync","detectCompilerInfo","externalCborInfos","_cborInfo","isObjectWithHash","_contextHash","cborRegexps","input","cborSegment","output","cborLength","cborLengthHex","lastTwoBytes","parseInt","cborEnd","cborStart","Map","hashKeys","key","has","rawVersion","get","version","Uint8Array","join","makeContext","contract","node","compilation","abi","Abi","normalize","bytecode","deployedBytecode","compile_common_1","NewToLegacy","forBytecode","hash","Conversion","toHexString","keccak256","type","value","fallback","abiEntry","receive","id","AbiDataUtils","computeSelectors","payable","abiHasPayableFallback","fallbackAbi","libraryString","startsWith"],"sourceRoot":"","sources":["../../../lib/contexts/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}