{"ast":null,"code":"const DebugUtils = require(\"@truffle/debug-utils\");\n\n/**\n * Methods to fetch and decode reason string from ganache when a tx errors.\n */\n\nconst reason = {\n  /**\n   * Extracts a reason string from `eth_call` response\n   * @param  {Object}           res  response from `eth_call` to extract reason\n   * @param  {Web3}             web3 a helpful friend\n   * @param  {InterfaceAdapter}      interfaceAdapter a new helpful friend\n   * @return {String|Undefined}      decoded reason string\n   */\n  _extract: function (res, web3, _interfaceAdapter) {\n    //I'm not sure why interfaceAdapter is here if it's not used,\n    //so I just put an underscore in front of its name for now...\n    if (!res || !res.error && !res.result) return;\n    const isObject = res && typeof res === \"object\" && res.error && res.error.data;\n    const isString = res && typeof res === \"object\" && typeof res.result === \"string\";\n    if (isObject) {\n      // NOTE that Ganache >=2 returns the reason string when\n      // vmErrorsOnRPCResponse === true, which this code could\n      // be updated to respect (instead of computing here)\n      const data = res.error.data;\n      let resData;\n      if (typeof data === \"string\") {\n        resData = data; // geth, Ganache >7.0.0\n      } else if (\"result\" in data) {\n        // there is a single result (Ganache 7.0.0)\n        resData = data.result;\n      } else {\n        // handle `evm_mine`, `miner_start`, batch payloads, and ganache 2.0\n        // NOTE this only works for a single failed transaction at a time.\n        const hash = Object.keys(data)[0];\n        const errorDetails = data[hash];\n        resData = errorDetails.return /* ganache 2.0 */;\n      }\n\n      return reason._decode(resData, web3);\n    } else if (isString) {\n      return reason._decode(res.result, web3);\n    } else {\n      return undefined;\n    }\n  },\n  _decode: function (rawData, web3) {\n    const errorStringHash = \"0x08c379a0\";\n    const panicCodeHash = \"0x4e487b71\";\n    const selectorLength = 2 + 2 * 4; //0x then 4 bytes (0x then 8 hex digits)\n    const wordLength = 2 * 32; //32 bytes (64 hex digits)\n    if (!rawData) {\n      return undefined;\n    } else if (rawData === \"0x\") {\n      //no revert message\n      return undefined;\n    } else if (rawData.startsWith(errorStringHash)) {\n      try {\n        return web3.eth.abi.decodeParameter(\"string\", rawData.slice(selectorLength));\n      } catch (_) {\n        //no reasonable way to handle this case at present\n        return undefined;\n      }\n    } else if (rawData.startsWith(panicCodeHash)) {\n      if (rawData.length === selectorLength + wordLength) {\n        const panicCode = web3.eth.abi.decodeParameter(\"uint256\", rawData.slice(selectorLength)); //this returns a decimal string\n        return `Panic: ${DebugUtils.panicString(panicCode)}`;\n      } else {\n        //incorrectly encoded panic...?\n        return undefined;\n      }\n    } else {\n      //we can't reasonably handle custom errors here\n      //(but we can probably assume it is one?)\n      return \"Custom error (could not decode)\";\n    }\n  },\n  /**\n   * Runs tx via `eth_call` and resolves a reason string if it exists on the response.\n   * @param  {Object} web3\n   * @param  {Object} interfaceAdapter\n   * @return {String|Undefined}\n   */\n  get: function (params, web3, interfaceAdapter) {\n    const packet = {\n      jsonrpc: \"2.0\",\n      method: \"eth_call\",\n      params: [params, \"latest\"],\n      id: new Date().getTime()\n    };\n    return new Promise(resolve => {\n      web3.currentProvider.send(packet, (err, response) => {\n        const reasonString = reason._extract(response, web3, interfaceAdapter);\n        resolve(reasonString);\n      });\n    });\n  }\n};\nmodule.exports = reason;","map":{"version":3,"names":["DebugUtils","require","reason","_extract","res","web3","_interfaceAdapter","error","result","isObject","data","isString","resData","hash","Object","keys","errorDetails","return","_decode","undefined","rawData","errorStringHash","panicCodeHash","selectorLength","wordLength","startsWith","eth","abi","decodeParameter","slice","_","length","panicCode","panicString","get","params","interfaceAdapter","packet","jsonrpc","method","id","Date","getTime","Promise","resolve","currentProvider","send","err","response","reasonString","module","exports"],"sources":["C:/Users/ankit/Desktop/FUND/funding/node_modules/@truffle/contract/lib/reason.js"],"sourcesContent":["const DebugUtils = require(\"@truffle/debug-utils\");\n\n/**\n * Methods to fetch and decode reason string from ganache when a tx errors.\n */\n\nconst reason = {\n  /**\n   * Extracts a reason string from `eth_call` response\n   * @param  {Object}           res  response from `eth_call` to extract reason\n   * @param  {Web3}             web3 a helpful friend\n   * @param  {InterfaceAdapter}      interfaceAdapter a new helpful friend\n   * @return {String|Undefined}      decoded reason string\n   */\n  _extract: function (res, web3, _interfaceAdapter) {\n    //I'm not sure why interfaceAdapter is here if it's not used,\n    //so I just put an underscore in front of its name for now...\n    if (!res || (!res.error && !res.result)) return;\n\n    const isObject =\n      res && typeof res === \"object\" && res.error && res.error.data;\n    const isString =\n      res && typeof res === \"object\" && typeof res.result === \"string\";\n\n    if (isObject) {\n      // NOTE that Ganache >=2 returns the reason string when\n      // vmErrorsOnRPCResponse === true, which this code could\n      // be updated to respect (instead of computing here)\n      const data = res.error.data;\n      let resData;\n      if (typeof data === \"string\") {\n        resData = data; // geth, Ganache >7.0.0\n      } else if (\"result\" in data) {\n        // there is a single result (Ganache 7.0.0)\n        resData = data.result;\n      } else {\n        // handle `evm_mine`, `miner_start`, batch payloads, and ganache 2.0\n        // NOTE this only works for a single failed transaction at a time.\n        const hash = Object.keys(data)[0];\n        const errorDetails = data[hash];\n        resData = errorDetails.return /* ganache 2.0 */;\n      }\n\n      return reason._decode(resData, web3);\n    } else if (isString) {\n      return reason._decode(res.result, web3);\n    } else {\n      return undefined;\n    }\n  },\n\n  _decode: function (rawData, web3) {\n    const errorStringHash = \"0x08c379a0\";\n    const panicCodeHash = \"0x4e487b71\";\n    const selectorLength = 2 + 2 * 4; //0x then 4 bytes (0x then 8 hex digits)\n    const wordLength = 2 * 32; //32 bytes (64 hex digits)\n    if (!rawData) {\n      return undefined;\n    } else if (rawData === \"0x\") {\n      //no revert message\n      return undefined;\n    } else if (rawData.startsWith(errorStringHash)) {\n      try {\n        return web3.eth.abi.decodeParameter(\n          \"string\",\n          rawData.slice(selectorLength)\n        );\n      } catch (_) {\n        //no reasonable way to handle this case at present\n        return undefined;\n      }\n    } else if (rawData.startsWith(panicCodeHash)) {\n      if (rawData.length === selectorLength + wordLength) {\n        const panicCode = web3.eth.abi.decodeParameter(\n          \"uint256\",\n          rawData.slice(selectorLength)\n        ); //this returns a decimal string\n        return `Panic: ${DebugUtils.panicString(panicCode)}`;\n      } else {\n        //incorrectly encoded panic...?\n        return undefined;\n      }\n    } else {\n      //we can't reasonably handle custom errors here\n      //(but we can probably assume it is one?)\n      return \"Custom error (could not decode)\";\n    }\n  },\n\n  /**\n   * Runs tx via `eth_call` and resolves a reason string if it exists on the response.\n   * @param  {Object} web3\n   * @param  {Object} interfaceAdapter\n   * @return {String|Undefined}\n   */\n  get: function (params, web3, interfaceAdapter) {\n    const packet = {\n      jsonrpc: \"2.0\",\n      method: \"eth_call\",\n      params: [params, \"latest\"],\n      id: new Date().getTime()\n    };\n\n    return new Promise(resolve => {\n      web3.currentProvider.send(packet, (err, response) => {\n        const reasonString = reason._extract(response, web3, interfaceAdapter);\n        resolve(reasonString);\n      });\n    });\n  }\n};\n\nmodule.exports = reason;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}