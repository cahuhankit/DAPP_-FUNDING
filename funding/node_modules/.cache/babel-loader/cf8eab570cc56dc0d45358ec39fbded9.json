{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPaddingLeft = exports.decodeExternalFunction = exports.decodeContract = exports.decodeBasic = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:basic:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Contexts = __importStar(require(\"../../contexts\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nconst allocate_1 = require(\"../allocate\");\nfunction decodeBasic(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    const {\n      state\n    } = info;\n    const {\n      strictAbiMode: strict\n    } = options; //if this is undefined it'll still be falsy so it's OK\n    const paddingMode = options.paddingMode || \"default\";\n    let bytes;\n    let rawBytes;\n    try {\n      bytes = yield* (0, read_1.default)(pointer, state);\n    } catch (error) {\n      debug(\"segfault, pointer %o, state: %O\", pointer, state);\n      return (0, errors_1.handleDecodingError)(dataType, error, strict);\n    }\n    rawBytes = bytes;\n    debug(\"type %O\", dataType);\n    debug(\"pointer %o\", pointer);\n    switch (dataType.typeClass) {\n      case \"userDefinedValueType\":\n        {\n          const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n          if (!fullType.underlyingType) {\n            const error = {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: fullType\n            };\n            if (strict || options.allowRetry) {\n              throw new errors_1.StopDecodingError(error, true);\n              //note that we allow a retry if we couldn't locate the underlying type!\n            }\n\n            return {\n              type: fullType,\n              kind: \"error\",\n              error\n            };\n          }\n          const underlyingResult = yield* decodeBasic(fullType.underlyingType, pointer, info, options);\n          switch (underlyingResult.kind //yes this switch is a little unnecessary :P\n          ) {\n            case \"value\":\n              //wrap the value and return\n              return {\n                //no idea why need coercion here\n                type: fullType,\n                kind: \"value\",\n                value: underlyingResult\n              };\n            case \"error\":\n              //wrap the error and return an error result!\n              //this is inconsistent with how we handle other container types\n              //(structs, arrays, mappings), where having an error in one element\n              //does not cause an error in the whole thing, but to do that here\n              //would cause problems for the type system :-/\n              //so we'll just be inconsistent\n              return {\n                //TS is being bad again :-/\n                type: fullType,\n                kind: \"error\",\n                error: {\n                  kind: \"WrappedError\",\n                  error: underlyingResult\n                }\n              };\n          }\n          break; //to satisfy TS :P\n        }\n\n      case \"bool\":\n        {\n          if (!checkPadding(bytes, dataType, paddingMode)) {\n            let error = {\n              kind: \"BoolPaddingError\",\n              paddingType: getPaddingType(dataType, paddingMode),\n              raw: Conversion.toHexString(bytes)\n            };\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n          bytes = removePadding(bytes, dataType, paddingMode);\n          //note: the use of the BN is a little silly here,\n          //but, kind of stuck with it for now\n          const numeric = Conversion.toBN(bytes);\n          if (numeric.eqn(0)) {\n            return {\n              type: dataType,\n              kind: \"value\",\n              value: {\n                asBoolean: false\n              }\n            };\n          } else if (numeric.eqn(1)) {\n            return {\n              type: dataType,\n              kind: \"value\",\n              value: {\n                asBoolean: true\n              }\n            };\n          } else {\n            let error = {\n              kind: \"BoolOutOfRangeError\",\n              rawAsBN: numeric\n            };\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n        }\n      case \"uint\":\n        //first, check padding (if needed)\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"UintPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n        //now, truncate to appropriate length\n        bytes = removePadding(bytes, dataType, paddingMode);\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: {\n            asBN: Conversion.toBN(bytes),\n            rawAsBN: Conversion.toBN(rawBytes)\n          }\n        };\n      case \"int\":\n        //first, check padding (if needed)\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"IntPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n        //now, truncate to appropriate length (keeping the bytes on the right)\n        bytes = removePadding(bytes, dataType, paddingMode);\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: {\n            asBN: Conversion.toSignedBN(bytes),\n            rawAsBN: Conversion.toSignedBN(rawBytes)\n          }\n        };\n      case \"address\":\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"AddressPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n        bytes = removePadding(bytes, dataType, paddingMode);\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: {\n            asAddress: Evm.Utils.toAddress(bytes),\n            rawAsHex: Conversion.toHexString(rawBytes)\n          }\n        };\n      case \"contract\":\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"ContractPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n        bytes = removePadding(bytes, dataType, paddingMode);\n        const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n        const contractValueInfo = yield* decodeContract(bytes, info);\n        return {\n          type: fullType,\n          kind: \"value\",\n          value: contractValueInfo\n        };\n      case \"bytes\":\n        //NOTE: we assume this is a *static* bytestring,\n        //because this is decodeBasic! dynamic ones should\n        //go to decodeBytes!\n        let coercedDataType = dataType;\n        //first, check padding (if needed)\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"BytesPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n          return {\n            type: coercedDataType,\n            kind: \"error\",\n            error\n          };\n        }\n        //now, truncate to appropriate length\n        bytes = removePadding(bytes, dataType, paddingMode);\n        return {\n          type: coercedDataType,\n          kind: \"value\",\n          value: {\n            asHex: Conversion.toHexString(bytes),\n            rawAsHex: Conversion.toHexString(rawBytes)\n          }\n        };\n      case \"function\":\n        switch (dataType.visibility) {\n          case \"external\":\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n              const error = {\n                kind: \"FunctionExternalNonStackPaddingError\",\n                paddingType: getPaddingType(dataType, paddingMode),\n                raw: Conversion.toHexString(bytes)\n              };\n              if (strict) {\n                throw new errors_1.StopDecodingError(error);\n              }\n              return {\n                type: dataType,\n                kind: \"error\",\n                error\n              };\n            }\n            bytes = removePadding(bytes, dataType, paddingMode);\n            const address = bytes.slice(0, Evm.Utils.ADDRESS_SIZE);\n            const selector = bytes.slice(Evm.Utils.ADDRESS_SIZE, Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE);\n            return {\n              type: dataType,\n              kind: \"value\",\n              value: yield* decodeExternalFunction(address, selector, info)\n            };\n          case \"internal\":\n            //note: we used to error if we hit this point with strict === true,\n            //since internal function pointers don't go in the ABI, and strict\n            //mode is intended for ABI decoding.  however, there are times when\n            //we want to use strict mode to decode immutables, and immutables can\n            //include internal function pointers.  so now we allow this.  yes,\n            //this is a bit of an abuse of strict mode, which was after all meant\n            //for ABI decoding, but oh well.\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n              const error = {\n                kind: \"FunctionInternalPaddingError\",\n                paddingType: getPaddingType(dataType, paddingMode),\n                raw: Conversion.toHexString(bytes)\n              };\n              if (strict) {\n                throw new errors_1.StopDecodingError(error);\n              }\n              return {\n                type: dataType,\n                kind: \"error\",\n                error\n              };\n            }\n            bytes = removePadding(bytes, dataType, paddingMode);\n            const deployedPc = bytes.slice(-Evm.Utils.PC_SIZE);\n            const constructorPc = bytes.slice(-Evm.Utils.PC_SIZE * 2, -Evm.Utils.PC_SIZE);\n            return decodeInternalFunction(dataType, deployedPc, constructorPc, info, strict);\n        }\n        break;\n      //to satisfy TypeScript\n      case \"enum\":\n        {\n          let numeric = Conversion.toBN(bytes);\n          const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n          if (!fullType.options) {\n            let error = {\n              kind: \"EnumNotFoundDecodingError\",\n              type: fullType,\n              rawAsBN: numeric\n            };\n            if (strict || options.allowRetry) {\n              throw new errors_1.StopDecodingError(error, true);\n              //note that we allow a retry if we couldn't locate the enum type!\n            }\n\n            return {\n              type: fullType,\n              kind: \"error\",\n              error\n            };\n          }\n          //note: I'm doing the padding checks a little more manually on this one\n          //so that we can have the right type of error\n          const numOptions = fullType.options.length;\n          const numBytes = Math.ceil(Math.log2(numOptions) / 8);\n          const paddingType = getPaddingType(dataType, paddingMode);\n          if (!checkPaddingDirect(bytes, numBytes, paddingType)) {\n            let error = {\n              kind: \"EnumPaddingError\",\n              type: fullType,\n              paddingType,\n              raw: Conversion.toHexString(bytes)\n            };\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n          bytes = removePaddingDirect(bytes, numBytes, paddingType);\n          numeric = Conversion.toBN(bytes); //alter numeric!\n          if (numeric.ltn(numOptions)) {\n            const name = fullType.options[numeric.toNumber()];\n            //NOTE: despite the use of toNumber(), I'm NOT catching exceptions here and returning an\n            //error value like elsewhere; I'm just letting this one fail.  Why?  Because if we have\n            //an enum with that many options in the first place, we have bigger problems!\n            return {\n              type: fullType,\n              kind: \"value\",\n              value: {\n                name,\n                numericAsBN: numeric\n              }\n            };\n          } else {\n            let error = {\n              kind: \"EnumOutOfRangeError\",\n              type: fullType,\n              rawAsBN: numeric\n            };\n            if (strict) {\n              //note:\n              //if the enum is merely out of range rather than out of the ABI range,\n              //we do NOT throw an error here!  instead we simply return an error value,\n              //which we normally avoid doing in strict mode.  (the error will be caught\n              //later at the re-encoding step instead.)  why?  because we might be running\n              //in ABI mode, so we may need to abify this \"value\" rather than just throwing\n              //it out.\n              throw new errors_1.StopDecodingError(error);\n              //note that we do NOT allow a retry here!\n              //if we *can* find the enum type but the value is out of range,\n              //we *know* that it is invalid!\n            }\n\n            return {\n              type: fullType,\n              kind: \"error\",\n              error\n            };\n          }\n        }\n      case \"fixed\":\n        {\n          //first, check padding (if needed)\n          if (!checkPadding(bytes, dataType, paddingMode)) {\n            let error = {\n              kind: \"FixedPaddingError\",\n              paddingType: getPaddingType(dataType, paddingMode),\n              raw: Conversion.toHexString(bytes)\n            };\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n          //now, truncate to appropriate length (keeping the bytes on the right)\n          bytes = removePadding(bytes, dataType, paddingMode);\n          let asBN = Conversion.toSignedBN(bytes);\n          let rawAsBN = Conversion.toSignedBN(rawBytes);\n          let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n          let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBig,\n              rawAsBig\n            }\n          };\n        }\n      case \"ufixed\":\n        {\n          //first, check padding (if needed)\n          if (!checkPadding(bytes, dataType, paddingMode)) {\n            let error = {\n              kind: \"UfixedPaddingError\",\n              paddingType: getPaddingType(dataType, paddingMode),\n              raw: Conversion.toHexString(bytes)\n            };\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n          //now, truncate to appropriate length (keeping the bytes on the right)\n          bytes = removePadding(bytes, dataType, paddingMode);\n          let asBN = Conversion.toBN(bytes);\n          let rawAsBN = Conversion.toBN(rawBytes);\n          let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n          let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBig,\n              rawAsBig\n            }\n          };\n        }\n    }\n  }();\n}\nexports.decodeBasic = decodeBasic;\n//NOTE that this function returns a ContractValueInfo, not a ContractResult\nfunction* decodeContract(addressBytes, info) {\n  return (yield* decodeContractAndContext(addressBytes, info)).contractInfo;\n}\nexports.decodeContract = decodeContract;\nfunction* decodeContractAndContext(addressBytes, info) {\n  let address = Evm.Utils.toAddress(addressBytes);\n  let rawAddress = Conversion.toHexString(addressBytes);\n  let codeBytes = yield {\n    type: \"code\",\n    address\n  };\n  let code = Conversion.toHexString(codeBytes);\n  let context = Contexts.Utils.findContext(info.contexts, code);\n  if (context !== null) {\n    return {\n      context,\n      contractInfo: {\n        kind: \"known\",\n        address,\n        rawAddress,\n        class: Contexts.Import.contextToType(context)\n      }\n    };\n  } else {\n    return {\n      context,\n      contractInfo: {\n        kind: \"unknown\",\n        address,\n        rawAddress\n      }\n    };\n  }\n}\n//note: address can have extra zeroes on the left like elsewhere, but selector should be exactly 4 bytes\n//NOTE this again returns a FunctionExternalValueInfo, not a FunctionExternalResult\nfunction* decodeExternalFunction(addressBytes, selectorBytes, info) {\n  let {\n    contractInfo: contract,\n    context\n  } = yield* decodeContractAndContext(addressBytes, info);\n  let selector = Conversion.toHexString(selectorBytes);\n  if (contract.kind === \"unknown\") {\n    return {\n      kind: \"unknown\",\n      contract,\n      selector\n    };\n  }\n  let abiEntry = context.abi !== undefined ? context.abi[selector] : undefined;\n  if (abiEntry === undefined) {\n    return {\n      kind: \"invalid\",\n      contract,\n      selector\n    };\n  }\n  return {\n    kind: \"known\",\n    contract,\n    selector,\n    abi: abiEntry\n  };\n}\nexports.decodeExternalFunction = decodeExternalFunction;\n//this one works a bit differently -- in order to handle errors, it *does* return a FunctionInternalResult\nfunction decodeInternalFunction(dataType, deployedPcBytes, constructorPcBytes, info, strict) {\n  const deployedPc = Conversion.toBN(deployedPcBytes).toNumber();\n  const constructorPc = Conversion.toBN(constructorPcBytes).toNumber();\n  const context = Contexts.Import.contextToType(info.currentContext);\n  //before anything else: do we even have an internal functions table?\n  //if not, we'll just return the info we have without really attemting to decode\n  if (!info.internalFunctionsTable) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"unknown\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  }\n  //also before we continue: is the PC zero? if so let's just return that\n  if (deployedPc === 0 && constructorPc === 0) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  }\n  //another check: is only the deployed PC zero?\n  if (deployedPc === 0 && constructorPc !== 0) {\n    const error = {\n      kind: \"MalformedInternalFunctionError\",\n      context,\n      deployedProgramCounter: 0,\n      constructorProgramCounter: constructorPc\n    };\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n  //one last pre-check: is this a deployed-format pointer in a constructor?\n  if (info.currentContext.isConstructor && constructorPc === 0) {\n    const error = {\n      kind: \"DeployedFunctionInConstructorError\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: 0\n    };\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n  //otherwise, we get our function\n  const pc = info.currentContext.isConstructor ? constructorPc : deployedPc;\n  const functionEntry = info.internalFunctionsTable[pc];\n  if (!functionEntry) {\n    //if it's not zero and there's no entry... error!\n    const error = {\n      kind: \"NoSuchInternalFunctionError\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: constructorPc\n    };\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n  if (functionEntry.isDesignatedInvalid) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  }\n  const name = functionEntry.name;\n  const mutability = functionEntry.mutability;\n  const definedIn = Evm.Import.functionTableEntryToType(functionEntry); //may be null\n  const id = Evm.Import.makeInternalFunctionId(functionEntry);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      kind: \"function\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: constructorPc,\n      name,\n      id,\n      definedIn,\n      mutability\n    }\n  };\n}\nfunction checkPadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  const length = (0, allocate_1.byteLength)(dataType, userDefinedTypes);\n  const paddingType = getPaddingType(dataType, paddingMode);\n  if (paddingMode === \"permissive\") {\n    switch (dataType.typeClass) {\n      case \"bool\":\n      case \"enum\":\n      case \"function\":\n        //these three types are checked even in permissive mode\n        return checkPaddingDirect(bytes, length, paddingType);\n      default:\n        return true;\n    }\n  } else {\n    return checkPaddingDirect(bytes, length, paddingType);\n  }\n}\nfunction removePadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  const length = (0, allocate_1.byteLength)(dataType, userDefinedTypes);\n  const paddingType = getPaddingType(dataType, paddingMode);\n  return removePaddingDirect(bytes, length, paddingType);\n}\nfunction removePaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"right\":\n      return bytes.slice(0, length);\n    default:\n      return bytes.slice(-length);\n  }\n}\nfunction checkPaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"left\":\n      return checkPaddingLeft(bytes, length);\n    case \"right\":\n      return checkPaddingRight(bytes, length);\n    case \"signed\":\n      return checkPaddingSigned(bytes, length);\n    case \"signedOrLeft\":\n      return checkPaddingSigned(bytes, length) || checkPaddingLeft(bytes, length);\n  }\n}\nfunction getPaddingType(dataType, paddingMode) {\n  switch (paddingMode) {\n    case \"right\":\n      return \"right\";\n    case \"default\":\n    case \"permissive\":\n      return defaultPaddingType(dataType);\n    case \"zero\":\n      {\n        const defaultType = defaultPaddingType(dataType);\n        return defaultType === \"signed\" ? \"left\" : defaultType;\n      }\n    case \"defaultOrZero\":\n      {\n        const defaultType = defaultPaddingType(dataType);\n        return defaultType === \"signed\" ? \"signedOrLeft\" : defaultType;\n      }\n  }\n}\nfunction defaultPaddingType(dataType) {\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      return \"right\";\n    case \"int\":\n    case \"fixed\":\n      return \"signed\";\n    case \"function\":\n      if (dataType.visibility === \"external\") {\n        return \"right\";\n      }\n    //otherwise, fall through to default\n    default:\n      return \"left\";\n  }\n}\nfunction checkPaddingRight(bytes, length) {\n  let padding = bytes.slice(length); //cut off the first length bytes\n  return padding.every(paddingByte => paddingByte === 0);\n}\n//exporting this one for use in stack.ts\nfunction checkPaddingLeft(bytes, length) {\n  let padding = bytes.slice(0, -length); //cut off the last length bytes\n  return padding.every(paddingByte => paddingByte === 0);\n}\nexports.checkPaddingLeft = checkPaddingLeft;\nfunction checkPaddingSigned(bytes, length) {\n  let padding = bytes.slice(0, -length); //padding is all but the last length bytes\n  let value = bytes.slice(-length); //meanwhile the actual value is those last length bytes\n  let signByte = value[0] & 0x80 ? 0xff : 0x00;\n  return padding.every(paddingByte => paddingByte === signByte);\n}","map":{"version":3,"mappings":"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","names":["debug","decodeBasic","dataType","pointer","info","options","state","strictAbiMode","strict","paddingMode","bytes","rawBytes","error","typeClass","fullType","Format","Types","userDefinedTypes","underlyingType","kind","type","allowRetry","errors_1","underlyingResult","value","checkPadding","paddingType","getPaddingType","raw","Conversion","toHexString","removePadding","numeric","toBN","eqn","asBoolean","rawAsBN","asBN","toSignedBN","asAddress","Evm","Utils","toAddress","rawAsHex","contractValueInfo","decodeContract","coercedDataType","asHex","visibility","address","slice","ADDRESS_SIZE","selector","SELECTOR_SIZE","decodeExternalFunction","deployedPc","PC_SIZE","constructorPc","decodeInternalFunction","numOptions","length","numBytes","Math","ceil","log2","checkPaddingDirect","removePaddingDirect","ltn","name","toNumber","numericAsBN","asBig","shiftBigDown","toBig","places","rawAsBig","exports","addressBytes","decodeContractAndContext","contractInfo","rawAddress","codeBytes","code","context","Contexts","findContext","contexts","class","Import","contextToType","selectorBytes","contract","abiEntry","abi","undefined","deployedPcBytes","constructorPcBytes","currentContext","internalFunctionsTable","deployedProgramCounter","constructorProgramCounter","isConstructor","pc","functionEntry","isDesignatedInvalid","mutability","definedIn","functionTableEntryToType","id","makeInternalFunctionId","checkPaddingLeft","checkPaddingRight","checkPaddingSigned","defaultPaddingType","defaultType","padding","every","paddingByte","signByte"],"sourceRoot":"","sources":["../../../../lib/basic/decode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}