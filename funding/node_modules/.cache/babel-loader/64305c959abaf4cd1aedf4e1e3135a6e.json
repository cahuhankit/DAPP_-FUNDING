{"ast":null,"code":"export class ReplayPath {\n  static parse(replayPathStr) {\n    const [serializedCount, serializedChanges] = replayPathStr.split(':');\n    const counts = this.parseCounts(serializedCount);\n    const changes = this.parseChanges(serializedChanges);\n    return this.parseOccurences(counts, changes);\n  }\n  static stringify(replayPath) {\n    const occurences = this.countOccurences(replayPath);\n    const serializedCount = this.stringifyCounts(occurences);\n    const serializedChanges = this.stringifyChanges(occurences);\n    return `${serializedCount}:${serializedChanges}`;\n  }\n  static intToB64(n) {\n    if (n < 26) return String.fromCharCode(n + 65);\n    if (n < 52) return String.fromCharCode(n + 97 - 26);\n    if (n < 62) return String.fromCharCode(n + 48 - 52);\n    return String.fromCharCode(n === 62 ? 43 : 47);\n  }\n  static b64ToInt(c) {\n    if (c >= 'a') return c.charCodeAt(0) - 97 + 26;\n    if (c >= 'A') return c.charCodeAt(0) - 65;\n    if (c >= '0') return c.charCodeAt(0) - 48 + 52;\n    return c === '+' ? 62 : 63;\n  }\n  static countOccurences(replayPath) {\n    return replayPath.reduce((counts, cur) => {\n      if (counts.length === 0 || counts[counts.length - 1].count === 64 || counts[counts.length - 1].value !== cur) counts.push({\n        value: cur,\n        count: 1\n      });else counts[counts.length - 1].count += 1;\n      return counts;\n    }, []);\n  }\n  static parseOccurences(counts, changes) {\n    const replayPath = [];\n    for (let idx = 0; idx !== counts.length; ++idx) {\n      const count = counts[idx];\n      const value = changes[idx];\n      for (let num = 0; num !== count; ++num) replayPath.push(value);\n    }\n    return replayPath;\n  }\n  static stringifyChanges(occurences) {\n    let serializedChanges = '';\n    for (let idx = 0; idx < occurences.length; idx += 6) {\n      const changesInt = occurences.slice(idx, idx + 6).reduceRight((prev, cur) => prev * 2 + (cur.value ? 1 : 0), 0);\n      serializedChanges += this.intToB64(changesInt);\n    }\n    return serializedChanges;\n  }\n  static parseChanges(serializedChanges) {\n    const changesInt = serializedChanges.split('').map(c => this.b64ToInt(c));\n    const changes = [];\n    for (let idx = 0; idx !== changesInt.length; ++idx) {\n      let current = changesInt[idx];\n      for (let n = 0; n !== 6; ++n, current >>= 1) {\n        changes.push(current % 2 === 1);\n      }\n    }\n    return changes;\n  }\n  static stringifyCounts(occurences) {\n    return occurences.map(_ref => {\n      let {\n        count\n      } = _ref;\n      return this.intToB64(count - 1);\n    }).join('');\n  }\n  static parseCounts(serializedCount) {\n    return serializedCount.split('').map(c => this.b64ToInt(c) + 1);\n  }\n}","map":{"version":3,"names":["ReplayPath","parse","replayPathStr","serializedCount","serializedChanges","split","counts","parseCounts","changes","parseChanges","parseOccurences","stringify","replayPath","occurences","countOccurences","stringifyCounts","stringifyChanges","intToB64","n","String","fromCharCode","b64ToInt","c","charCodeAt","reduce","cur","length","count","value","push","idx","num","changesInt","slice","reduceRight","prev","map","current","join"],"sources":["C:/Users/ankit/Desktop/FUND/funding/node_modules/fast-check/lib/esm/check/model/ReplayPath.js"],"sourcesContent":["export class ReplayPath {\n    static parse(replayPathStr) {\n        const [serializedCount, serializedChanges] = replayPathStr.split(':');\n        const counts = this.parseCounts(serializedCount);\n        const changes = this.parseChanges(serializedChanges);\n        return this.parseOccurences(counts, changes);\n    }\n    static stringify(replayPath) {\n        const occurences = this.countOccurences(replayPath);\n        const serializedCount = this.stringifyCounts(occurences);\n        const serializedChanges = this.stringifyChanges(occurences);\n        return `${serializedCount}:${serializedChanges}`;\n    }\n    static intToB64(n) {\n        if (n < 26)\n            return String.fromCharCode(n + 65);\n        if (n < 52)\n            return String.fromCharCode(n + 97 - 26);\n        if (n < 62)\n            return String.fromCharCode(n + 48 - 52);\n        return String.fromCharCode(n === 62 ? 43 : 47);\n    }\n    static b64ToInt(c) {\n        if (c >= 'a')\n            return c.charCodeAt(0) - 97 + 26;\n        if (c >= 'A')\n            return c.charCodeAt(0) - 65;\n        if (c >= '0')\n            return c.charCodeAt(0) - 48 + 52;\n        return c === '+' ? 62 : 63;\n    }\n    static countOccurences(replayPath) {\n        return replayPath.reduce((counts, cur) => {\n            if (counts.length === 0 || counts[counts.length - 1].count === 64 || counts[counts.length - 1].value !== cur)\n                counts.push({ value: cur, count: 1 });\n            else\n                counts[counts.length - 1].count += 1;\n            return counts;\n        }, []);\n    }\n    static parseOccurences(counts, changes) {\n        const replayPath = [];\n        for (let idx = 0; idx !== counts.length; ++idx) {\n            const count = counts[idx];\n            const value = changes[idx];\n            for (let num = 0; num !== count; ++num)\n                replayPath.push(value);\n        }\n        return replayPath;\n    }\n    static stringifyChanges(occurences) {\n        let serializedChanges = '';\n        for (let idx = 0; idx < occurences.length; idx += 6) {\n            const changesInt = occurences\n                .slice(idx, idx + 6)\n                .reduceRight((prev, cur) => prev * 2 + (cur.value ? 1 : 0), 0);\n            serializedChanges += this.intToB64(changesInt);\n        }\n        return serializedChanges;\n    }\n    static parseChanges(serializedChanges) {\n        const changesInt = serializedChanges.split('').map((c) => this.b64ToInt(c));\n        const changes = [];\n        for (let idx = 0; idx !== changesInt.length; ++idx) {\n            let current = changesInt[idx];\n            for (let n = 0; n !== 6; ++n, current >>= 1) {\n                changes.push(current % 2 === 1);\n            }\n        }\n        return changes;\n    }\n    static stringifyCounts(occurences) {\n        return occurences.map(({ count }) => this.intToB64(count - 1)).join('');\n    }\n    static parseCounts(serializedCount) {\n        return serializedCount.split('').map((c) => this.b64ToInt(c) + 1);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}