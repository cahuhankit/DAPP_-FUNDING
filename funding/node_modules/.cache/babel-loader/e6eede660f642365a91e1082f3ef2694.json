{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveAndWrap = exports.wrapForMethod = exports.wrapMultiple = exports.Messages = exports.wrap = exports.BadResponseTypeError = exports.TypeMismatchError = exports.NoUniqueBestOverloadError = exports.NoOverloadsMatchedError = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap\");\nconst priority_1 = require(\"./priority\");\nconst errors_1 = require(\"./errors\");\nObject.defineProperty(exports, \"NoOverloadsMatchedError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.NoOverloadsMatchedError;\n  }\n});\nObject.defineProperty(exports, \"NoUniqueBestOverloadError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.NoUniqueBestOverloadError;\n  }\n});\nObject.defineProperty(exports, \"TypeMismatchError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.TypeMismatchError;\n  }\n});\nObject.defineProperty(exports, \"BadResponseTypeError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.BadResponseTypeError;\n  }\n});\n__exportStar(require(\"./errors\"), exports);\nconst wrap_1 = require(\"./wrap\");\nObject.defineProperty(exports, \"wrap\", {\n  enumerable: true,\n  get: function () {\n    return wrap_1.wrap;\n  }\n});\n__exportStar(require(\"./types\"), exports);\nexports.Messages = __importStar(require(\"./messages\"));\nfunction* wrapMultiple(types, inputs, wrapOptions) {\n  //just wrap the types in a tuple and defer to wrap()\n  const combinedType = {\n    typeClass: \"tuple\",\n    memberTypes: types\n  };\n  debug(\"wrapping multiple\");\n  const wrappedTogether = yield* (0, wrap_1.wrap)(combinedType, inputs, wrapOptions);\n  return wrappedTogether.value.map(_ref => {\n    let {\n      value\n    } = _ref;\n    return value;\n  });\n}\nexports.wrapMultiple = wrapMultiple;\n//note: turns on loose\nfunction* wrapForMethod(method, inputs, resolveOptions) {\n  const wrapped = yield* wrapForMethodRaw(method, inputs, resolveOptions, true);\n  return wrappingToResolution(method, wrapped);\n}\nexports.wrapForMethod = wrapForMethod;\nfunction wrappingToResolution(method, wrapped) {\n  if (wrapped.length > 0 && wrapped[wrapped.length - 1].type.typeClass === \"options\") {\n    //there's options\n    const wrappedArguments = wrapped.slice(0, -1); //cut off options\n    const options = wrapped[wrapped.length - 1].value;\n    return {\n      method,\n      arguments: wrappedArguments,\n      options\n    };\n  } else {\n    //no options\n    return {\n      method,\n      arguments: wrapped,\n      options: {}\n    };\n  }\n}\n//doesn't separate out options from arguments & doesn't turn on loose\nfunction wrapForMethodRaw(method, inputs, _ref2) {\n  let {\n    userDefinedTypes,\n    allowOptions,\n    allowJson,\n    strictBooleans\n  } = _ref2;\n  let loose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return function* () {\n    debug(\"wrapping for method\");\n    if (method.inputs.length === inputs.length) {\n      //no options case\n      debug(\"no options\");\n      return yield* wrapMultiple(method.inputs, inputs, {\n        userDefinedTypes,\n        oldOptionsBehavior: true,\n        loose,\n        name: \"<arguments>\",\n        allowJson,\n        strictBooleans\n      });\n    } else if (allowOptions && method.inputs.length === inputs.length - 1) {\n      //options case\n      debug(\"options\");\n      const inputsWithOptions = [...method.inputs, {\n        name: \"<options>\",\n        type: {\n          typeClass: \"options\"\n        }\n      }];\n      return yield* wrapMultiple(inputsWithOptions, inputs, {\n        userDefinedTypes,\n        oldOptionsBehavior: true,\n        loose,\n        name: \"<arguments>\",\n        allowJson,\n        strictBooleans\n      });\n    } else {\n      //invalid length case\n      const orOneMore = allowOptions ? ` (or ${method.inputs.length + 1} counting transaction options)` : \"\";\n      throw new errors_1.TypeMismatchError({\n        typeClass: \"tuple\",\n        memberTypes: method.inputs\n      }, inputs, \"<arguments>\", 5, `Incorrect number of arguments (expected ${method.inputs.length}${orOneMore}, got ${inputs.length})`);\n    }\n  }();\n}\nfunction resolveAndWrap(methods, inputs, _ref3) {\n  let {\n    userDefinedTypes,\n    allowOptions,\n    allowJson,\n    strictBooleans\n  } = _ref3;\n  return function* () {\n    //despite us having a good system for overload resolution, we want to\n    //use it as little as possible!  That's because using it means we don't\n    //get great error messages.  As such, we're going to do a bunch to filter\n    //things beforehand, so that we get good error messages.\n    if (methods.length === 1) {\n      //if there's only one possibility, we just defer to wrapForMethod\n      //if we ignore error messages this is silly... but we're not!\n      //this is important for good error messages in this case\n      return yield* wrapForMethod(methods[0], inputs, {\n        userDefinedTypes,\n        allowOptions,\n        allowJson,\n        strictBooleans\n      });\n    }\n    //OK, so, there are multiple possibilities then.  let's try to filter things down by length.\n    const possibleMatches = methods.filter(method => method.inputs.length === inputs.length);\n    //but, we've also got to account for the possibility of options\n    let possibleMatchesWithOptions = [];\n    let possibleOptions = {};\n    if (allowOptions && inputs.length > 0) {\n      //if options are allowed, we'll have to account for that.\n      //*however*, in order to minimize the number of possibilities, we won't\n      //use these unless the last argument of inputs actually looks like an options!\n      const lastInput = inputs[inputs.length - 1];\n      let isOptionsPossible = true;\n      try {\n        const wrappedOptions = yield* (0, wrap_1.wrap)({\n          typeClass: \"options\"\n        }, lastInput, {\n          name: \"<options>\",\n          loose: true,\n          oldOptionsBehavior: true,\n          userDefinedTypes,\n          allowJson,\n          strictBooleans\n        });\n        possibleOptions = wrappedOptions.value;\n      } catch (error) {\n        if (error instanceof errors_1.TypeMismatchError) {\n          isOptionsPossible = false;\n        } else {\n          throw error; //rethrow unexpected errors\n        }\n      }\n\n      if (isOptionsPossible) {\n        possibleMatchesWithOptions = methods.filter(method => method.inputs.length === inputs.length - 1);\n      }\n    }\n    debug(\"possibleMatches: %o\", possibleMatches);\n    debug(\"possibleMatchesWithOptions: %o\", possibleMatchesWithOptions);\n    //if there's now only one possibility, great!\n    if (possibleMatches.length === 1 && possibleMatchesWithOptions.length === 0) {\n      //only one possibility, no options. we can just defer to wrapMultiple.\n      //(again, point is to have good error messaging)\n      debug(\"only one possibility, no options\");\n      const method = possibleMatches[0];\n      return {\n        method,\n        arguments: yield* wrapMultiple(method.inputs, inputs, {\n          userDefinedTypes,\n          loose: true,\n          name: \"<arguments>\",\n          allowJson,\n          strictBooleans\n        }),\n        options: {}\n      };\n    } else if (possibleMatchesWithOptions.length === 1 && possibleMatches.length === 0) {\n      //only one possibility, with options.  moreover, we already determined the options\n      //above, so we can once again just defer to wrapMultiple\n      debug(\"only one possiblity, with options\");\n      const method = possibleMatchesWithOptions[0];\n      return {\n        method,\n        arguments: yield* wrapMultiple(method.inputs, inputs, {\n          userDefinedTypes,\n          loose: true,\n          name: \"<arguments>\",\n          allowJson,\n          strictBooleans\n        }),\n        options: possibleOptions\n      };\n    } else if (possibleMatches.length === 0 && possibleMatchesWithOptions.length === 0) {\n      debug(\"no possibilities\");\n      //nothing matches!\n      throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);\n    }\n    //if all of our attempts to avoid it have failed, we'll have to actually use\n    //our overload resolution system. note how we do *not* turn on loose in this\n    //case!\n    debug(\"attempting overload resolution\");\n    let resolutions = [];\n    for (const method of methods) {\n      let wrapped;\n      try {\n        //note this part takes care of options for us...\n        //although yes this means options will be re-wrapped, oh well\n        wrapped = yield* wrapForMethodRaw(method, inputs, {\n          userDefinedTypes,\n          allowOptions,\n          allowJson,\n          strictBooleans\n        });\n      } catch (error) {\n        //if there's an error, don't add it\n        debug(\"failed: %O\", method);\n        debug(\"because: %O\", error);\n        continue;\n      }\n      //note that options and arguments here are both not correct, but we'll\n      //fix them up later!\n      debug(\"adding: %O\", method);\n      resolutions.push({\n        method,\n        arguments: wrapped,\n        options: {}\n      });\n    }\n    //now: narrow it down to the most specific one(s)\n    debug(\"resolutions: %O\", resolutions);\n    resolutions = resolutions.filter(resolution => resolutions.every(comparisonResolution => !(0, priority_1.isMoreSpecificMultiple)(comparisonResolution.arguments, resolution.arguments, userDefinedTypes) ||\n    //because the comparison is nonstrict, this comparison is added to\n    //effectively make it strict\n    // i.e. we have !(x<=y) but we want !(x<y), i.e.,\n    // !(x<=y) | x=y, i.e., !(x<=y) | (x<=y & y<=x),\n    // i.e., !(x<=y) | y<=x\n    (0, priority_1.isMoreSpecificMultiple)(resolution.arguments, comparisonResolution.arguments, userDefinedTypes)));\n    debug(\"resolutions remaining: %O\", resolutions);\n    switch (resolutions.length) {\n      case 0:\n        //no resolution worked\n        throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);\n      case 1:\n        //there was a most specific resolution; fix up options and arguments\n        //before returning\n        const {\n          method,\n          arguments: wrapped\n        } = resolutions[0];\n        return wrappingToResolution(method, wrapped);\n      default:\n        //no unique most-specific resolution\n        throw new errors_1.NoUniqueBestOverloadError(resolutions);\n    }\n  }();\n}\nexports.resolveAndWrap = resolveAndWrap;","map":{"version":3,"mappings":"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","names":["debug","Object","enumerable","get","errors_1","__exportStar","wrap_1","exports","wrapMultiple","types","inputs","wrapOptions","combinedType","typeClass","memberTypes","wrappedTogether","value","map","wrapForMethod","method","resolveOptions","wrapped","wrapForMethodRaw","wrappingToResolution","length","type","wrappedArguments","slice","options","arguments","userDefinedTypes","allowOptions","allowJson","strictBooleans","loose","oldOptionsBehavior","name","inputsWithOptions","orOneMore","resolveAndWrap","methods","possibleMatches","filter","possibleMatchesWithOptions","possibleOptions","lastInput","isOptionsPossible","wrappedOptions","error","resolutions","push","resolution","every","comparisonResolution"],"sourceRoot":"","sources":["../../../lib/wrap/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}