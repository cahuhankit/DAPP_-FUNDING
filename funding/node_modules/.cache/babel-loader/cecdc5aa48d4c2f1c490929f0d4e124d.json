{"ast":null,"code":"const debug = require(\"debug\")(\"contract:contract\");\nlet Web3 = require(\"web3\");\nconst webUtils = require(\"web3-utils\");\nconst execute = require(\"../execute\");\nconst bootstrap = require(\"./bootstrap\");\nconst constructorMethods = require(\"./constructorMethods\");\nconst properties = require(\"./properties\");\n\n// For browserified version. If browserify gave us an empty version,\n// look for the one provided by the user.\nif (typeof Web3 === \"object\" && Object.keys(Web3).length === 0) {\n  Web3 = global.Web3;\n}\n(function (module) {\n  // Accepts a contract object created with web3.eth.Contract or an address.\n  function Contract(contract) {\n    var instance = this;\n    var constructor = instance.constructor;\n\n    // Disambiguate between .at() and .new()\n    if (typeof contract === \"string\") {\n      var web3Instance = new constructor.web3.eth.Contract(constructor.abi);\n      web3Instance.options.address = contract;\n      contract = web3Instance;\n    }\n\n    // Core:\n    instance.methods = {};\n    instance.abi = constructor.abi;\n    instance.address = contract.options.address;\n    instance.transactionHash = contract.transactionHash;\n    instance.contract = contract;\n\n    //for stacktracing in tests\n    if (constructor.debugger) {\n      instance.debugger = constructor.debugger;\n    }\n\n    // User defined methods, overloaded methods, events\n    instance.abi.forEach(function (item) {\n      switch (item.type) {\n        case \"function\":\n          var isConstant = [\"pure\", \"view\"].includes(item.stateMutability) || item.constant; // new form // deprecated case\n\n          var signature = webUtils._jsonInterfaceMethodToString(item);\n          var method = function (constant, web3Method) {\n            var fn;\n            constant ? fn = execute.call.call(constructor, web3Method, item, instance.address) : fn = execute.send.call(constructor, web3Method, item, instance.address);\n            fn.call = execute.call.call(constructor, web3Method, item, instance.address);\n            fn.sendTransaction = execute.send.call(constructor, web3Method, item, instance.address);\n            fn.estimateGas = execute.estimate.call(constructor, web3Method, item, instance.address);\n            fn.request = execute.request.call(constructor, web3Method, item, instance.address);\n            return fn;\n          };\n\n          // Only define methods once. Any overloaded methods will have all their\n          // accessors available by ABI signature available on the `methods` key below.\n          if (instance[item.name] === undefined) {\n            instance[item.name] = method(isConstant, contract.methods[item.name]);\n          }\n\n          // Overloaded methods should be invoked via the .methods property\n          instance.methods[signature] = method(isConstant, contract.methods[signature]);\n          break;\n        case \"event\":\n          instance[item.name] = execute.event.call(constructor, contract.events[item.name]);\n          break;\n      }\n    });\n\n    // instance.{sendTransaction, estimateGas, call, send}\n    instance.sendTransaction = execute.send.call(constructor, null, null, instance.address);\n    instance.estimateGas = execute.estimate.call(constructor, null, null, instance.address);\n\n    // Prefer user defined `call`\n    if (!instance.call) {\n      instance.call = execute.call.call(constructor, null, null, instance.address);\n    }\n\n    // Prefer user defined `send`\n    if (!instance.send) {\n      instance.send = function (value) {\n        let txParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const packet = Object.assign({\n          value: value\n        }, txParams);\n        return instance.sendTransaction(packet);\n      };\n    }\n\n    // Other events\n    instance.allEvents = execute.allEvents.call(constructor, contract);\n    instance.getPastEvents = execute.getPastEvents.call(constructor, contract);\n  }\n  Contract._constructorMethods = constructorMethods(Contract);\n\n  // Getter functions are scoped to Contract object.\n  Contract._properties = properties;\n  bootstrap(Contract);\n  module.exports = Contract;\n  return Contract;\n})(module || {});","map":{"version":3,"names":["debug","require","Web3","webUtils","execute","bootstrap","constructorMethods","properties","Object","keys","length","global","module","Contract","contract","instance","constructor","web3Instance","web3","eth","abi","options","address","methods","transactionHash","debugger","forEach","item","type","isConstant","includes","stateMutability","constant","signature","_jsonInterfaceMethodToString","method","web3Method","fn","call","send","sendTransaction","estimateGas","estimate","request","name","undefined","event","events","value","txParams","packet","assign","allEvents","getPastEvents","_constructorMethods","_properties","exports"],"sources":["C:/Users/ankit/Desktop/FUND/funding/node_modules/@truffle/contract/lib/contract/index.js"],"sourcesContent":["const debug = require(\"debug\")(\"contract:contract\");\nlet Web3 = require(\"web3\");\nconst webUtils = require(\"web3-utils\");\nconst execute = require(\"../execute\");\nconst bootstrap = require(\"./bootstrap\");\nconst constructorMethods = require(\"./constructorMethods\");\nconst properties = require(\"./properties\");\n\n// For browserified version. If browserify gave us an empty version,\n// look for the one provided by the user.\nif (typeof Web3 === \"object\" && Object.keys(Web3).length === 0) {\n  Web3 = global.Web3;\n}\n\n(function (module) {\n  // Accepts a contract object created with web3.eth.Contract or an address.\n  function Contract(contract) {\n    var instance = this;\n    var constructor = instance.constructor;\n\n    // Disambiguate between .at() and .new()\n    if (typeof contract === \"string\") {\n      var web3Instance = new constructor.web3.eth.Contract(constructor.abi);\n      web3Instance.options.address = contract;\n      contract = web3Instance;\n    }\n\n    // Core:\n    instance.methods = {};\n    instance.abi = constructor.abi;\n    instance.address = contract.options.address;\n    instance.transactionHash = contract.transactionHash;\n    instance.contract = contract;\n\n    //for stacktracing in tests\n    if (constructor.debugger) {\n      instance.debugger = constructor.debugger;\n    }\n\n    // User defined methods, overloaded methods, events\n    instance.abi.forEach(function (item) {\n      switch (item.type) {\n        case \"function\":\n          var isConstant =\n            [\"pure\", \"view\"].includes(item.stateMutability) || item.constant; // new form // deprecated case\n\n          var signature = webUtils._jsonInterfaceMethodToString(item);\n\n          var method = function (constant, web3Method) {\n            var fn;\n\n            constant\n              ? (fn = execute.call.call(\n                  constructor,\n                  web3Method,\n                  item,\n                  instance.address\n                ))\n              : (fn = execute.send.call(\n                  constructor,\n                  web3Method,\n                  item,\n                  instance.address\n                ));\n\n            fn.call = execute.call.call(\n              constructor,\n              web3Method,\n              item,\n              instance.address\n            );\n            fn.sendTransaction = execute.send.call(\n              constructor,\n              web3Method,\n              item,\n              instance.address\n            );\n            fn.estimateGas = execute.estimate.call(\n              constructor,\n              web3Method,\n              item,\n              instance.address\n            );\n            fn.request = execute.request.call(\n              constructor,\n              web3Method,\n              item,\n              instance.address\n            );\n\n            return fn;\n          };\n\n          // Only define methods once. Any overloaded methods will have all their\n          // accessors available by ABI signature available on the `methods` key below.\n          if (instance[item.name] === undefined) {\n            instance[item.name] = method(\n              isConstant,\n              contract.methods[item.name]\n            );\n          }\n\n          // Overloaded methods should be invoked via the .methods property\n          instance.methods[signature] = method(\n            isConstant,\n            contract.methods[signature]\n          );\n          break;\n\n        case \"event\":\n          instance[item.name] = execute.event.call(\n            constructor,\n            contract.events[item.name]\n          );\n          break;\n      }\n    });\n\n    // instance.{sendTransaction, estimateGas, call, send}\n    instance.sendTransaction = execute.send.call(\n      constructor,\n      null,\n      null,\n      instance.address\n    );\n\n    instance.estimateGas = execute.estimate.call(\n      constructor,\n      null,\n      null,\n      instance.address\n    );\n\n    // Prefer user defined `call`\n    if (!instance.call) {\n      instance.call = execute.call.call(\n        constructor,\n        null,\n        null,\n        instance.address\n      );\n    }\n\n    // Prefer user defined `send`\n    if (!instance.send) {\n      instance.send = (value, txParams = {}) => {\n        const packet = Object.assign({ value: value }, txParams);\n        return instance.sendTransaction(packet);\n      };\n    }\n\n    // Other events\n    instance.allEvents = execute.allEvents.call(constructor, contract);\n    instance.getPastEvents = execute.getPastEvents.call(constructor, contract);\n  }\n\n  Contract._constructorMethods = constructorMethods(Contract);\n\n  // Getter functions are scoped to Contract object.\n  Contract._properties = properties;\n\n  bootstrap(Contract);\n  module.exports = Contract;\n\n  return Contract;\n})(module || {});\n"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC,CAAC,mBAAmB,CAAC;AACnD,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC1B,MAAME,QAAQ,GAAGF,OAAO,CAAC,YAAY,CAAC;AACtC,MAAMG,OAAO,GAAGH,OAAO,CAAC,YAAY,CAAC;AACrC,MAAMI,SAAS,GAAGJ,OAAO,CAAC,aAAa,CAAC;AACxC,MAAMK,kBAAkB,GAAGL,OAAO,CAAC,sBAAsB,CAAC;AAC1D,MAAMM,UAAU,GAAGN,OAAO,CAAC,cAAc,CAAC;;AAE1C;AACA;AACA,IAAI,OAAOC,IAAI,KAAK,QAAQ,IAAIM,MAAM,CAACC,IAAI,CAACP,IAAI,CAAC,CAACQ,MAAM,KAAK,CAAC,EAAE;EAC9DR,IAAI,GAAGS,MAAM,CAACT,IAAI;AACpB;AAEA,CAAC,UAAUU,MAAM,EAAE;EACjB;EACA,SAASC,QAAQ,CAACC,QAAQ,EAAE;IAC1B,IAAIC,QAAQ,GAAG,IAAI;IACnB,IAAIC,WAAW,GAAGD,QAAQ,CAACC,WAAW;;IAEtC;IACA,IAAI,OAAOF,QAAQ,KAAK,QAAQ,EAAE;MAChC,IAAIG,YAAY,GAAG,IAAID,WAAW,CAACE,IAAI,CAACC,GAAG,CAACN,QAAQ,CAACG,WAAW,CAACI,GAAG,CAAC;MACrEH,YAAY,CAACI,OAAO,CAACC,OAAO,GAAGR,QAAQ;MACvCA,QAAQ,GAAGG,YAAY;IACzB;;IAEA;IACAF,QAAQ,CAACQ,OAAO,GAAG,CAAC,CAAC;IACrBR,QAAQ,CAACK,GAAG,GAAGJ,WAAW,CAACI,GAAG;IAC9BL,QAAQ,CAACO,OAAO,GAAGR,QAAQ,CAACO,OAAO,CAACC,OAAO;IAC3CP,QAAQ,CAACS,eAAe,GAAGV,QAAQ,CAACU,eAAe;IACnDT,QAAQ,CAACD,QAAQ,GAAGA,QAAQ;;IAE5B;IACA,IAAIE,WAAW,CAACS,QAAQ,EAAE;MACxBV,QAAQ,CAACU,QAAQ,GAAGT,WAAW,CAACS,QAAQ;IAC1C;;IAEA;IACAV,QAAQ,CAACK,GAAG,CAACM,OAAO,CAAC,UAAUC,IAAI,EAAE;MACnC,QAAQA,IAAI,CAACC,IAAI;QACf,KAAK,UAAU;UACb,IAAIC,UAAU,GACZ,CAAC,MAAM,EAAE,MAAM,CAAC,CAACC,QAAQ,CAACH,IAAI,CAACI,eAAe,CAAC,IAAIJ,IAAI,CAACK,QAAQ,CAAC,CAAC;;UAEpE,IAAIC,SAAS,GAAG9B,QAAQ,CAAC+B,4BAA4B,CAACP,IAAI,CAAC;UAE3D,IAAIQ,MAAM,GAAG,UAAUH,QAAQ,EAAEI,UAAU,EAAE;YAC3C,IAAIC,EAAE;YAENL,QAAQ,GACHK,EAAE,GAAGjC,OAAO,CAACkC,IAAI,CAACA,IAAI,CACrBtB,WAAW,EACXoB,UAAU,EACVT,IAAI,EACJZ,QAAQ,CAACO,OAAO,CACjB,GACAe,EAAE,GAAGjC,OAAO,CAACmC,IAAI,CAACD,IAAI,CACrBtB,WAAW,EACXoB,UAAU,EACVT,IAAI,EACJZ,QAAQ,CAACO,OAAO,CAChB;YAENe,EAAE,CAACC,IAAI,GAAGlC,OAAO,CAACkC,IAAI,CAACA,IAAI,CACzBtB,WAAW,EACXoB,UAAU,EACVT,IAAI,EACJZ,QAAQ,CAACO,OAAO,CACjB;YACDe,EAAE,CAACG,eAAe,GAAGpC,OAAO,CAACmC,IAAI,CAACD,IAAI,CACpCtB,WAAW,EACXoB,UAAU,EACVT,IAAI,EACJZ,QAAQ,CAACO,OAAO,CACjB;YACDe,EAAE,CAACI,WAAW,GAAGrC,OAAO,CAACsC,QAAQ,CAACJ,IAAI,CACpCtB,WAAW,EACXoB,UAAU,EACVT,IAAI,EACJZ,QAAQ,CAACO,OAAO,CACjB;YACDe,EAAE,CAACM,OAAO,GAAGvC,OAAO,CAACuC,OAAO,CAACL,IAAI,CAC/BtB,WAAW,EACXoB,UAAU,EACVT,IAAI,EACJZ,QAAQ,CAACO,OAAO,CACjB;YAED,OAAOe,EAAE;UACX,CAAC;;UAED;UACA;UACA,IAAItB,QAAQ,CAACY,IAAI,CAACiB,IAAI,CAAC,KAAKC,SAAS,EAAE;YACrC9B,QAAQ,CAACY,IAAI,CAACiB,IAAI,CAAC,GAAGT,MAAM,CAC1BN,UAAU,EACVf,QAAQ,CAACS,OAAO,CAACI,IAAI,CAACiB,IAAI,CAAC,CAC5B;UACH;;UAEA;UACA7B,QAAQ,CAACQ,OAAO,CAACU,SAAS,CAAC,GAAGE,MAAM,CAClCN,UAAU,EACVf,QAAQ,CAACS,OAAO,CAACU,SAAS,CAAC,CAC5B;UACD;QAEF,KAAK,OAAO;UACVlB,QAAQ,CAACY,IAAI,CAACiB,IAAI,CAAC,GAAGxC,OAAO,CAAC0C,KAAK,CAACR,IAAI,CACtCtB,WAAW,EACXF,QAAQ,CAACiC,MAAM,CAACpB,IAAI,CAACiB,IAAI,CAAC,CAC3B;UACD;MAAM;IAEZ,CAAC,CAAC;;IAEF;IACA7B,QAAQ,CAACyB,eAAe,GAAGpC,OAAO,CAACmC,IAAI,CAACD,IAAI,CAC1CtB,WAAW,EACX,IAAI,EACJ,IAAI,EACJD,QAAQ,CAACO,OAAO,CACjB;IAEDP,QAAQ,CAAC0B,WAAW,GAAGrC,OAAO,CAACsC,QAAQ,CAACJ,IAAI,CAC1CtB,WAAW,EACX,IAAI,EACJ,IAAI,EACJD,QAAQ,CAACO,OAAO,CACjB;;IAED;IACA,IAAI,CAACP,QAAQ,CAACuB,IAAI,EAAE;MAClBvB,QAAQ,CAACuB,IAAI,GAAGlC,OAAO,CAACkC,IAAI,CAACA,IAAI,CAC/BtB,WAAW,EACX,IAAI,EACJ,IAAI,EACJD,QAAQ,CAACO,OAAO,CACjB;IACH;;IAEA;IACA,IAAI,CAACP,QAAQ,CAACwB,IAAI,EAAE;MAClBxB,QAAQ,CAACwB,IAAI,GAAG,UAACS,KAAK,EAAoB;QAAA,IAAlBC,QAAQ,uEAAG,CAAC,CAAC;QACnC,MAAMC,MAAM,GAAG1C,MAAM,CAAC2C,MAAM,CAAC;UAAEH,KAAK,EAAEA;QAAM,CAAC,EAAEC,QAAQ,CAAC;QACxD,OAAOlC,QAAQ,CAACyB,eAAe,CAACU,MAAM,CAAC;MACzC,CAAC;IACH;;IAEA;IACAnC,QAAQ,CAACqC,SAAS,GAAGhD,OAAO,CAACgD,SAAS,CAACd,IAAI,CAACtB,WAAW,EAAEF,QAAQ,CAAC;IAClEC,QAAQ,CAACsC,aAAa,GAAGjD,OAAO,CAACiD,aAAa,CAACf,IAAI,CAACtB,WAAW,EAAEF,QAAQ,CAAC;EAC5E;EAEAD,QAAQ,CAACyC,mBAAmB,GAAGhD,kBAAkB,CAACO,QAAQ,CAAC;;EAE3D;EACAA,QAAQ,CAAC0C,WAAW,GAAGhD,UAAU;EAEjCF,SAAS,CAACQ,QAAQ,CAAC;EACnBD,MAAM,CAAC4C,OAAO,GAAG3C,QAAQ;EAEzB,OAAOA,QAAQ;AACjB,CAAC,EAAED,MAAM,IAAI,CAAC,CAAC,CAAC"},"metadata":{},"sourceType":"script"}