{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:string\");\nconst dispatch_1 = require(\"./dispatch\");\nconst errors_1 = require(\"./errors\");\nconst decode_1 = require(\"../bytes/decode\");\nconst bytes_1 = require(\"./bytes\");\nconst Utils = __importStar(require(\"./utils\"));\nconst Messages = __importStar(require(\"./messages\"));\nconst stringCasesBasic = [stringFromString, stringFromBoxedString, stringFromCodecStringValue, stringFromUint8ArrayLike, stringFailureCase];\nexports.stringCases = [stringFromTypeValueInput, ...stringCasesBasic];\nfunction* stringFromString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  if (!Utils.isValidUtf16(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.invalidUtf16Message);\n  }\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      kind: \"valid\",\n      asString: input\n    }\n  };\n}\nfunction* stringFromBoxedString(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n  }\n  //defer to primitive string case\n  return yield* stringFromString(dataType, input.valueOf(), wrapOptions);\n}\nfunction* stringFromCodecStringValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  //rather than dealing with the different kinds in this case\n  //for rewrapping, we'll just rewrap directly;\n  //yes, this is a bit inconsistent with how we handle this case for other types\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: input.value\n  };\n}\nfunction* stringFromUint8ArrayLike(dataType, input, wrapOptions) {\n  if (!Utils.isUint8ArrayLike(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Uint8Array-like\");\n  }\n  //the next series of checks is delegated to a helper fn\n  (0, bytes_1.validateUint8ArrayLike)(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)\n  const info = (0, decode_1.decodeString)(new Uint8Array(input));\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: info\n  };\n}\nfunction* stringFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n  if (input.type !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n  //extract value & try again, with loose option turned on\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), stringCasesBasic);\n}\nfunction* stringFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, Messages.notAStringMessage);\n}","map":{"version":3,"mappings":"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","names":["debug","stringCasesBasic","stringFromString","stringFromBoxedString","stringFromCodecStringValue","stringFromUint8ArrayLike","stringFailureCase","exports","stringFromTypeValueInput","dataType","input","wrapOptions","errors_1","name","Utils","isValidUtf16","Messages","invalidUtf16Message","type","kind","value","asString","isBoxedString","valueOf","isWrappedResult","typeClass","wrappedTypeMessage","errorResultMessage","isUint8ArrayLike","info","Uint8Array","isTypeValueInput","specifiedTypeMessage","loose","notAStringMessage"],"sourceRoot":"","sources":["../../../lib/wrap/string.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}