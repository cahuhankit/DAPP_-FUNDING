{"ast":null,"code":"\"use strict\";\n\n/**\n * Contains the types for type objects, and some\n * functions for working with them.\n *\n * @category Main Format\n *\n * @packageDocumentation\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isContractDefinedType = exports.typeStringWithoutLocation = exports.typeString = exports.specifyLocation = exports.fullType = exports.isReferenceType = exports.forgetCompilations = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:format:types\");\nfunction forgetCompilations(typesByCompilation) {\n  return Object.assign({}, ...Object.values(typesByCompilation).map(_ref => {\n    let {\n      types\n    } = _ref;\n    return types;\n  }));\n}\nexports.forgetCompilations = forgetCompilations;\nfunction isUserDefinedType(anyType) {\n  const userDefinedTypes = [\"contract\", \"enum\", \"struct\", \"userDefinedValueType\"];\n  return userDefinedTypes.includes(anyType.typeClass);\n}\nfunction isReferenceType(anyType) {\n  const alwaysReferenceTypes = [\"array\", \"mapping\", \"struct\", \"string\"];\n  if (alwaysReferenceTypes.includes(anyType.typeClass)) {\n    return true;\n  } else if (anyType.typeClass === \"bytes\") {\n    return anyType.kind === \"dynamic\";\n  } else {\n    return false;\n  }\n}\nexports.isReferenceType = isReferenceType;\n//one could define a counterpart function that stripped all unnecessary information\n//from the type object, but at the moment I see no need for that\nfunction fullType(basicType, userDefinedTypes) {\n  if (!isUserDefinedType(basicType)) {\n    return basicType;\n  }\n  let id = basicType.id;\n  let storedType = userDefinedTypes[id];\n  if (!storedType) {\n    return basicType;\n  }\n  let returnType = Object.assign(Object.assign({}, basicType), storedType);\n  if (isReferenceType(basicType) && basicType.location !== undefined) {\n    returnType = specifyLocation(returnType, basicType.location);\n  }\n  return returnType;\n}\nexports.fullType = fullType;\n//the location argument here always forces, so passing undefined *will* force undefined\nfunction specifyLocation(dataType, location) {\n  if (isReferenceType(dataType)) {\n    switch (dataType.typeClass) {\n      case \"string\":\n      case \"bytes\":\n        return Object.assign(Object.assign({}, dataType), {\n          location\n        });\n      case \"array\":\n        return Object.assign(Object.assign({}, dataType), {\n          location,\n          baseType: specifyLocation(dataType.baseType, location)\n        });\n      case \"mapping\":\n        let newLocation = location === \"storage\" ? \"storage\" : undefined;\n        return Object.assign(Object.assign({}, dataType), {\n          location: newLocation,\n          valueType: specifyLocation(dataType.valueType, newLocation)\n        });\n      case \"struct\":\n        let returnType = Object.assign(Object.assign({}, dataType), {\n          location\n        });\n        if (returnType.memberTypes) {\n          returnType.memberTypes = returnType.memberTypes.map(_ref2 => {\n            let {\n              name: memberName,\n              type: memberType\n            } = _ref2;\n            return {\n              name: memberName,\n              type: specifyLocation(memberType, location)\n            };\n          });\n        }\n        return returnType;\n    }\n  } else {\n    return dataType;\n  }\n}\nexports.specifyLocation = specifyLocation;\n//NOTE: the following two functions might not be exactly right for weird internal stuff,\n//or for ABI-only stuff.  (E.g. for internal stuff sometimes it records whether things\n//are pointers or not??  we don't track that so we can't recreate that)\n//But what can you do.\nfunction typeString(dataType) {\n  let baseString = typeStringWithoutLocation(dataType);\n  if (isReferenceType(dataType) && dataType.location) {\n    return baseString + \" \" + dataType.location;\n  } else {\n    return baseString;\n  }\n}\nexports.typeString = typeString;\nfunction typeStringWithoutLocation(dataType) {\n  switch (dataType.typeClass) {\n    case \"uint\":\n      return dataType.typeHint || `uint${dataType.bits}`;\n    case \"int\":\n      return dataType.typeHint || `int${dataType.bits}`;\n    case \"bool\":\n      return dataType.typeHint || \"bool\";\n    case \"bytes\":\n      if (dataType.typeHint) {\n        return dataType.typeHint;\n      }\n      switch (dataType.kind) {\n        case \"dynamic\":\n          return \"bytes\";\n        case \"static\":\n          return `bytes${dataType.length}`;\n      }\n    case \"address\":\n      switch (dataType.kind) {\n        case \"general\":\n          return dataType.typeHint || \"address\";\n        //I guess?\n        case \"specific\":\n          return dataType.payable ? \"address payable\" : \"address\";\n      }\n    case \"string\":\n      return dataType.typeHint || \"string\";\n    case \"fixed\":\n      return dataType.typeHint || `fixed${dataType.bits}x${dataType.places}`;\n    case \"ufixed\":\n      return dataType.typeHint || `ufixed${dataType.bits}x${dataType.places}`;\n    case \"array\":\n      if (dataType.typeHint) {\n        return dataType.typeHint;\n      }\n      switch (dataType.kind) {\n        case \"dynamic\":\n          return `${typeStringWithoutLocation(dataType.baseType)}[]`;\n        case \"static\":\n          return `${typeStringWithoutLocation(dataType.baseType)}[${dataType.length}]`;\n      }\n    case \"mapping\":\n      return `mapping(${typeStringWithoutLocation(dataType.keyType)} => ${typeStringWithoutLocation(dataType.valueType)})`;\n    case \"struct\":\n    case \"enum\":\n      //combining these cases for simplicity\n      switch (dataType.kind) {\n        case \"local\":\n          return `${dataType.typeClass} ${dataType.definingContractName}.${dataType.typeName}`;\n        case \"global\":\n          return `${dataType.typeClass} ${dataType.typeName}`;\n      }\n      break;\n    //to satisfy TS :P\n    case \"userDefinedValueType\":\n      //differs from struct & enum in that typeClass is omitted\n      switch (dataType.kind) {\n        case \"local\":\n          return `${dataType.definingContractName}.${dataType.typeName}`;\n        case \"global\":\n          return `${dataType.typeName}`;\n      }\n      break;\n    //to satisfy TS :P\n    case \"tuple\":\n      return dataType.typeHint || \"tuple(\" + dataType.memberTypes.map(memberType => typeString(memberType.type)).join(\",\") + \")\";\n    //note that we do include location and do not put spaces\n    case \"contract\":\n      return dataType.contractKind + \" \" + dataType.typeName;\n    case \"magic\":\n      //no, this is not transposed!\n      const variableNames = {\n        message: \"msg\",\n        transaction: \"tx\",\n        block: \"block\"\n      };\n      return variableNames[dataType.variable];\n    case \"type\":\n      return `type(${typeString(dataType.type)})`;\n    case \"function\":\n      let visibilityString;\n      switch (dataType.visibility) {\n        case \"external\":\n          if (dataType.kind === \"general\") {\n            if (dataType.typeHint) {\n              return dataType.typeHint;\n            } else {\n              return \"function external\"; //I guess???\n            }\n          }\n\n          visibilityString = \" external\"; //note the deliberate space!\n          break;\n        case \"internal\":\n          visibilityString = \"\";\n          break;\n      }\n      let mutabilityString = dataType.mutability === \"nonpayable\" ? \"\" : \" \" + dataType.mutability; //again, note the deliberate space\n      let inputList = dataType.inputParameterTypes.map(typeString).join(\",\"); //note that we do include location, and do not put spaces\n      let outputList = dataType.outputParameterTypes.map(typeString).join(\",\");\n      let inputString = `function(${inputList})`;\n      let outputString = outputList === \"\" ? \"\" : ` returns (${outputList})`; //again, note the deliberate space\n      return inputString + mutabilityString + visibilityString + outputString;\n    case \"options\":\n      //note: not a real Solidity type! just for error messaging!\n      return \"options\";\n  }\n}\nexports.typeStringWithoutLocation = typeStringWithoutLocation;\nfunction isContractDefinedType(anyType) {\n  const contractDefinedTypes = [\"enum\", \"struct\", \"userDefinedValueType\"];\n  return contractDefinedTypes.includes(anyType.typeClass) && anyType.kind === \"local\";\n}\nexports.isContractDefinedType = isContractDefinedType;","map":{"version":3,"mappings":"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","names":["debug","forgetCompilations","typesByCompilation","Object","assign","values","map","types","exports","isUserDefinedType","anyType","userDefinedTypes","includes","typeClass","isReferenceType","alwaysReferenceTypes","kind","fullType","basicType","id","storedType","returnType","location","undefined","specifyLocation","dataType","baseType","newLocation","valueType","memberTypes","name","memberName","type","memberType","typeString","baseString","typeStringWithoutLocation","typeHint","bits","length","payable","places","keyType","definingContractName","typeName","join","contractKind","variableNames","message","transaction","block","variable","visibilityString","visibility","mutabilityString","mutability","inputList","inputParameterTypes","outputList","outputParameterTypes","inputString","outputString","isContractDefinedType","contractDefinedTypes"],"sourceRoot":"","sources":["../../../lib/format/types.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}