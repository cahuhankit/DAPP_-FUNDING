{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeBasic = void 0;\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Evm = __importStar(require(\"../../evm\"));\n//UGH -- it turns out TypeScript can't handle nested tagged unions\n//see: https://github.com/microsoft/TypeScript/issues/18758\n//so, I'm just going to have to throw in a bunch of type coercions >_>\n/**\n * Handles encoding of basic types; yes the input type is broader than\n * it should be but it's hard to fix this without causing other problems,\n * sorry!\n * @Category Encoding (low-level)\n */\nfunction encodeBasic(input) {\n  let bytes;\n  switch (input.type.typeClass) {\n    case \"userDefinedValueType\":\n      return encodeBasic(input.value);\n    case \"uint\":\n    case \"int\":\n      return Conversion.toBytes(input.value.asBN, Evm.Utils.WORD_SIZE);\n    case \"enum\":\n      return Conversion.toBytes(input.value.numericAsBN, Evm.Utils.WORD_SIZE);\n    case \"bool\":\n      {\n        bytes = new Uint8Array(Evm.Utils.WORD_SIZE); //is initialized to zeroes\n        if (input.value.asBoolean) {\n          bytes[Evm.Utils.WORD_SIZE - 1] = 1;\n        }\n        return bytes;\n      }\n    case \"bytes\":\n      switch (input.type.kind) {\n        //deliberately not handling dynamic case!\n        case \"static\":\n          bytes = Conversion.toBytes(input.value.asHex);\n          let padded = new Uint8Array(Evm.Utils.WORD_SIZE); //initialized to zeroes\n          padded.set(bytes);\n          return padded;\n      }\n    case \"address\":\n      return Conversion.toBytes(input.value.asAddress, Evm.Utils.WORD_SIZE);\n    case \"contract\":\n      return Conversion.toBytes(input.value.address, Evm.Utils.WORD_SIZE);\n    case \"function\":\n      {\n        switch (input.type.visibility) {\n          //for our purposes here, we will NOT count internal functions as a\n          //basic type!  so no handling of internal case\n          case \"external\":\n            let coercedInput = input;\n            let encoded = new Uint8Array(Evm.Utils.WORD_SIZE); //starts filled w/0s\n            let addressBytes = Conversion.toBytes(coercedInput.value.contract.address); //should already be correct length\n            let selectorBytes = Conversion.toBytes(coercedInput.value.selector); //should already be correct length\n            encoded.set(addressBytes);\n            encoded.set(selectorBytes, Evm.Utils.ADDRESS_SIZE); //set it after the address\n            return encoded;\n        }\n        break; //to satisfy TS\n      }\n\n    case \"fixed\":\n    case \"ufixed\":\n      let bigValue = input.value.asBig;\n      let shiftedValue = Conversion.shiftBigUp(bigValue, input.type.places);\n      return Conversion.toBytes(shiftedValue, Evm.Utils.WORD_SIZE);\n  }\n}\nexports.encodeBasic = encodeBasic;","map":{"version":3,"mappings":"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","names":["encodeBasic","input","bytes","type","typeClass","value","Conversion","toBytes","asBN","Evm","Utils","WORD_SIZE","numericAsBN","Uint8Array","asBoolean","kind","asHex","padded","set","asAddress","address","visibility","coercedInput","encoded","addressBytes","contract","selectorBytes","selector","ADDRESS_SIZE","bigValue","asBig","shiftedValue","shiftBigUp","places","exports"],"sourceRoot":"","sources":["../../../../lib/basic/encode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}