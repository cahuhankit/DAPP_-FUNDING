{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.equalSlots = exports.slotAddress = exports.storageLengthToBytes = exports.isWordsLength = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:storage:utils\");\nconst Evm = __importStar(require(\"../evm\"));\nconst MappingKey = __importStar(require(\"../mapping-key\"));\nfunction isWordsLength(size) {\n  return size.words !== undefined;\n}\nexports.isWordsLength = isWordsLength;\nfunction storageLengthToBytes(size) {\n  if (isWordsLength(size)) {\n    debug(\"size.words %d\", size.words);\n    return size.words * Evm.Utils.WORD_SIZE;\n  } else {\n    return size.bytes;\n  }\n}\nexports.storageLengthToBytes = storageLengthToBytes;\n/**\n * convert a slot to a word corresponding to actual storage address\n *\n * if `slot` is an array, return hash of array values.\n * if `slot` array is nested, recurse on sub-arrays\n *\n * @param slot - number or possibly-nested array of numbers\n */\nfunction slotAddress(slot) {\n  if (slot.key !== undefined && slot.path !== undefined) {\n    // mapping reference\n    return Evm.Utils.keccak256(MappingKey.Encode.mappingKeyAsHex(slot.key), slotAddress(slot.path)).add(slot.offset);\n  } else if (slot.path !== undefined) {\n    const pathAddress = slotAddress(slot.path);\n    const path = slot.hashPath ? Evm.Utils.keccak256(pathAddress) : pathAddress;\n    return path.add(slot.offset);\n  } else {\n    return slot.offset;\n  }\n}\nexports.slotAddress = slotAddress;\n//note: this function compares slots mostly by structure,\n//rather than by their numerical value\nfunction equalSlots(slot1, slot2) {\n  if (!slot1 || !slot2) {\n    return !slot1 && !slot2; //if either is undefined, it's true only if both are\n  }\n\n  if (!slot1.offset.eq(slot2.offset)) {\n    return false;\n  }\n  if (slot1.hashPath !== slot2.hashPath) {\n    return false;\n  }\n  if (!equalSlots(slot1.path, slot2.path)) {\n    return false;\n  }\n  //to compare keys, we'll just compare their hex encodings\n  //(yes, that leaves some wiggle room, as it could consider different\n  //*types* of keys to be equal, but if keys are the only difference then\n  //that should determine those types, so it shouldn't be a problem)\n  if (!slot1.key || !slot2.key) {\n    //first, though, they likely don't *have* keys\n    return !slot1.key && !slot2.key;\n  }\n  //if they do have keys, though...\n  return Evm.Utils.equalData(MappingKey.Encode.encodeMappingKey(slot1.key), MappingKey.Encode.encodeMappingKey(slot2.key));\n}\nexports.equalSlots = equalSlots;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA,MAAMA,KAAK,GAAG,mBAAW,EAAC,qBAAqB,CAAC;AAEhD;AACA;AAIA,SAAgBC,aAAa,CAACC,IAAmB;EAC/C,OAA2BA,IAAK,CAACC,KAAK,KAAKC,SAAS;AACtD;AAFAC;AAIA,SAAgBC,oBAAoB,CAACJ,IAAmB;EACtD,IAAID,aAAa,CAACC,IAAI,CAAC,EAAE;IACvBF,KAAK,CAAC,eAAe,EAAEE,IAAI,CAACC,KAAK,CAAC;IAClC,OAAOD,IAAI,CAACC,KAAK,GAAGI,GAAG,CAACC,KAAK,CAACC,SAAS;GACxC,MAAM;IACL,OAAOP,IAAI,CAACQ,KAAK;;AAErB;AAPAL;AASA;;;;;;;;AAQA,SAAgBM,WAAW,CAACC,IAAU;EACpC,IAAIA,IAAI,CAACC,GAAG,KAAKT,SAAS,IAAIQ,IAAI,CAACE,IAAI,KAAKV,SAAS,EAAE;IACrD;IACA,OAAOG,GAAG,CAACC,KAAK,CAACO,SAAS,CACxBC,UAAU,CAACC,MAAM,CAACC,eAAe,CAACN,IAAI,CAACC,GAAG,CAAC,EAC3CF,WAAW,CAACC,IAAI,CAACE,IAAI,CAAC,CACvB,CAACK,GAAG,CAACP,IAAI,CAACQ,MAAM,CAAC;GACnB,MAAM,IAAIR,IAAI,CAACE,IAAI,KAAKV,SAAS,EAAE;IAClC,MAAMiB,WAAW,GAAGV,WAAW,CAACC,IAAI,CAACE,IAAI,CAAC;IAC1C,MAAMA,IAAI,GAAOF,IAAI,CAACU,QAAQ,GAC1Bf,GAAG,CAACC,KAAK,CAACO,SAAS,CAACM,WAAW,CAAC,GAChCA,WAAW;IACf,OAAOP,IAAI,CAACK,GAAG,CAACP,IAAI,CAACQ,MAAM,CAAC;GAC7B,MAAM;IACL,OAAOR,IAAI,CAACQ,MAAM;;AAEtB;AAhBAf;AAkBA;AACA;AACA,SAAgBkB,UAAU,CACxBC,KAAuB,EACvBC,KAAuB;EAEvB,IAAI,CAACD,KAAK,IAAI,CAACC,KAAK,EAAE;IACpB,OAAO,CAACD,KAAK,IAAI,CAACC,KAAK,CAAC,CAAC;;;EAE3B,IAAI,CAACD,KAAK,CAACJ,MAAM,CAACM,EAAE,CAACD,KAAK,CAACL,MAAM,CAAC,EAAE;IAClC,OAAO,KAAK;;EAEd,IAAII,KAAK,CAACF,QAAQ,KAAKG,KAAK,CAACH,QAAQ,EAAE;IACrC,OAAO,KAAK;;EAEd,IAAI,CAACC,UAAU,CAACC,KAAK,CAACV,IAAI,EAAEW,KAAK,CAACX,IAAI,CAAC,EAAE;IACvC,OAAO,KAAK;;EAEd;EACA;EACA;EACA;EACA,IAAI,CAACU,KAAK,CAACX,GAAG,IAAI,CAACY,KAAK,CAACZ,GAAG,EAAE;IAC5B;IACA,OAAO,CAACW,KAAK,CAACX,GAAG,IAAI,CAACY,KAAK,CAACZ,GAAG;;EAEjC;EACA,OAAON,GAAG,CAACC,KAAK,CAACmB,SAAS,CACxBX,UAAU,CAACC,MAAM,CAACW,gBAAgB,CAACJ,KAAK,CAACX,GAAG,CAAC,EAC7CG,UAAU,CAACC,MAAM,CAACW,gBAAgB,CAACH,KAAK,CAACZ,GAAG,CAAC,CAC9C;AACH;AA7BAR","names":["debug","isWordsLength","size","words","undefined","exports","storageLengthToBytes","Evm","Utils","WORD_SIZE","bytes","slotAddress","slot","key","path","keccak256","MappingKey","Encode","mappingKeyAsHex","add","offset","pathAddress","hashPath","equalSlots","slot1","slot2","eq","equalData","encodeMappingKey"],"sourceRoot":"","sources":["../../../lib/storage/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}