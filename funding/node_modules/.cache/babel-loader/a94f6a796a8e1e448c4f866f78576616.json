{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readBytes = exports.readCode = void 0;\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nfunction* readCode(pointer, state) {\n  let code = state.code;\n  if (!code) {\n    const address = Evm.Utils.toAddress(state.specials.this);\n    code = yield {\n      type: \"code\",\n      address\n    };\n    if (code === null) {\n      //check for null as a way to deliberately indicate an error\n      throw new errors_1.DecodingError({\n        kind: \"CodeNotSuppliedError\",\n        address\n      });\n    }\n  }\n  return readBytes(pointer, Object.assign(Object.assign({}, state), {\n    code\n  }));\n}\nexports.readCode = readCode;\nfunction readBytes(pointer, state) {\n  let sourceBytes = state[pointer.location];\n  const {\n    start: offset,\n    length\n  } = pointer;\n  if (!Number.isSafeInteger(offset + length)) {\n    throw new errors_1.DecodingError({\n      kind: \"ReadErrorBytes\",\n      location: pointer.location,\n      start: offset,\n      length\n    });\n  }\n  // grab `length` bytes no matter what, here fill this array\n  var bytes = new Uint8Array(length);\n  bytes.fill(0); //fill it wil zeroes to start\n  //if the start is beyond the end of the source, just return those 0s\n  if (offset >= sourceBytes.length) {\n    return bytes;\n  }\n  // if we're reading past the end of the source, truncate the length to read\n  let excess = offset + length - sourceBytes.length;\n  let readLength;\n  if (excess > 0) {\n    readLength = sourceBytes.length - offset;\n  } else {\n    readLength = length;\n  }\n  //get the (truncated) bytes\n  let existing = new Uint8Array(sourceBytes.buffer, offset, readLength);\n  //copy it into our buffer\n  bytes.set(existing);\n  return bytes;\n}\nexports.readBytes = readBytes;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA;AAGA,UAAiBA,QAAQ,CACvBC,OAA4B,EAC5BC,KAAmB;EAEnB,IAAIC,IAAI,GAAGD,KAAK,CAACC,IAAI;EACrB,IAAI,CAACA,IAAI,EAAE;IACT,MAAMC,OAAO,GAAGC,GAAG,CAACC,KAAK,CAACC,SAAS,CAACL,KAAK,CAACM,QAAQ,CAACC,IAAI,CAAC;IACxDN,IAAI,GAAG,MAAM;MACXO,IAAI,EAAE,MAAM;MACZN;KACD;IACD,IAAID,IAAI,KAAK,IAAI,EAAE;MACjB;MACA,MAAM,IAAIQ,sBAAa,CAAC;QACtBC,IAAI,EAAE,sBAA+B;QACrCR;OACD,CAAC;;;EAGN,OAAOS,SAAS,CAACZ,OAAO,kCAAOC,KAAK;IAAEC;EAAI,GAAG;AAC/C;AApBAW;AAsBA,SAAgBD,SAAS,CACvBZ,OAA6B,EAC7BC,KAAmB;EAEnB,IAAIa,WAAW,GAAGb,KAAK,CAACD,OAAO,CAACe,QAAQ,CAAC;EAEzC,MAAM;IAAEC,KAAK,EAAEC,MAAM;IAAEC;EAAM,CAAE,GAAGlB,OAAO;EACzC,IAAI,CAACmB,MAAM,CAACC,aAAa,CAACH,MAAM,GAAGC,MAAM,CAAC,EAAE;IAC1C,MAAM,IAAIR,sBAAa,CAAC;MACtBC,IAAI,EAAE,gBAAyB;MAC/BI,QAAQ,EAAEf,OAAO,CAACe,QAAQ;MAC1BC,KAAK,EAAEC,MAAM;MACbC;KACD,CAAC;;EAGJ;EACA,IAAIG,KAAK,GAAG,IAAIC,UAAU,CAACJ,MAAM,CAAC;EAClCG,KAAK,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;EAEf;EACA,IAAIN,MAAM,IAAIH,WAAW,CAACI,MAAM,EAAE;IAChC,OAAOG,KAAK;;EAGd;EACA,IAAIG,MAAM,GAAGP,MAAM,GAAGC,MAAM,GAAGJ,WAAW,CAACI,MAAM;EACjD,IAAIO,UAAU;EACd,IAAID,MAAM,GAAG,CAAC,EAAE;IACdC,UAAU,GAAGX,WAAW,CAACI,MAAM,GAAGD,MAAM;GACzC,MAAM;IACLQ,UAAU,GAAGP,MAAM;;EAGrB;EACA,IAAIQ,QAAQ,GAAG,IAAIJ,UAAU,CAACR,WAAW,CAACa,MAAM,EAAEV,MAAM,EAAEQ,UAAU,CAAC;EAErE;EACAJ,KAAK,CAACO,GAAG,CAACF,QAAQ,CAAC;EAEnB,OAAOL,KAAK;AACd;AAzCAR","names":["readCode","pointer","state","code","address","Evm","Utils","toAddress","specials","this","type","errors_1","kind","readBytes","exports","sourceBytes","location","start","offset","length","Number","isSafeInteger","bytes","Uint8Array","fill","excess","readLength","existing","buffer","set"],"sourceRoot":"","sources":["../../../../lib/bytes/read/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}