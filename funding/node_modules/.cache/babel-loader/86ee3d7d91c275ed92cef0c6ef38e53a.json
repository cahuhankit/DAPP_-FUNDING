{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeUnderscoresHex = exports.removeUnderscoresNoHex = exports.removeUnderscoresNumeric = exports.isValidUtf16 = exports.isBoxedPrimitive = exports.isBoxedBoolean = exports.isBoxedNumber = exports.isBoxedString = exports.isByteStringWithUnderscores = exports.isByteString = exports.isPrefixlessHexString = exports.isHexString = exports.base64Length = exports.isBase64 = exports.isPlainObject = exports.isUint8ArrayLike = exports.isWrappedResult = exports.isFunctionExternalInput = exports.isContractInput = exports.isEncodingTextInput = exports.isTypeValueInput = exports.isSafeNumber = exports.minValue = exports.maxValue = exports.places = void 0;\nconst big_js_1 = __importDefault(require(\"big.js\"));\nconst Conversion = __importStar(require(\"../conversion\"));\nconst isBoolean_1 = __importDefault(require(\"lodash/isBoolean\")); //recognizes boolean *or* Boolean\nconst isString_1 = __importDefault(require(\"lodash/isString\")); //recognizes string *or* String\nconst isNumber_1 = __importDefault(require(\"lodash/isNumber\")); //recognizes number *or* Number\nconst utf8_1 = __importDefault(require(\"utf8\"));\nfunction places(dataType) {\n  switch (dataType.typeClass) {\n    case \"int\":\n    case \"uint\":\n      return 0;\n    case \"fixed\":\n    case \"ufixed\":\n      return dataType.places;\n  }\n}\nexports.places = places;\nfunction maxValue(dataType) {\n  let bits = dataType.bits;\n  if (dataType.typeClass === \"int\" || dataType.typeClass === \"fixed\") {\n    bits -= 1; //subtract 1 for signed\n  }\n\n  const maxIntegerValue = new big_js_1.default(2).pow(bits).minus(1);\n  return Conversion.shiftBigDown(maxIntegerValue, places(dataType));\n}\nexports.maxValue = maxValue;\nfunction minValue(dataType) {\n  if (dataType.typeClass === \"uint\" || dataType.typeClass === \"ufixed\") {\n    return new big_js_1.default(0);\n  }\n  const minIntegerValue = new big_js_1.default(0).minus(new big_js_1.default(2).pow(dataType.bits));\n  return Conversion.shiftBigDown(minIntegerValue, places(dataType));\n}\nexports.minValue = minValue;\nfunction isSafeNumber(dataType, input) {\n  const scaledUp = input * 10 ** dataType.places;\n  return Number.MIN_SAFE_INTEGER <= scaledUp && scaledUp <= Number.MAX_SAFE_INTEGER;\n}\nexports.isSafeNumber = isSafeNumber;\nfunction isTypeValueInput(input) {\n  return typeof input === \"object\" && input !== null && typeof input.type === \"string\" && \"value\" in input && Object.keys(input).length === 2;\n}\nexports.isTypeValueInput = isTypeValueInput;\nfunction isEncodingTextInput(input) {\n  return typeof input === \"object\" && input !== null && typeof input.encoding === \"string\" && typeof input.text === \"string\" && Object.keys(input).length === 2;\n}\nexports.isEncodingTextInput = isEncodingTextInput;\nfunction isContractInput(input) {\n  return (typeof input === \"object\" || typeof input === \"function\") && input !== null && typeof input.address === \"string\" &&\n  //we *don't* check anything more for addresses, we'll let the\n  //address wrapper handle that\n  !(\"selector\" in input);\n}\nexports.isContractInput = isContractInput;\nfunction isFunctionExternalInput(input) {\n  return (typeof input === \"object\" || typeof input === \"function\") && input !== null && \"address\" in input && \"selector\" in input;\n}\nexports.isFunctionExternalInput = isFunctionExternalInput;\nfunction isWrappedResult(input) {\n  return typeof input === \"object\" && input !== null && typeof input.type === \"object\" && input.type !== null && typeof input.type.typeClass === \"string\" && (input.kind === \"value\" && typeof input.value === \"object\" || input.kind === \"error\" && typeof input.error === \"object\");\n}\nexports.isWrappedResult = isWrappedResult;\nfunction isUint8ArrayLike(input) {\n  return input instanceof Uint8Array || typeof input === \"object\" && input !== null && typeof input.length === \"number\";\n}\nexports.isUint8ArrayLike = isUint8ArrayLike;\n//hack?\nfunction isPlainObject(input) {\n  return typeof input === \"object\" && input !== null;\n}\nexports.isPlainObject = isPlainObject;\nfunction isBase64(input) {\n  const base64Pattern = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}([A-Za-z0-9+/]|=)=)?$/; //Vim's syntax highlighting is wrong here\n  return Boolean(input.match(base64Pattern));\n}\nexports.isBase64 = isBase64;\nfunction base64Length(base64) {\n  const [_, endingEquals] = base64.match(/(=*)$/); //note this match always succeeds\n  return base64.length * 3 / 4 - endingEquals.length;\n}\nexports.base64Length = base64Length;\nfunction isHexString(input) {\n  //(with prefix, to be clear)\n  const hexStringPattern = /^0[xX][0-9a-fA-F]*$/;\n  return Boolean(input.match(hexStringPattern));\n}\nexports.isHexString = isHexString;\nfunction isPrefixlessHexString(input) {\n  const shortHexStringPattern = /^[0-9a-fA-F]*$/;\n  return Boolean(input.match(shortHexStringPattern));\n}\nexports.isPrefixlessHexString = isPrefixlessHexString;\nfunction isByteString(input) {\n  const byteStringPattern = /^0[xX]([0-9a-fA-F]{2})*$/;\n  return Boolean(input.match(byteStringPattern));\n}\nexports.isByteString = isByteString;\nfunction isByteStringWithUnderscores(input) {\n  const byteStringWithUnderscoresPattern = /^0[xX](([0-9a-fA-F]{2}_?)*([0-9a-fA-F]{2}))?$/;\n  return Boolean(input.match(byteStringWithUnderscoresPattern));\n}\nexports.isByteStringWithUnderscores = isByteStringWithUnderscores;\nfunction isBoxedString(input) {\n  //unfortunately, isString has been typed incorrectly.\n  //it should return `input is string|String`, but instead it\n  //incorrectly returns `input is string`.  As such, we have\n  //to work around its incorrect typing here.\n  return (0, isString_1.default)(input) && typeof input !== \"string\";\n}\nexports.isBoxedString = isBoxedString;\nfunction isBoxedNumber(input) {\n  //see comment on isBoxedString\n  return (0, isNumber_1.default)(input) && typeof input !== \"number\";\n}\nexports.isBoxedNumber = isBoxedNumber;\nfunction isBoxedBoolean(input) {\n  //see comment on isBoxedString\n  return (0, isBoolean_1.default)(input) && typeof input !== \"boolean\";\n}\nexports.isBoxedBoolean = isBoxedBoolean;\nfunction isBoxedPrimitive(input) {\n  return isBoxedString(input) || isBoxedNumber(input) || isBoxedBoolean(input);\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\nfunction isValidUtf16(input) {\n  try {\n    utf8_1.default.encode(input); //encode but discard :P\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\nexports.isValidUtf16 = isValidUtf16;\nfunction removeUnderscoresNumeric(numeric) {\n  //if it contains 0x or 0X, treat as hex;\n  //otherwise, treat as non-hex (decimal/octal/binary)\n  return numeric.match(/0x/i) ? removeUnderscoresHex(numeric) : removeUnderscoresNoHex(numeric);\n}\nexports.removeUnderscoresNumeric = removeUnderscoresNumeric;\nfunction removeUnderscoresNoHex(numeric) {\n  //this would be easy with lookbehind assertions, but those aren't safe to use\n  //in all browsers, so, we're going to have to do things a bit more\n  //manually...\n  return removeUnderscoresWithRegex(numeric, /\\d_\\d/);\n}\nexports.removeUnderscoresNoHex = removeUnderscoresNoHex;\nfunction removeUnderscoresHex(hex) {\n  //same comment\n  return removeUnderscoresWithRegex(hex, /[\\da-f]_[\\da-f]/i);\n}\nexports.removeUnderscoresHex = removeUnderscoresHex;\n//note: regex should be of the form <A>_<A>, where <A> is a regex that matches\n//precisely one character!  this will not work otherwise!\nfunction removeUnderscoresWithRegex(input, regex) {\n  let match;\n  while (match = input.match(regex)) {\n    //replace input by the same thing but w/ the underscore removed,\n    //by taking the text before and after the underscore\n    input = input.slice(0, match.index + 1) + input.slice(match.index + 2);\n  }\n  return input;\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;AACA;AACA,iEAAyC,CAAC;AAC1C,+DAAuC,CAAC;AACxC,+DAAuC,CAAC;AACxC;AAEA,SAAgBA,MAAM,CAACC,QAAqB;EAC1C,QAAQA,QAAQ,CAACC,SAAS;IACxB,KAAK,KAAK;IACV,KAAK,MAAM;MACT,OAAO,CAAC;IACV,KAAK,OAAO;IACZ,KAAK,QAAQ;MACX,OAAOD,QAAQ,CAACD,MAAM;EAAC;AAE7B;AATAG;AAWA,SAAgBC,QAAQ,CAACH,QAAqB;EAC5C,IAAII,IAAI,GAAGJ,QAAQ,CAACI,IAAI;EACxB,IAAIJ,QAAQ,CAACC,SAAS,KAAK,KAAK,IAAID,QAAQ,CAACC,SAAS,KAAK,OAAO,EAAE;IAClEG,IAAI,IAAI,CAAC,CAAC,CAAC;;;EAEb,MAAMC,eAAe,GAAG,IAAIC,gBAAG,CAAC,CAAC,CAAC,CAACC,GAAG,CAACH,IAAI,CAAC,CAACI,KAAK,CAAC,CAAC,CAAC;EACrD,OAAOC,UAAU,CAACC,YAAY,CAACL,eAAe,EAAEN,MAAM,CAACC,QAAQ,CAAC,CAAC;AACnE;AAPAE;AASA,SAAgBS,QAAQ,CAACX,QAAqB;EAC5C,IAAIA,QAAQ,CAACC,SAAS,KAAK,MAAM,IAAID,QAAQ,CAACC,SAAS,KAAK,QAAQ,EAAE;IACpE,OAAO,IAAIK,gBAAG,CAAC,CAAC,CAAC;;EAEnB,MAAMM,eAAe,GAAG,IAAIN,gBAAG,CAAC,CAAC,CAAC,CAACE,KAAK,CAAC,IAAIF,gBAAG,CAAC,CAAC,CAAC,CAACC,GAAG,CAACP,QAAQ,CAACI,IAAI,CAAC,CAAC;EACvE,OAAOK,UAAU,CAACC,YAAY,CAACE,eAAe,EAAEb,MAAM,CAACC,QAAQ,CAAC,CAAC;AACnE;AANAE;AAQA,SAAgBW,YAAY,CAACb,QAAqB,EAAEc,KAAa;EAC/D,MAAMC,QAAQ,GAAGD,KAAK,GAAG,EAAE,IAAId,QAAQ,CAACD,MAAM;EAC9C,OACEiB,MAAM,CAACC,gBAAgB,IAAIF,QAAQ,IAAIA,QAAQ,IAAIC,MAAM,CAACE,gBAAgB;AAE9E;AALAhB;AAOA,SAAgBiB,gBAAgB,CAACL,KAAU;EACzC,OACE,OAAOA,KAAK,KAAK,QAAQ,IACzBA,KAAK,KAAK,IAAI,IACd,OAAOA,KAAK,CAACM,IAAI,KAAK,QAAQ,IAC9B,OAAO,IAAIN,KAAK,IAChBO,MAAM,CAACC,IAAI,CAACR,KAAK,CAAC,CAACS,MAAM,KAAK,CAAC;AAEnC;AARArB;AAUA,SAAgBsB,mBAAmB,CAACV,KAAU;EAC5C,OACE,OAAOA,KAAK,KAAK,QAAQ,IACzBA,KAAK,KAAK,IAAI,IACd,OAAOA,KAAK,CAACW,QAAQ,KAAK,QAAQ,IAClC,OAAOX,KAAK,CAACY,IAAI,KAAK,QAAQ,IAC9BL,MAAM,CAACC,IAAI,CAACR,KAAK,CAAC,CAACS,MAAM,KAAK,CAAC;AAEnC;AARArB;AAUA,SAAgByB,eAAe,CAACb,KAAU;EACxC,OACE,CAAC,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,UAAU,KACzDA,KAAK,KAAK,IAAI,IACd,OAAOA,KAAK,CAACc,OAAO,KAAK,QAAQ;EACjC;EACA;EACA,EAAE,UAAU,IAAId,KAAK,CAAC;AAE1B;AATAZ;AAWA,SAAgB2B,uBAAuB,CACrCf,KAAU;EAEV,OACE,CAAC,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,UAAU,KACzDA,KAAK,KAAK,IAAI,IACd,SAAS,IAAIA,KAAK,IAClB,UAAU,IAAIA,KAAK;AAEvB;AATAZ;AAWA,SAAgB4B,eAAe,CAAChB,KAAU;EACxC,OACE,OAAOA,KAAK,KAAK,QAAQ,IACzBA,KAAK,KAAK,IAAI,IACd,OAAOA,KAAK,CAACM,IAAI,KAAK,QAAQ,IAC9BN,KAAK,CAACM,IAAI,KAAK,IAAI,IACnB,OAAON,KAAK,CAACM,IAAI,CAACnB,SAAS,KAAK,QAAQ,KACtCa,KAAK,CAACiB,IAAI,KAAK,OAAO,IAAI,OAAOjB,KAAK,CAACkB,KAAK,KAAK,QAAQ,IACxDlB,KAAK,CAACiB,IAAI,KAAK,OAAO,IAAI,OAAOjB,KAAK,CAACmB,KAAK,KAAK,QAAS,CAAC;AAElE;AAVA/B;AAYA,SAAgBgC,gBAAgB,CAACpB,KAAU;EACzC,OACEA,KAAK,YAAYqB,UAAU,IAC1B,OAAOrB,KAAK,KAAK,QAAQ,IACxBA,KAAK,KAAK,IAAI,IACd,OAAOA,KAAK,CAACS,MAAM,KAAK,QAAS;AAEvC;AAPArB;AASA;AACA,SAAgBkC,aAAa,CAACtB,KAAU;EACtC,OAAO,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI;AACpD;AAFAZ;AAIA,SAAgBmC,QAAQ,CAACvB,KAAa;EACpC,MAAMwB,aAAa,GACjB,4DAA4D,CAAC,CAAC;EAChE,OAAOC,OAAO,CAACzB,KAAK,CAAC0B,KAAK,CAACF,aAAa,CAAC,CAAC;AAC5C;AAJApC;AAMA,SAAgBuC,YAAY,CAACC,MAAc;EACzC,MAAM,CAACC,CAAC,EAAEC,YAAY,CAAC,GAAGF,MAAM,CAACF,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;EACjD,OAAQE,MAAM,CAACnB,MAAM,GAAG,CAAC,GAAI,CAAC,GAAGqB,YAAY,CAACrB,MAAM;AACtD;AAHArB;AAKA,SAAgB2C,WAAW,CAAC/B,KAAa;EACvC;EACA,MAAMgC,gBAAgB,GAAG,qBAAqB;EAC9C,OAAOP,OAAO,CAACzB,KAAK,CAAC0B,KAAK,CAACM,gBAAgB,CAAC,CAAC;AAC/C;AAJA5C;AAMA,SAAgB6C,qBAAqB,CAACjC,KAAa;EACjD,MAAMkC,qBAAqB,GAAG,gBAAgB;EAC9C,OAAOT,OAAO,CAACzB,KAAK,CAAC0B,KAAK,CAACQ,qBAAqB,CAAC,CAAC;AACpD;AAHA9C;AAKA,SAAgB+C,YAAY,CAACnC,KAAa;EACxC,MAAMoC,iBAAiB,GAAG,0BAA0B;EACpD,OAAOX,OAAO,CAACzB,KAAK,CAAC0B,KAAK,CAACU,iBAAiB,CAAC,CAAC;AAChD;AAHAhD;AAKA,SAAgBiD,2BAA2B,CAACrC,KAAa;EACvD,MAAMsC,gCAAgC,GACpC,+CAA+C;EACjD,OAAOb,OAAO,CAACzB,KAAK,CAAC0B,KAAK,CAACY,gCAAgC,CAAC,CAAC;AAC/D;AAJAlD;AAMA,SAAgBmD,aAAa,CAACvC,KAAU;EACtC;EACA;EACA;EACA;EACA,OAAO,sBAAQ,EAACA,KAAK,CAAC,IAAI,OAAyBA,KAAM,KAAK,QAAQ;AACxE;AANAZ;AAQA,SAAgBoD,aAAa,CAACxC,KAAU;EACtC;EACA,OAAO,sBAAQ,EAACA,KAAK,CAAC,IAAI,OAAyBA,KAAM,KAAK,QAAQ;AACxE;AAHAZ;AAKA,SAAgBqD,cAAc,CAACzC,KAAU;EACvC;EACA,OAAO,uBAAS,EAACA,KAAK,CAAC,IAAI,OAA2BA,KAAM,KAAK,SAAS;AAC5E;AAHAZ;AAKA,SAAgBsD,gBAAgB,CAC9B1C,KAAU;EAEV,OAAOuC,aAAa,CAACvC,KAAK,CAAC,IAAIwC,aAAa,CAACxC,KAAK,CAAC,IAAIyC,cAAc,CAACzC,KAAK,CAAC;AAC9E;AAJAZ;AAMA,SAAgBuD,YAAY,CAAC3C,KAAa;EACxC,IAAI;IACF4C,cAAI,CAACC,MAAM,CAAC7C,KAAK,CAAC,CAAC,CAAC;IACpB,OAAO,IAAI;GACZ,CAAC,WAAM;IACN,OAAO,KAAK;;AAEhB;AAPAZ;AASA,SAAgB0D,wBAAwB,CAACC,OAAe;EACtD;EACA;EACA,OAAOA,OAAO,CAACrB,KAAK,CAAC,KAAK,CAAC,GACvBsB,oBAAoB,CAACD,OAAO,CAAC,GAC7BE,sBAAsB,CAACF,OAAO,CAAC;AACrC;AANA3D;AAQA,SAAgB6D,sBAAsB,CAACF,OAAe;EACpD;EACA;EACA;EACA,OAAOG,0BAA0B,CAACH,OAAO,EAAE,OAAO,CAAC;AACrD;AALA3D;AAOA,SAAgB4D,oBAAoB,CAACG,GAAW;EAC9C;EACA,OAAOD,0BAA0B,CAACC,GAAG,EAAE,kBAAkB,CAAC;AAC5D;AAHA/D;AAKA;AACA;AACA,SAAS8D,0BAA0B,CAAClD,KAAa,EAAEoD,KAAa;EAC9D,IAAI1B,KAAK;EACT,OAAQA,KAAK,GAAG1B,KAAK,CAAC0B,KAAK,CAAC0B,KAAK,CAAC,EAAG;IACnC;IACA;IACApD,KAAK,GAAGA,KAAK,CAACqD,KAAK,CAAC,CAAC,EAAE3B,KAAK,CAAC4B,KAAK,GAAG,CAAC,CAAC,GAAGtD,KAAK,CAACqD,KAAK,CAAC3B,KAAK,CAAC4B,KAAK,GAAG,CAAC,CAAC;;EAExE,OAAOtD,KAAK;AACd","names":["places","dataType","typeClass","exports","maxValue","bits","maxIntegerValue","big_js_1","pow","minus","Conversion","shiftBigDown","minValue","minIntegerValue","isSafeNumber","input","scaledUp","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","isTypeValueInput","type","Object","keys","length","isEncodingTextInput","encoding","text","isContractInput","address","isFunctionExternalInput","isWrappedResult","kind","value","error","isUint8ArrayLike","Uint8Array","isPlainObject","isBase64","base64Pattern","Boolean","match","base64Length","base64","_","endingEquals","isHexString","hexStringPattern","isPrefixlessHexString","shortHexStringPattern","isByteString","byteStringPattern","isByteStringWithUnderscores","byteStringWithUnderscoresPattern","isBoxedString","isBoxedNumber","isBoxedBoolean","isBoxedPrimitive","isValidUtf16","utf8_1","encode","removeUnderscoresNumeric","numeric","removeUnderscoresHex","removeUnderscoresNoHex","removeUnderscoresWithRegex","hex","regex","slice","index"],"sourceRoot":"","sources":["../../../lib/wrap/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}