{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cleanBool = exports.countDecimalPlaces = exports.shiftBigDown = exports.shiftBigUp = exports.stringToBytes = exports.toBytes = exports.toHexString = exports.toBig = exports.toBigInt = exports.toSignedBN = exports.isBig = exports.toBN = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:conversion\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst big_js_1 = __importDefault(require(\"big.js\"));\nconst utf8_1 = __importDefault(require(\"utf8\"));\n/**\n * @param bytes - undefined | string | number | BN | Uint8Array | Big\n * @return {BN}\n */\nfunction toBN(bytes) {\n  if (bytes === undefined) {\n    return undefined;\n  } else if (typeof bytes === \"string\") {\n    return new bn_js_1.default(bytes, 16);\n  } else if (typeof bytes === \"bigint\") {\n    return new bn_js_1.default(bytes.toString(16), 16);\n  } else if (typeof bytes == \"number\" || bn_js_1.default.isBN(bytes)) {\n    return new bn_js_1.default(bytes);\n  } else if (isBig(bytes)) {\n    return new bn_js_1.default(bytes.toFixed()); //warning, better hope input is integer!\n    //note: going through string may seem silly but it's actually not terrible here,\n    //since BN is binary-based and Big is decimal-based\n    //[toFixed is like toString except it guarantees scientific notation is not used]\n  } else if (typeof bytes.reduce === \"function\") {\n    return bytes.reduce((num, byte) => num.shln(8).addn(byte), new bn_js_1.default(0));\n  }\n}\nexports.toBN = toBN;\n//Big doesnt provide this function, so we'll make one ourselves\n//HACK\nfunction isBig(input) {\n  return typeof input === \"object\" && input !== null && (input.s === 1 || input.s === -1) && typeof input.e === \"number\" && Array.isArray(input.c) &&\n  //we want to be sure this is *not* a BigNumber instead,\n  //but we can't use isBigNumber here because we don't want\n  //to import that library here, so, HACK, we'll check that\n  //it lacks a particular BigNumber method that would be meaningless\n  //for Bigs\n  !input.isFinite;\n  //(BigNumbers have this method because it supports Infinity and NaN,\n  //but Big doesn't, so this method doesn't exist, because it would\n  //be pointless)\n}\n\nexports.isBig = isBig;\n/**\n * @param bytes - Uint8Array\n * @return {BN}\n */\nfunction toSignedBN(bytes) {\n  if (bytes[0] < 0x80) {\n    // if first bit is 0\n    return toBN(bytes);\n  } else {\n    return toBN(bytes.map(b => 0xff - b)).addn(1).neg();\n  }\n}\nexports.toSignedBN = toSignedBN;\nfunction toBigInt(value) {\n  //BN is binary-based, so we convert by means of a hex string in order\n  //to avoid having to do a binary-decimal conversion and back :P\n  return !value.isNeg() ? BigInt(\"0x\" + value.toString(16)) : -BigInt(\"0x\" + value.neg().toString(16)); //can't directly make negative BigInt from hex string\n}\n\nexports.toBigInt = toBigInt;\nfunction toBig(value) {\n  //note: going through string may seem silly but it's actually not terrible here,\n  //since BN (& number) is binary-based and Big is decimal-based\n  return new big_js_1.default(value.toString());\n}\nexports.toBig = toBig;\n/**\n * @param bytes - Uint8Array | BN | bigint\n * @param padLength - number - minimum desired byte length (left-pad with zeroes)\n * @param padRight - boolean - causes padding to occur on right instead of left\n * @return {string}\n */\nfunction toHexString(bytes) {\n  let padLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let padRight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (bn_js_1.default.isBN(bytes) || typeof bytes === \"bigint\" || typeof bytes === \"number\" || isBig(bytes)) {\n    bytes = toBytes(bytes);\n  }\n  const pad = s => `${\"00\".slice(0, 2 - s.length)}${s}`;\n  //                                          0  1  2  3  4\n  //                                 0  1  2  3  4  5  6  7\n  // bytes.length:        5  -  0x(          e5 c2 aa 09 11 )\n  // length (preferred):  8  -  0x( 00 00 00 e5 c2 aa 09 11 )\n  //                                `--.---'\n  //                                     offset 3\n  if (bytes.length < padLength) {\n    let prior = bytes;\n    bytes = new Uint8Array(padLength);\n    if (padRight) {\n      //unusual case: pad on right\n      bytes.set(prior);\n    } else {\n      //usual case\n      bytes.set(prior, padLength - prior.length);\n    }\n  }\n  debug(\"bytes: %o\", bytes);\n  let string = bytes.reduce((str, byte) => `${str}${pad(byte.toString(16))}`, \"\");\n  return `0x${string}`;\n}\nexports.toHexString = toHexString;\nfunction toBytes(data) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  //note that length is a minimum output length\n  //strings will be 0-padded on left\n  //numbers/BNs will be sign-padded on left\n  //NOTE: if a number/BN is passed in that is too big for the given length,\n  //you will get an error!\n  //(note that strings passed in should be hex strings; this is not for converting\n  //generic strings to hex)\n  if (typeof data === \"bigint\") {\n    data = data.toString(16);\n  }\n  if (typeof data === \"string\") {\n    let hex = data; //renaming for clarity\n    if (hex.startsWith(\"0x\")) {\n      hex = hex.slice(2);\n    }\n    if (hex === \"\") {\n      //this special case is necessary because the match below will return null,\n      //not an empty array, when given an empty string\n      return new Uint8Array(0);\n    }\n    if (hex.length % 2 == 1) {\n      hex = `0${hex}`;\n    }\n    let bytes = new Uint8Array(hex.match(/.{2}/g).map(byte => parseInt(byte, 16)));\n    if (bytes.length < length) {\n      let prior = bytes;\n      bytes = new Uint8Array(length);\n      bytes.set(prior, length - prior.length);\n    }\n    return bytes;\n  } else {\n    // BN/Big/number case\n    if (typeof data === \"number\") {\n      data = new bn_js_1.default(data);\n    } else if (isBig(data)) {\n      //note: going through string may seem silly but it's actually not terrible here,\n      //since BN is binary-based and Big is decimal-based\n      data = new bn_js_1.default(data.toFixed());\n      //[toFixed is like toString except it guarantees scientific notation is not used]\n    }\n    //note that the argument for toTwos is given in bits\n    return data.toTwos(length * 8).toArrayLike(Uint8Array, \"be\", length);\n    //big-endian\n  }\n}\n\nexports.toBytes = toBytes;\nfunction stringToBytes(input) {\n  input = utf8_1.default.encode(input);\n  let bytes = new Uint8Array(input.length);\n  for (let i = 0; i < input.length; i++) {\n    bytes[i] = input.charCodeAt(i);\n  }\n  return bytes;\n  //NOTE: this will throw an error if the string contained malformed UTF-16!\n  //but, well, it shouldn't contain that...\n}\n\nexports.stringToBytes = stringToBytes;\n//computes value * 10**decimalPlaces\nfunction shiftBigUp(value, decimalPlaces) {\n  let newValue = new big_js_1.default(value);\n  newValue.e += decimalPlaces;\n  return newValue;\n}\nexports.shiftBigUp = shiftBigUp;\n//computes value * 10**-decimalPlaces\nfunction shiftBigDown(value, decimalPlaces) {\n  let newValue = new big_js_1.default(value);\n  newValue.e -= decimalPlaces;\n  return newValue;\n}\nexports.shiftBigDown = shiftBigDown;\nfunction countDecimalPlaces(value) {\n  return Math.max(0, value.c.length - value.e - 1);\n}\nexports.countDecimalPlaces = countDecimalPlaces;\n//converts out of range booleans to true; something of a HACK\n//NOTE: does NOT do this recursively inside structs, arrays, etc!\n//I mean, those aren't elementary and therefore aren't in the domain\n//anyway, but still\nfunction cleanBool(result) {\n  switch (result.kind) {\n    case \"value\":\n      return result;\n    case \"error\":\n      switch (result.error.kind) {\n        case \"BoolOutOfRangeError\":\n          //return true\n          return {\n            type: result.type,\n            kind: \"value\",\n            value: {\n              asBoolean: true\n            }\n          };\n        default:\n          return result;\n      }\n  }\n}\nexports.cleanBool = cleanBool;","map":{"version":3,"mappings":"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","names":["debug","toBN","bytes","undefined","bn_js_1","toString","isBN","isBig","toFixed","reduce","num","byte","shln","addn","exports","input","s","e","Array","isArray","c","isFinite","toSignedBN","map","b","neg","toBigInt","value","isNeg","BigInt","toBig","big_js_1","toHexString","padLength","padRight","toBytes","pad","slice","length","prior","Uint8Array","set","string","str","data","hex","startsWith","match","parseInt","toTwos","toArrayLike","stringToBytes","utf8_1","encode","i","charCodeAt","shiftBigUp","decimalPlaces","newValue","shiftBigDown","countDecimalPlaces","Math","max","cleanBool","result","kind","error","type","asBoolean"],"sourceRoot":"","sources":["../../lib/conversion.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}