{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:decode\");\nconst AstConstant = __importStar(require(\"./ast-constant\"));\nconst AbiData = __importStar(require(\"./abi-data\"));\nconst Compiler = __importStar(require(\"./compiler\"));\nconst Format = __importStar(require(\"./format\"));\nconst Basic = __importStar(require(\"./basic\"));\nconst Memory = __importStar(require(\"./memory\"));\nconst Special = __importStar(require(\"./special\"));\nconst Stack = __importStar(require(\"./stack\"));\nconst Storage = __importStar(require(\"./storage\"));\nconst Topic = __importStar(require(\"./topic\"));\nfunction decode(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    return Format.Utils.Circularity.tie(yield* decodeDispatch(dataType, pointer, info, options));\n  }();\n}\nexports.default = decode;\nfunction decodeDispatch(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    debug(\"type %O\", dataType);\n    debug(\"pointer %O\", pointer);\n    switch (pointer.location) {\n      case \"storage\":\n        return yield* Storage.Decode.decodeStorage(dataType, pointer, info);\n      case \"stack\":\n        return yield* Stack.Decode.decodeStack(dataType, pointer, info);\n      case \"stackliteral\":\n        return yield* Stack.Decode.decodeLiteral(dataType, pointer, info);\n      case \"definition\":\n        return yield* AstConstant.Decode.decodeConstant(dataType, pointer, info);\n      case \"special\":\n        return yield* Special.Decode.decodeSpecial(dataType, pointer, info);\n      case \"calldata\":\n      case \"eventdata\":\n      case \"returndata\":\n        return yield* AbiData.Decode.decodeAbi(dataType, pointer, info, options);\n      case \"eventtopic\":\n        return yield* Topic.Decode.decodeTopic(dataType, pointer, info, options);\n      case \"code\":\n      case \"nowhere\":\n        //currently only basic types can go in code, so we'll dispatch directly to decodeBasic\n        //(if it's a nowhere pointer, this will return an error result, of course)\n        //(also, Solidity <0.8.9 would always zero-pad immutables regardless of type,\n        //so we have to set the padding mode appropriately to allow for this)\n        return yield* Basic.Decode.decodeBasic(dataType, pointer, info, Object.assign(Object.assign({}, options), {\n          paddingMode: \"defaultOrZero\"\n        }));\n      case \"memory\":\n        //this case -- decoding something that resides *directly* in memory,\n        //rather than located via a pointer -- only comes up when decoding immutables\n        //in a constructor.  thus, we turn on the forceRightPadding option on Solidity\n        //versions prior to 0.8.9, because before then all immutables would be right-padded\n        //while in memory\n        switch (Compiler.Utils.solidityFamily(info.currentContext.compiler)) {\n          case \"0.5.x\":\n          case \"0.8.x\":\n          case \"0.8.7+\":\n            return yield* Memory.Decode.decodeMemory(dataType, pointer, info, Object.assign(Object.assign({}, options), {\n              paddingMode: \"right\"\n            }));\n          default:\n            return yield* Memory.Decode.decodeMemory(dataType, pointer, info, options);\n        }\n    }\n  }();\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA,MAAMA,KAAK,GAAG,mBAAW,EAAC,cAAc,CAAC;AAEzC;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA,SAAyBC,MAAM,CAC7BC,QAA2B,EAC3BC,OAA4B,EAC5BC,IAAiB;EAAA,IACjBC,8EAA0B,EAAE;EAAA;IAE5B,OAAOC,MAAM,CAACC,KAAK,CAACC,WAAW,CAACC,GAAG,CACjC,OAAOC,cAAc,CAACR,QAAQ,EAAEC,OAAO,EAAEC,IAAI,EAAEC,OAAO,CAAC,CACxD;EACH,CAAC;AAAA;AATDM;AAWA,SAAUD,cAAc,CACtBR,QAA2B,EAC3BC,OAA4B,EAC5BC,IAAiB;EAAA,IACjBC,8EAA0B,EAAE;EAAA;IAE5BL,KAAK,CAAC,SAAS,EAAEE,QAAQ,CAAC;IAC1BF,KAAK,CAAC,YAAY,EAAEG,OAAO,CAAC;IAE5B,QAAQA,OAAO,CAACS,QAAQ;MACtB,KAAK,SAAS;QACZ,OAAO,OAAOC,OAAO,CAACC,MAAM,CAACC,aAAa,CAACb,QAAQ,EAAEC,OAAO,EAAEC,IAAI,CAAC;MAErE,KAAK,OAAO;QACV,OAAO,OAAOY,KAAK,CAACF,MAAM,CAACG,WAAW,CAACf,QAAQ,EAAEC,OAAO,EAAEC,IAAI,CAAC;MAEjE,KAAK,cAAc;QACjB,OAAO,OAAOY,KAAK,CAACF,MAAM,CAACI,aAAa,CAAChB,QAAQ,EAAEC,OAAO,EAAEC,IAAI,CAAC;MAEnE,KAAK,YAAY;QACf,OAAO,OAAOe,WAAW,CAACL,MAAM,CAACM,cAAc,CAAClB,QAAQ,EAAEC,OAAO,EAAEC,IAAI,CAAC;MAE1E,KAAK,SAAS;QACZ,OAAO,OAAOiB,OAAO,CAACP,MAAM,CAACQ,aAAa,CAACpB,QAAQ,EAAEC,OAAO,EAAEC,IAAI,CAAC;MAErE,KAAK,UAAU;MACf,KAAK,WAAW;MAChB,KAAK,YAAY;QACf,OAAO,OAAOmB,OAAO,CAACT,MAAM,CAACU,SAAS,CAACtB,QAAQ,EAAEC,OAAO,EAAEC,IAAI,EAAEC,OAAO,CAAC;MAE1E,KAAK,YAAY;QACf,OAAO,OAAOoB,KAAK,CAACX,MAAM,CAACY,WAAW,CAACxB,QAAQ,EAAEC,OAAO,EAAEC,IAAI,EAAEC,OAAO,CAAC;MAE1E,KAAK,MAAM;MACX,KAAK,SAAS;QACZ;QACA;QACA;QACA;QACA,OAAO,OAAOsB,KAAK,CAACb,MAAM,CAACc,WAAW,CAAC1B,QAAQ,EAAEC,OAAO,EAAEC,IAAI,kCACzDC,OAAO;UACVwB,WAAW,EAAE;QAAe,GAC5B;MAEJ,KAAK,QAAQ;QACX;QACA;QACA;QACA;QACA;QACA,QAAQC,QAAQ,CAACvB,KAAK,CAACwB,cAAc,CAAC3B,IAAI,CAAC4B,cAAc,CAACC,QAAQ,CAAC;UACjE,KAAK,OAAO;UACZ,KAAK,OAAO;UACZ,KAAK,QAAQ;YACX,OAAO,OAAOC,MAAM,CAACpB,MAAM,CAACqB,YAAY,CAACjC,QAAQ,EAAEC,OAAO,EAAEC,IAAI,kCAC3DC,OAAO;cACVwB,WAAW,EAAE;YAAO,GACpB;UACJ;YACE,OAAO,OAAOK,MAAM,CAACpB,MAAM,CAACqB,YAAY,CACtCjC,QAAQ,EACRC,OAAO,EACPC,IAAI,EACJC,OAAO,CACR;QAAC;IACL;EAEP,CAAC;AAAA","names":["debug","decode","dataType","pointer","info","options","Format","Utils","Circularity","tie","decodeDispatch","exports","location","Storage","Decode","decodeStorage","Stack","decodeStack","decodeLiteral","AstConstant","decodeConstant","Special","decodeSpecial","AbiData","decodeAbi","Topic","decodeTopic","Basic","decodeBasic","paddingMode","Compiler","solidityFamily","currentContext","compiler","Memory","decodeMemory"],"sourceRoot":"","sources":["../../lib/decode.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}