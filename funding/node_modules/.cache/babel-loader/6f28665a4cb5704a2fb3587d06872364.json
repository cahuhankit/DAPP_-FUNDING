{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.storageSize = exports.getStateAllocations = exports.getStorageAllocations = exports.UnknownBaseContractIdError = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:storage:allocate\");\nconst Compiler = __importStar(require(\"../../compiler\"));\nconst Common = __importStar(require(\"../../common\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst Ast = __importStar(require(\"../../ast\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst Format = __importStar(require(\"../../format\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst partition_1 = __importDefault(require(\"lodash/partition\"));\nclass UnknownBaseContractIdError extends Error {\n  constructor(derivedId, derivedName, derivedKind, baseId) {\n    const message = `Cannot locate base contract ID ${baseId} of ${derivedKind} ${derivedName} (ID ${derivedId})`;\n    super(message);\n    this.name = \"UnknownBaseContractIdError\";\n    this.derivedId = derivedId;\n    this.derivedName = derivedName;\n    this.derivedKind = derivedKind;\n    this.baseId = baseId;\n  }\n}\nexports.UnknownBaseContractIdError = UnknownBaseContractIdError;\n//contracts contains only the contracts to be allocated; any base classes not\n//being allocated should just be in referenceDeclarations\nfunction getStorageAllocations(userDefinedTypesByCompilation) {\n  let allocations = {};\n  for (const compilation of Object.values(userDefinedTypesByCompilation)) {\n    const {\n      compiler,\n      types: userDefinedTypes\n    } = compilation;\n    for (const dataType of Object.values(compilation.types)) {\n      if (dataType.typeClass === \"struct\") {\n        try {\n          allocations = allocateStruct(dataType, userDefinedTypes, allocations, compiler);\n        } catch (_a) {\n          //if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n          //note: a better way of handling this would probably be to *mark* it\n          //as failed rather than throwing an exception as that would lead to less\n          //recomputation, but this is simpler and I don't think the recomputation\n          //should really be a problem\n        }\n      }\n    }\n  }\n  return allocations;\n}\nexports.getStorageAllocations = getStorageAllocations;\n/**\n * This function gets allocations for the state variables of the contracts;\n * this is distinct from getStorageAllocations, which gets allocations for\n * storage structs.\n *\n * While mostly state variables are kept in storage, constant ones are not.\n * And immutable ones, once those are introduced, will be kept in code!\n * (But those don't exist yet so this function doesn't handle them yet.)\n */\nfunction getStateAllocations(contracts, referenceDeclarations, userDefinedTypes, storageAllocations) {\n  let existingAllocations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  let allocations = existingAllocations;\n  for (const contractInfo of contracts) {\n    let {\n      contractNode: contract,\n      immutableReferences,\n      compiler,\n      compilationId\n    } = contractInfo;\n    try {\n      allocations = allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations[compilationId], userDefinedTypes, storageAllocations, allocations);\n    } catch (_a) {\n      //we're just going to allow failure here and catch the problem elsewhere\n    }\n  }\n  return allocations;\n}\nexports.getStateAllocations = getStateAllocations;\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations, compiler) {\n  //NOTE: dataType here should be a *stored* type!\n  //it is up to the caller to take care of this\n  return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations, compiler);\n}\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations, compiler) {\n  let offset = 0; //will convert to BN when placing in slot\n  let index = Evm.Utils.WORD_SIZE - 1;\n  //don't allocate things that have already been allocated\n  if (parentId in existingAllocations) {\n    return existingAllocations;\n  }\n  let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n  //otherwise, we need to allocate\n  let memberAllocations = [];\n  for (const member of members) {\n    let size;\n    ({\n      size,\n      allocations\n    } = storageSizeAndAllocate(member.type, userDefinedTypes, allocations, compiler));\n    //if it's sized in words (and we're not at the start of slot) we need to start on a new slot\n    //if it's sized in bytes but there's not enough room, we also need a new slot\n    if (Utils.isWordsLength(size) ? index < Evm.Utils.WORD_SIZE - 1 : size.bytes > index + 1) {\n      index = Evm.Utils.WORD_SIZE - 1;\n      offset += 1;\n    }\n    //otherwise, we remain in place\n    let range;\n    if (Utils.isWordsLength(size)) {\n      //words case\n      range = {\n        from: {\n          slot: {\n            offset: new bn_js_1.default(offset) //start at the current slot...\n          },\n\n          index: 0 //...at the beginning of the word.\n        },\n\n        to: {\n          slot: {\n            offset: new bn_js_1.default(offset + size.words - 1) //end at the current slot plus # of words minus 1...\n          },\n\n          index: Evm.Utils.WORD_SIZE - 1 //...at the end of the word.\n        }\n      };\n    } else {\n      //bytes case\n      range = {\n        from: {\n          slot: {\n            offset: new bn_js_1.default(offset) //start at the current slot...\n          },\n\n          index: index - (size.bytes - 1) //...early enough to fit what's being allocated.\n        },\n\n        to: {\n          slot: {\n            offset: new bn_js_1.default(offset) //end at the current slot...\n          },\n\n          index: index //...at the current position.\n        }\n      };\n    }\n\n    memberAllocations.push({\n      name: member.name,\n      type: member.type,\n      pointer: {\n        location: \"storage\",\n        range\n      }\n    });\n    //finally, adjust the current position.\n    //if it was sized in words, move down that many slots and reset position w/in slot\n    if (Utils.isWordsLength(size)) {\n      offset += size.words;\n      index = Evm.Utils.WORD_SIZE - 1;\n    }\n    //if it was sized in bytes, move down an appropriate number of bytes.\n    else {\n      index -= size.bytes;\n      //but if this puts us into the next word, move to the next word.\n      if (index < 0) {\n        index = Evm.Utils.WORD_SIZE - 1;\n        offset += 1;\n      }\n    }\n  }\n  //finally, let's determine the overall siz; we're dealing with a struct, so\n  //the size is measured in words\n  //it's one plus the last word used, i.e. one plus the current word... unless the\n  //current word remains entirely unused, then it's just the current word\n  //SPECIAL CASE: if *nothing* has been used, allocate a single word (that's how\n  //empty structs behave in versions where they're legal)\n  let totalSize;\n  if (index === Evm.Utils.WORD_SIZE - 1 && offset !== 0) {\n    totalSize = {\n      words: offset\n    };\n  } else {\n    totalSize = {\n      words: offset + 1\n    };\n  }\n  //having made our allocation, let's add it to allocations!\n  allocations[parentId] = {\n    members: memberAllocations,\n    size: totalSize\n  };\n  //...and we're done!\n  return allocations;\n}\nfunction getStateVariables(contractNode) {\n  // process for state variables\n  return contractNode.nodes.filter(node => node.nodeType === \"VariableDeclaration\" && node.stateVariable);\n}\nfunction allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations, userDefinedTypes, storageAllocations) {\n  let existingAllocations = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n  //we're going to do a 2-deep clone here\n  let allocations = Object.assign({}, ...Object.entries(existingAllocations).map(_ref => {\n    let [compilationId, compilationAllocations] = _ref;\n    return {\n      [compilationId]: Object.assign({}, compilationAllocations)\n    };\n  }));\n  if (!immutableReferences) {\n    immutableReferences = {}; //also, let's set this up for convenience\n  }\n  //base contracts are listed from most derived to most base, so we\n  //have to reverse before processing, but reverse() is in place, so we\n  //clone with slice first\n  let linearizedBaseContractsFromBase = contract.linearizedBaseContracts.slice().reverse();\n  //first, let's get all the variables under consideration\n  let variables = [].concat(...linearizedBaseContractsFromBase.map(id => {\n    let baseNode = referenceDeclarations[id];\n    if (baseNode === undefined) {\n      throw new UnknownBaseContractIdError(contract.id, contract.name, contract.contractKind, id);\n    }\n    return getStateVariables(baseNode).map(definition => ({\n      definition,\n      definedIn: baseNode\n    }));\n  }));\n  //just in case the constant field ever gets removed\n  const isConstant = definition => definition.constant || definition.mutability === \"constant\";\n  //now: we split the variables into storage, constant, and code\n  let [constantVariables, variableVariables] = (0, partition_1.default)(variables, variable => isConstant(variable.definition));\n  //why use this function instead of just checking\n  //definition.mutability?\n  //because of a bug in Solidity 0.6.5 that causes the mutability field\n  //not to exist.  So, we also have to check against immutableReferences.\n  const isImmutable = definition => definition.mutability === \"immutable\" || definition.id.toString() in immutableReferences;\n  let [immutableVariables, storageVariables] = (0, partition_1.default)(variableVariables, variable => isImmutable(variable.definition));\n  //transform storage variables into data types\n  const storageVariableTypes = storageVariables.map(variable => ({\n    name: variable.definition.name,\n    type: Ast.Import.definitionToType(variable.definition, compilationId, compiler)\n  }));\n  //let's allocate the storage variables using a fictitious ID\n  const id = \"-1\";\n  const storageVariableStorageAllocations = allocateMembers(id, storageVariableTypes, userDefinedTypes, storageAllocations, compiler)[id];\n  //transform to new format\n  const storageVariableAllocations = storageVariables.map((_ref2, index) => {\n    let {\n      definition,\n      definedIn\n    } = _ref2;\n    return {\n      definition,\n      definedIn,\n      compilationId,\n      pointer: storageVariableStorageAllocations.members[index].pointer\n    };\n  });\n  //now let's create allocations for the immutables\n  let immutableVariableAllocations = immutableVariables.map(_ref3 => {\n    let {\n      definition,\n      definedIn\n    } = _ref3;\n    let references = immutableReferences[definition.id.toString()] || [];\n    let pointer;\n    if (references.length === 0) {\n      pointer = {\n        location: \"nowhere\"\n      };\n    } else {\n      pointer = {\n        location: \"code\",\n        start: references[0].start,\n        length: references[0].length\n      };\n    }\n    return {\n      definition,\n      definedIn,\n      compilationId,\n      pointer\n    };\n  });\n  //and let's create allocations for the constants\n  let constantVariableAllocations = constantVariables.map(_ref4 => {\n    let {\n      definition,\n      definedIn\n    } = _ref4;\n    return {\n      definition,\n      definedIn,\n      compilationId,\n      pointer: {\n        location: \"definition\",\n        definition: definition.value\n      }\n    };\n  });\n  //now, reweave the three together\n  let contractAllocation = [];\n  for (let variable of variables) {\n    let arrayToGrabFrom = isConstant(variable.definition) ? constantVariableAllocations : isImmutable(variable.definition) ? immutableVariableAllocations : storageVariableAllocations;\n    contractAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n  }\n  //finally, set things and return\n  if (!allocations[compilationId]) {\n    allocations[compilationId] = {};\n  }\n  allocations[compilationId][contract.id] = {\n    members: contractAllocation\n  };\n  return allocations;\n}\n//NOTE: This wrapper function is for use in decoding ONLY, after allocation is done.\n//The allocator should (and does) instead use a direct call to storageSizeAndAllocate,\n//not to the wrapper, because it may need the allocations returned.\nfunction storageSize(dataType, userDefinedTypes, allocations, compiler) {\n  return storageSizeAndAllocate(dataType, userDefinedTypes, allocations, compiler).size;\n}\nexports.storageSize = storageSize;\nfunction storageSizeAndAllocate(dataType, userDefinedTypes, existingAllocations, compiler) {\n  //we'll only directly handle reference types here;\n  //direct types will be handled by dispatching to Basic.Allocate.byteLength\n  //in the default case\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      {\n        switch (dataType.kind) {\n          case \"static\":\n            //really a basic type :)\n            return {\n              size: {\n                bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n              },\n              allocations: existingAllocations\n            };\n          case \"dynamic\":\n            return {\n              size: {\n                words: 1\n              },\n              allocations: existingAllocations\n            };\n        }\n      }\n    case \"string\":\n    case \"mapping\":\n      return {\n        size: {\n          words: 1\n        },\n        allocations: existingAllocations\n      };\n    case \"array\":\n      {\n        switch (dataType.kind) {\n          case \"dynamic\":\n            return {\n              size: {\n                words: 1\n              },\n              allocations: existingAllocations\n            };\n          case \"static\":\n            //static array case\n            const length = dataType.length.toNumber(); //warning! but if it's too big we have a problem\n            if (length === 0) {\n              //in versions of Solidity where it's legal, arrays of length 0 still take up 1 word\n              return {\n                size: {\n                  words: 1\n                },\n                allocations: existingAllocations\n              };\n            }\n            let {\n              size: baseSize,\n              allocations\n            } = storageSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);\n            if (!Utils.isWordsLength(baseSize)) {\n              //bytes case\n              const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n              debug(\"length %o\", length);\n              const numWords = Math.ceil(length / perWord);\n              return {\n                size: {\n                  words: numWords\n                },\n                allocations\n              };\n            } else {\n              //words case\n              return {\n                size: {\n                  words: baseSize.words * length\n                },\n                allocations\n              };\n            }\n        }\n      }\n    case \"struct\":\n      {\n        let allocations = existingAllocations;\n        let allocation = allocations[dataType.id]; //may be undefined!\n        if (allocation === undefined) {\n          //if we don't find an allocation, we'll have to do the allocation ourselves\n          const storedType = userDefinedTypes[dataType.id];\n          if (!storedType) {\n            throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n          }\n          allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n          allocation = allocations[dataType.id];\n        }\n        //having found our allocation, we can just look up its size\n        return {\n          size: allocation.size,\n          allocations\n        };\n      }\n    case \"userDefinedValueType\":\n      if (Compiler.Utils.solidityFamily(compiler) === \"0.8.7+\") {\n        //UDVTs were introduced in Solidity 0.8.8.  However, in that version,\n        //and that version only, they have a bug where they always take up a\n        //full word in storage regardless of the size of the underlying type.\n        return {\n          size: {\n            words: 1\n          },\n          allocations: existingAllocations\n        };\n      }\n    //otherwise, treat them normally\n    //DELIBERATE FALL-TRHOUGH\n    default:\n      //otherwise, it's a direct type\n      return {\n        size: {\n          bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n        },\n        allocations: existingAllocations\n      };\n  }\n}","map":{"version":3,"mappings":"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","names":["debug","UnknownBaseContractIdError","Error","constructor","derivedId","derivedName","derivedKind","baseId","message","name","exports","getStorageAllocations","userDefinedTypesByCompilation","allocations","compilation","Object","values","compiler","types","userDefinedTypes","dataType","typeClass","allocateStruct","getStateAllocations","contracts","referenceDeclarations","storageAllocations","existingAllocations","contractInfo","contractNode","contract","immutableReferences","compilationId","allocateContractState","allocateMembers","id","memberTypes","parentId","members","offset","index","Evm","Utils","WORD_SIZE","memberAllocations","member","size","storageSizeAndAllocate","type","isWordsLength","bytes","range","from","slot","bn_js_1","to","words","push","pointer","location","totalSize","getStateVariables","nodes","filter","node","nodeType","stateVariable","assign","entries","map","compilationAllocations","linearizedBaseContractsFromBase","linearizedBaseContracts","slice","reverse","variables","concat","baseNode","undefined","contractKind","definition","definedIn","isConstant","constant","mutability","constantVariables","variableVariables","variable","isImmutable","toString","immutableVariables","storageVariables","storageVariableTypes","Ast","Import","definitionToType","storageVariableStorageAllocations","storageVariableAllocations","immutableVariableAllocations","references","length","start","constantVariableAllocations","value","contractAllocation","arrayToGrabFrom","shift","storageSize","kind","Basic","Allocate","byteLength","toNumber","baseSize","baseType","perWord","Math","floor","numWords","ceil","allocation","storedType","Common","UnknownUserDefinedTypeError","Format","Types","typeString","Compiler","solidityFamily"],"sourceRoot":"","sources":["../../../../lib/storage/allocate/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}