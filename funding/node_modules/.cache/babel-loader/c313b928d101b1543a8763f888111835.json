{"ast":null,"code":"\"use strict\";\n\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeMemoryReferenceByAddress = exports.decodeMemory = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:memory:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst errors_1 = require(\"../../errors\");\nfunction decodeMemory(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    if (Format.Types.isReferenceType(dataType)) {\n      if ((0, allocate_1.isSkippedInMemoryStructs)(dataType)) {\n        //special case; these types are always empty in memory\n        return decodeMemorySkippedType(dataType);\n      } else {\n        return yield* decodeMemoryReferenceByAddress(dataType, pointer, info, options);\n      }\n    } else {\n      return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n    }\n  }();\n}\nexports.decodeMemory = decodeMemory;\nfunction decodeMemorySkippedType(dataType) {\n  switch (dataType.typeClass) {\n    case \"mapping\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: []\n      };\n    case \"array\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: []\n      };\n    //other cases should not arise!\n  }\n}\n\nfunction decodeMemoryReferenceByAddress(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    const {\n      state\n    } = info;\n    const memoryVisited = options.memoryVisited || [];\n    debug(\"pointer %o\", pointer);\n    let rawValue;\n    try {\n      rawValue = yield* (0, read_1.default)(pointer, state);\n    } catch (error) {\n      return (0, errors_1.handleDecodingError)(dataType, error);\n    }\n    let startPositionAsBN = Conversion.toBN(rawValue);\n    let startPosition;\n    try {\n      startPosition = startPositionAsBN.toNumber();\n    } catch (_a) {\n      return {\n        //again with the TS failures...\n        type: dataType,\n        kind: \"error\",\n        error: {\n          kind: \"OverlargePointersNotImplementedError\",\n          pointerAsBN: startPositionAsBN\n        }\n      };\n    }\n    //startPosition may get modified later, so let's save the current\n    //value for circularity detection purposes\n    const objectPosition = startPosition;\n    let rawLength;\n    let lengthAsBN;\n    let length;\n    let seenPreviously;\n    switch (dataType.typeClass) {\n      case \"bytes\":\n      case \"string\":\n        //initial word contains length\n        try {\n          rawLength = yield* (0, read_1.default)({\n            location: \"memory\",\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state);\n        } catch (error) {\n          return (0, errors_1.handleDecodingError)(dataType, error);\n        }\n        lengthAsBN = Conversion.toBN(rawLength);\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_b) {\n          return {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN\n            }\n          };\n        }\n        let childPointer = {\n          location: \"memory\",\n          start: startPosition + Evm.Utils.WORD_SIZE,\n          length\n        };\n        return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info);\n      case \"array\":\n        {\n          //first: circularity check!\n          seenPreviously = memoryVisited.indexOf(objectPosition);\n          if (seenPreviously !== -1) {\n            return {\n              type: dataType,\n              kind: \"value\",\n              reference: seenPreviously + 1,\n              value: [] //will be fixed later by the tie function\n            };\n          }\n          //otherwise, decode as normal\n          if (dataType.kind === \"dynamic\") {\n            //initial word contains array length\n            try {\n              rawLength = yield* (0, read_1.default)({\n                location: \"memory\",\n                start: startPosition,\n                length: Evm.Utils.WORD_SIZE\n              }, state);\n            } catch (error) {\n              return (0, errors_1.handleDecodingError)(dataType, error);\n            }\n            lengthAsBN = Conversion.toBN(rawLength);\n            startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n            //to next word, as first word was used for length\n          } else {\n            lengthAsBN = dataType.length;\n          }\n          try {\n            length = lengthAsBN.toNumber();\n          } catch (_c) {\n            return {\n              type: dataType,\n              kind: \"error\",\n              error: {\n                kind: \"OverlongArraysAndStringsNotImplementedError\",\n                lengthAsBN\n              }\n            };\n          }\n          let memoryNowVisited = [objectPosition, ...memoryVisited];\n          let baseType = dataType.baseType;\n          let decodedChildren = [];\n          for (let index = 0; index < length; index++) {\n            decodedChildren.push(yield* decodeMemory(baseType, {\n              location: \"memory\",\n              start: startPosition + index * Evm.Utils.WORD_SIZE,\n              length: Evm.Utils.WORD_SIZE\n            }, info, {\n              memoryVisited: memoryNowVisited\n            }));\n          }\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: decodedChildren\n          };\n        }\n      case \"struct\":\n        {\n          //first: circularity check!\n          seenPreviously = memoryVisited.indexOf(objectPosition);\n          if (seenPreviously !== -1) {\n            return {\n              type: dataType,\n              kind: \"value\",\n              reference: seenPreviously + 1,\n              value: [] //will be fixed later by the tie function\n            };\n          }\n          //otherwise, decode as normal\n          const {\n            allocations: {\n              memory: allocations\n            }\n          } = info;\n          const typeId = dataType.id;\n          const structAllocation = allocations[typeId];\n          if (!structAllocation) {\n            return {\n              type: dataType,\n              kind: \"error\",\n              error: {\n                kind: \"UserDefinedTypeNotFoundError\",\n                type: dataType\n              }\n            };\n          }\n          debug(\"structAllocation %O\", structAllocation);\n          let memoryNowVisited = [objectPosition, ...memoryVisited];\n          let decodedMembers = [];\n          for (let index = 0; index < structAllocation.members.length; index++) {\n            const memberAllocation = structAllocation.members[index];\n            const memberPointer = memberAllocation.pointer;\n            const childPointer = {\n              location: \"memory\",\n              start: startPosition + memberPointer.start,\n              length: memberPointer.length //always equals WORD_SIZE or 0\n            };\n\n            let memberName = memberAllocation.name;\n            let memberType = Format.Types.specifyLocation(memberAllocation.type, \"memory\");\n            decodedMembers.push({\n              name: memberName,\n              value: yield* decodeMemory(memberType, childPointer, info, {\n                memoryVisited: memoryNowVisited\n              })\n            });\n          }\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: decodedMembers\n          };\n        }\n    }\n  }();\n}\nexports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;","map":{"version":3,"mappings":"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","names":["debug","decodeMemory","dataType","pointer","info","options","Format","Types","isReferenceType","decodeMemorySkippedType","decodeMemoryReferenceByAddress","Basic","Decode","decodeBasic","exports","typeClass","type","kind","value","state","memoryVisited","rawValue","error","startPositionAsBN","Conversion","toBN","startPosition","toNumber","pointerAsBN","objectPosition","rawLength","lengthAsBN","length","seenPreviously","location","start","Evm","Utils","WORD_SIZE","childPointer","Bytes","decodeBytes","indexOf","reference","memoryNowVisited","baseType","decodedChildren","index","push","allocations","memory","typeId","id","structAllocation","decodedMembers","members","memberAllocation","memberPointer","memberName","name","memberType","specifyLocation"],"sourceRoot":"","sources":["../../../../lib/memory/decode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}