{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\nconst BinaryParseStream = require('../vendor/binary-parse-stream');\nconst Tagged = require('./tagged');\nconst Simple = require('./simple');\nconst utils = require('./utils');\nconst bignumber = require('bignumber.js').BigNumber;\nconst NoFilter = require('nofilter');\nconst constants = require('./constants');\n// Do not fix this if you want to support node v4\nconst MT = constants.MT;\nconst NUMBYTES = constants.NUMBYTES;\nconst SIMPLE = constants.SIMPLE;\nconst SYMS = constants.SYMS;\nconst BI = utils.bigIntize(constants.BI);\nconst BN = constants.BN;\nconst COUNT = Symbol('count');\nconst PENDING_KEY = Symbol('pending_key');\nconst MAJOR = Symbol('major type');\nconst ERROR = Symbol('error');\nconst NOT_FOUND = Symbol('not found');\nfunction parentArray(parent, typ, count) {\n  const a = [];\n  a[COUNT] = count;\n  a[SYMS.PARENT] = parent;\n  a[MAJOR] = typ;\n  return a;\n}\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter();\n  b[COUNT] = -1;\n  b[SYMS.PARENT] = parent;\n  b[MAJOR] = typ;\n  return b;\n}\n\n/**\n * @param {Buffer} v\n * @private\n */\nfunction _tag_2(v) {\n  return utils.bufferToBigInt(v);\n}\n\n/**\n * @param {BigInt} v\n * @private\n */\nfunction _tag_3(v) {\n  // avoid syntax error on old runtimes\n  return BI.MINUS_ONE - utils.bufferToBigInt(v);\n}\n\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends {BinaryParseStream}\n */\nclass Decoder extends BinaryParseStream {\n  /**\n   * Create a parsing stream.\n   *\n   * @param {object} [options={}]\n   * @param {number} [options.max_depth=-1] - the maximum depth to parse.\n   *   Use -1 for \"until you run out of memory\".  Set this to a finite\n   *   positive number for un-trusted inputs.  Most standard inputs won't nest\n   *   more than 100 or so levels; I've tested into the millions before\n   *   running out of memory.\n   * @param {object} [options.tags] - mapping from tag number to function(v),\n   *   where v is the decoded value that comes after the tag, and where the\n   *   function returns the correctly-created value for that tag.\n   * @param {boolean} [options.bigint=false] generate JavaScript BigInt's\n   *   instead of BigNumbers, when possible.  TODO: when BigInt's are\n   *   more prevalent, change this to default to the value of cbor.hasBigInt.\n   */\n  constructor(options) {\n    options = options || {};\n    const tags = options.tags;\n    delete options.tags;\n    const max_depth = options.max_depth != null ? options.max_depth : -1;\n    delete options.max_depth;\n    const bigI = utils.hasBigInt ? !!options.bigint : false;\n    delete options.bigint;\n    super(options);\n    this.running = true;\n    this.max_depth = max_depth;\n    this.tags = tags;\n    if (bigI) {\n      if (this.tags == null) {\n        this.tags = {};\n      }\n      if (this.tags[2] == null) {\n        this.tags[2] = _tag_2;\n      }\n      if (this.tags[3] == null) {\n        this.tags[3] = _tag_3;\n      }\n    }\n  }\n\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @static\n   * @param {any} val - the value to check\n   * @returns {any} the corrected value\n   *\n   * @example\n   * myDecoder.on('data', function(val) {\n   *   val = Decoder.nullcheck(val);\n   *   ...\n   * });\n   */\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null;\n      case SYMS.UNDEFINED:\n        return undefined;\n      case NOT_FOUND:\n        throw new Error('Value not found');\n      default:\n        return val;\n    }\n  }\n\n  /**\n   * @typedef DecodeOptions\n   * @property {string} [encoding='hex'] - The encoding of the input.\n   *   Ignored if input is a Buffer.\n   */\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw an\n   * exception if the input is not valid CBOR.\n   *\n   * @static\n   * @param {string|Buffer|stream.Readable} input\n   * @param {DecodeOptions|string} [options] Options\n   * @returns {any} - the decoded value\n   */\n  static decodeFirstSync(input, options) {\n    options = options || {\n      encoding: 'hex'\n    };\n    let opts = {};\n    let encod;\n    switch (typeof options) {\n      case 'string':\n        encod = options;\n        break;\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding;\n        delete opts.encoding;\n        break;\n    }\n    const c = new Decoder(opts);\n    const s = input instanceof stream.Readable ? input : new NoFilter(input, encod != null ? encod : utils.guessEncoding(input));\n\n    // for/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n    const parser = c._parse();\n    let state = parser.next();\n    while (!state.done) {\n      const b = s.read(state.value);\n      if (b == null || b.length !== state.value) {\n        throw new Error('Insufficient data');\n      }\n      state = parser.next(b);\n    }\n    const val = Decoder.nullcheck(state.value);\n    if (s.length > 0) {\n      const nextByte = s.read(1);\n      s.unshift(nextByte);\n      const er = new Error('Unexpected data: 0x' + nextByte[0].toString(16));\n      er.value = val;\n      throw er;\n    }\n    return val;\n  }\n\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @static\n   * @param {string|Buffer|stream.Readable} input\n   * @param {DecodeOptions|string} [options] Options or encoding string\n   * @returns {Array} - Array of all found items\n   */\n  static decodeAllSync(input, options) {\n    options = options || {\n      encoding: 'hex'\n    };\n    let opts = {};\n    let encod;\n    switch (typeof options) {\n      case 'string':\n        encod = options;\n        break;\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding;\n        delete opts.encoding;\n    }\n    const c = new Decoder(opts);\n    const s = input instanceof stream.Readable ? input : new NoFilter(input, encod != null ? encod : utils.guessEncoding(input));\n    const res = [];\n    while (s.length > 0) {\n      const parser = c._parse();\n      let state = parser.next();\n      while (!state.done) {\n        const b = s.read(state.value);\n        if (b == null || b.length !== state.value) {\n          throw new Error('Insufficient data');\n        }\n        state = parser.next(b);\n      }\n      res.push(Decoder.nullcheck(state.value));\n    }\n    return res;\n  }\n\n  /**\n   * @callback decodeCallback\n   * @param {Error} [error] - if one was generated\n   * @param {any} [value] - the decoded value\n   */\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are more\n   * bytes left over at the end, and optionally if there were no valid CBOR\n   * bytes in the input.  Emits the {Decoder.NOT_FOUND} Symbol in the callback\n   * if no data was found and the `required` option is false.\n   *\n   * @static\n   * @param {string|Buffer} input - the input to parse\n   * @param {DecodeOptions|decodeCallback|string} [options] - options\n   * @param {decodeCallback} [cb] callback\n   * @returns {Promise<any>} returned even if callback is specified\n   */\n  static decodeFirst(input, options, cb) {\n    let opts = {};\n    let required = false;\n    let encod = 'hex';\n    switch (typeof options) {\n      case 'function':\n        cb = options;\n        encod = utils.guessEncoding(input);\n        break;\n      case 'string':\n        encod = options;\n        break;\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n        delete opts.encoding;\n        required = opts.required != null ? opts.required : false;\n        delete opts.required;\n    }\n    const c = new Decoder(opts);\n    let v = NOT_FOUND;\n    const p = new Promise((resolve, reject) => {\n      c.on('data', val => {\n        v = Decoder.nullcheck(val);\n        c.close();\n      });\n      c.once('error', er => {\n        if (v !== NOT_FOUND) {\n          er.value = v;\n        }\n        v = ERROR;\n        c.close();\n        return reject(er);\n      });\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'));\n            } else {\n              return resolve(v);\n            }\n          case ERROR:\n            return void 0;\n          default:\n            return resolve(v);\n        }\n      });\n    });\n    if (typeof cb === 'function') {\n      p.then(v => cb(null, v), cb);\n    }\n    c.end(input, encod);\n    return p;\n  }\n\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error - if one was generated\n   * @param {Array} value - all of the decoded values, wrapped in an Array\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @static\n   * @param {(string|Buffer)} input - the input to parse\n   * @param {(string|Object)} options - Decoding options.\n   *   If string, the input encoding.\n   * @param {decodeAllCallback} cb callback\n   * @returns {Promise<Array>} even if callback is specified\n   */\n  static decodeAll(input, options, cb) {\n    let opts = {};\n    let encod = 'hex';\n    switch (typeof options) {\n      case 'function':\n        cb = options;\n        encod = utils.guessEncoding(input);\n        break;\n      case 'string':\n        encod = options;\n        break;\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n        delete opts.encoding;\n    }\n    const c = new Decoder(opts);\n    const vals = [];\n    c.on('data', val => {\n      return vals.push(Decoder.nullcheck(val));\n    });\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject);\n      c.on('end', () => resolve(vals));\n    });\n    if (typeof cb === 'function') {\n      p.then(v => cb(null, v), cb);\n    }\n    c.end(input, encod);\n    return p;\n  }\n\n  /**\n   * Stop processing\n   */\n  close() {\n    this.running = false;\n    this.__fresh = true;\n  }\n  *_parse() {\n    let parent = null;\n    let depth = 0;\n    let val = null;\n    while (true) {\n      if (this.max_depth >= 0 && depth > this.max_depth) {\n        throw new Error('Maximum depth ' + this.max_depth + ' exceeded');\n      }\n      const octet = (yield 1)[0];\n      if (!this.running) {\n        throw new Error('Unexpected data: 0x' + octet.toString(16));\n      }\n      const mt = octet >> 5;\n      const ai = octet & 0x1f;\n      const parent_major = parent != null ? parent[MAJOR] : undefined;\n      const parent_length = parent != null ? parent.length : undefined;\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length);\n          val = (yield 1)[0];\n          break;\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT:\n          const numbytes = 1 << ai - 24;\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length);\n          const buf = yield numbytes;\n          val = mt === MT.SIMPLE_FLOAT ? buf : utils.parseCBORint(ai, buf);\n          break;\n        case 28:\n        case 29:\n        case 30:\n          this.running = false;\n          throw new Error('Additional info not implemented: ' + ai);\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`);\n          }\n          val = -1;\n          break;\n        default:\n          val = ai;\n      }\n      switch (mt) {\n        case MT.POS_INT:\n          // val already decoded\n          break;\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BN.NEG_MAX;\n          } else if (val instanceof bignumber) {\n            val = BN.MINUS_ONE.minus(val);\n          } else {\n            val = -1 - val;\n          }\n          break;\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = mt === MT.BYTE_STRING ? Buffer.allocUnsafe(0) : '';\n              break;\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentBufferStream(parent, mt);\n              depth++;\n              continue;\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = yield val;\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val);\n              }\n          }\n          break;\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = mt === MT.MAP ? {} : [];\n              break;\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentArray(parent, mt, -1);\n              depth++;\n              continue;\n            default:\n              this.emit('start', mt, val, parent_major, parent_length);\n              parent = parentArray(parent, mt, val * (mt - 3));\n              depth++;\n              continue;\n          }\n          break;\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length);\n          parent = parentArray(parent, mt, 1);\n          parent.push(val);\n          depth++;\n          continue;\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if (ai === NUMBYTES.ONE && val < 32) {\n              throw new Error(`Invalid two-byte encoding of simple value ${val}`);\n            }\n            const hasParent = parent != null;\n            val = Simple.decode(val, hasParent, hasParent && parent[COUNT] < 0);\n          } else {\n            val = utils.parseCBORfloat(val);\n          }\n      }\n      this.emit('value', val, parent_major, parent_length, ai);\n      let again = false;\n      while (parent != null) {\n        switch (false) {\n          case val !== SYMS.BREAK:\n            parent[COUNT] = 1;\n            break;\n          case !Array.isArray(parent):\n            parent.push(val);\n            break;\n          case !(parent instanceof NoFilter):\n            const pm = parent[MAJOR];\n            if (pm != null && pm !== mt) {\n              this.running = false;\n              throw new Error('Invalid major type in indefinite encoding');\n            }\n            parent.write(val);\n        }\n        if (--parent[COUNT] !== 0) {\n          again = true;\n          break;\n        }\n        --depth;\n        delete parent[COUNT];\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent;\n              break;\n            case MT.MAP:\n              let allstrings = true;\n              if (parent.length % 2 !== 0) {\n                throw new Error('Invalid map length: ' + parent.length);\n              }\n              for (let i = 0, len = parent.length; i < len; i += 2) {\n                if (typeof parent[i] !== 'string') {\n                  allstrings = false;\n                  break;\n                }\n              }\n              if (allstrings) {\n                val = {};\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val[parent[i]] = parent[i + 1];\n                }\n              } else {\n                val = new Map();\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val.set(parent[i], parent[i + 1]);\n                }\n              }\n              break;\n            case MT.TAG:\n              const t = new Tagged(parent[0], parent[1]);\n              val = t.convert(this.tags);\n              break;\n          }\n        } else if (parent instanceof NoFilter) {\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice();\n              break;\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8');\n              break;\n          }\n        }\n        this.emit('stop', parent[MAJOR]);\n        const old = parent;\n        parent = parent[SYMS.PARENT];\n        delete old[SYMS.PARENT];\n        delete old[MAJOR];\n      }\n      if (!again) {\n        return val;\n      }\n    }\n  }\n}\nDecoder.NOT_FOUND = NOT_FOUND;\nmodule.exports = Decoder;","map":{"version":3,"names":["stream","require","BinaryParseStream","Tagged","Simple","utils","bignumber","BigNumber","NoFilter","constants","MT","NUMBYTES","SIMPLE","SYMS","BI","bigIntize","BN","COUNT","Symbol","PENDING_KEY","MAJOR","ERROR","NOT_FOUND","parentArray","parent","typ","count","a","PARENT","parentBufferStream","b","_tag_2","v","bufferToBigInt","_tag_3","MINUS_ONE","Decoder","constructor","options","tags","max_depth","bigI","hasBigInt","bigint","running","nullcheck","val","NULL","UNDEFINED","undefined","Error","decodeFirstSync","input","encoding","opts","encod","extend","c","s","Readable","guessEncoding","parser","_parse","state","next","done","read","value","length","nextByte","unshift","er","toString","decodeAllSync","res","push","decodeFirst","cb","required","p","Promise","resolve","reject","on","close","once","then","end","decodeAll","vals","__fresh","depth","octet","mt","ai","parent_major","parent_length","ONE","emit","TWO","FOUR","EIGHT","numbytes","buf","SIMPLE_FLOAT","parseCBORint","INDEFINITE","POS_INT","NEG_INT","TAG","Number","MAX_SAFE_INTEGER","NEG_MAX","minus","BYTE_STRING","UTF8_STRING","Buffer","allocUnsafe","STREAM","utf8","ARRAY","MAP","hasParent","decode","parseCBORfloat","again","BREAK","Array","isArray","pm","write","allstrings","i","len","Map","set","t","convert","slice","old","module","exports"],"sources":["C:/Users/ankit/Desktop/FUND/funding/node_modules/cbor/lib/decoder.js"],"sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst BinaryParseStream = require('../vendor/binary-parse-stream')\nconst Tagged = require('./tagged')\nconst Simple = require('./simple')\nconst utils = require('./utils')\nconst bignumber = require('bignumber.js').BigNumber\nconst NoFilter = require('nofilter')\nconst constants = require('./constants')\n// Do not fix this if you want to support node v4\nconst MT = constants.MT\nconst NUMBYTES = constants.NUMBYTES\nconst SIMPLE = constants.SIMPLE\nconst SYMS = constants.SYMS\n\nconst BI = utils.bigIntize(constants.BI)\nconst BN = constants.BN\nconst COUNT = Symbol('count')\nconst PENDING_KEY = Symbol('pending_key')\nconst MAJOR = Symbol('major type')\nconst ERROR = Symbol('error')\nconst NOT_FOUND = Symbol('not found')\n\nfunction parentArray(parent, typ, count) {\n  const a = []\n  a[COUNT] = count\n  a[SYMS.PARENT] = parent\n  a[MAJOR] = typ\n  return a\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter()\n  b[COUNT] = -1\n  b[SYMS.PARENT] = parent\n  b[MAJOR] = typ\n  return b\n}\n\n/**\n * @param {Buffer} v\n * @private\n */\nfunction _tag_2(v) {\n  return utils.bufferToBigInt(v)\n}\n\n/**\n * @param {BigInt} v\n * @private\n */\nfunction _tag_3(v) {\n  // avoid syntax error on old runtimes\n  return BI.MINUS_ONE - utils.bufferToBigInt(v)\n}\n\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends {BinaryParseStream}\n */\nclass Decoder extends BinaryParseStream {\n\n  /**\n   * Create a parsing stream.\n   *\n   * @param {object} [options={}]\n   * @param {number} [options.max_depth=-1] - the maximum depth to parse.\n   *   Use -1 for \"until you run out of memory\".  Set this to a finite\n   *   positive number for un-trusted inputs.  Most standard inputs won't nest\n   *   more than 100 or so levels; I've tested into the millions before\n   *   running out of memory.\n   * @param {object} [options.tags] - mapping from tag number to function(v),\n   *   where v is the decoded value that comes after the tag, and where the\n   *   function returns the correctly-created value for that tag.\n   * @param {boolean} [options.bigint=false] generate JavaScript BigInt's\n   *   instead of BigNumbers, when possible.  TODO: when BigInt's are\n   *   more prevalent, change this to default to the value of cbor.hasBigInt.\n   */\n  constructor(options) {\n    options = options || {}\n    const tags = options.tags\n    delete options.tags\n    const max_depth = (options.max_depth != null) ? options.max_depth : -1\n    delete options.max_depth\n    const bigI = utils.hasBigInt ? (!!options.bigint) : false\n    delete options.bigint\n    super(options)\n\n    this.running = true\n    this.max_depth = max_depth\n    this.tags = tags\n    if (bigI) {\n      if (this.tags == null) {\n        this.tags = {}\n      }\n      if (this.tags[2] == null) {\n        this.tags[2] = _tag_2\n      }\n      if (this.tags[3] == null) {\n        this.tags[3] = _tag_3\n      }\n    }\n  }\n\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @static\n   * @param {any} val - the value to check\n   * @returns {any} the corrected value\n   *\n   * @example\n   * myDecoder.on('data', function(val) {\n   *   val = Decoder.nullcheck(val);\n   *   ...\n   * });\n   */\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null\n      case SYMS.UNDEFINED:\n        return undefined\n      case NOT_FOUND:\n        throw new Error('Value not found')\n      default:\n        return val\n    }\n  }\n\n  /**\n   * @typedef DecodeOptions\n   * @property {string} [encoding='hex'] - The encoding of the input.\n   *   Ignored if input is a Buffer.\n   */\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw an\n   * exception if the input is not valid CBOR.\n   *\n   * @static\n   * @param {string|Buffer|stream.Readable} input\n   * @param {DecodeOptions|string} [options] Options\n   * @returns {any} - the decoded value\n   */\n  static decodeFirstSync(input, options) {\n    options = options || { encoding: 'hex' }\n    let opts = {}\n    let encod\n    switch (typeof options) {\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = opts.encoding\n        delete opts.encoding\n        break\n    }\n    const c = new Decoder(opts)\n    const s = (input instanceof stream.Readable) ? input : new NoFilter(\n      input,\n      encod != null ? encod : utils.guessEncoding(input))\n\n    // for/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n    const parser = c._parse()\n    let state = parser.next()\n    while (!state.done) {\n      const b = s.read(state.value)\n      if ((b == null) || (b.length !== state.value)) {\n        throw new Error('Insufficient data')\n      }\n      state = parser.next(b)\n    }\n    const val = Decoder.nullcheck(state.value)\n    if (s.length > 0) {\n      const nextByte = s.read(1)\n      s.unshift(nextByte)\n      const er = new Error(\n        'Unexpected data: 0x' + nextByte[0].toString(16))\n      er.value = val\n      throw er\n    }\n    return val\n  }\n\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @static\n   * @param {string|Buffer|stream.Readable} input\n   * @param {DecodeOptions|string} [options] Options or encoding string\n   * @returns {Array} - Array of all found items\n   */\n  static decodeAllSync(input, options) {\n    options = options || { encoding: 'hex' }\n    let opts = {}\n    let encod\n    switch (typeof options) {\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = opts.encoding\n        delete opts.encoding\n    }\n    const c = new Decoder(opts)\n    const s = (input instanceof stream.Readable) ? input : new NoFilter(\n      input,\n      encod != null ? encod : utils.guessEncoding(input))\n    const res = []\n    while (s.length > 0) {\n      const parser = c._parse()\n      let state = parser.next()\n      while (!state.done) {\n        const b = s.read(state.value)\n        if ((b == null) || (b.length !== state.value)) {\n          throw new Error('Insufficient data')\n        }\n        state = parser.next(b)\n      }\n      res.push(Decoder.nullcheck(state.value))\n    }\n    return res\n  }\n\n  /**\n   * @callback decodeCallback\n   * @param {Error} [error] - if one was generated\n   * @param {any} [value] - the decoded value\n   */\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are more\n   * bytes left over at the end, and optionally if there were no valid CBOR\n   * bytes in the input.  Emits the {Decoder.NOT_FOUND} Symbol in the callback\n   * if no data was found and the `required` option is false.\n   *\n   * @static\n   * @param {string|Buffer} input - the input to parse\n   * @param {DecodeOptions|decodeCallback|string} [options] - options\n   * @param {decodeCallback} [cb] callback\n   * @returns {Promise<any>} returned even if callback is specified\n   */\n  static decodeFirst(input, options, cb) {\n    let opts = {}\n    let required = false\n    let encod = 'hex'\n    switch (typeof options) {\n      case 'function':\n        cb = options\n        encod = utils.guessEncoding(input)\n        break\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = (opts.encoding != null) ?\n          opts.encoding : utils.guessEncoding(input)\n        delete opts.encoding\n        required = (opts.required != null) ? opts.required : false\n        delete opts.required\n    }\n    const c = new Decoder(opts)\n    let v = NOT_FOUND\n    const p = new Promise((resolve, reject) => {\n      c.on('data', (val) => {\n        v = Decoder.nullcheck(val)\n        c.close()\n      })\n      c.once('error', (er) => {\n        if (v !== NOT_FOUND) {\n          er.value = v\n        }\n        v = ERROR\n        c.close()\n        return reject(er)\n      })\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'))\n            } else {\n              return resolve(v)\n            }\n          case ERROR:\n            return void 0\n          default:\n            return resolve(v)\n        }\n      })\n    })\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(null, v), cb)\n    }\n    c.end(input, encod)\n    return p\n  }\n\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error - if one was generated\n   * @param {Array} value - all of the decoded values, wrapped in an Array\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @static\n   * @param {(string|Buffer)} input - the input to parse\n   * @param {(string|Object)} options - Decoding options.\n   *   If string, the input encoding.\n   * @param {decodeAllCallback} cb callback\n   * @returns {Promise<Array>} even if callback is specified\n   */\n  static decodeAll(input, options, cb) {\n    let opts = {}\n    let encod = 'hex'\n    switch (typeof options) {\n      case 'function':\n        cb = options\n        encod = utils.guessEncoding(input)\n        break\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = (opts.encoding != null) ?\n          opts.encoding : utils.guessEncoding(input)\n        delete opts.encoding\n    }\n    const c = new Decoder(opts)\n    const vals = []\n    c.on('data', (val) => {\n      return vals.push(Decoder.nullcheck(val))\n    })\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject)\n      c.on('end', () => resolve(vals))\n    })\n    if (typeof cb === 'function') {\n      p.then(v => cb(null, v), cb)\n    }\n    c.end(input, encod)\n    return p\n  }\n\n  /**\n   * Stop processing\n   */\n  close() {\n    this.running = false\n    this.__fresh = true\n  }\n\n  *_parse() {\n    let parent = null\n    let depth = 0\n    let val = null\n    while (true) {\n      if ((this.max_depth >= 0) && (depth > this.max_depth)) {\n        throw new Error('Maximum depth ' + this.max_depth + ' exceeded')\n      }\n      const octet = (yield 1)[0]\n      if (!this.running) {\n        throw new Error('Unexpected data: 0x' + (octet.toString(16)))\n      }\n      const mt = octet >> 5\n      const ai = octet & 0x1f\n      const parent_major = (parent != null) ? parent[MAJOR] : undefined\n      const parent_length = (parent != null) ? parent.length : undefined\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length)\n          val = (yield 1)[0]\n          break\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT:\n          const numbytes = 1 << (ai - 24)\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length)\n          const buf = yield numbytes\n          val = (mt === MT.SIMPLE_FLOAT) ? buf : utils.parseCBORint(ai, buf)\n          break\n        case 28:\n        case 29:\n        case 30:\n          this.running = false\n          throw new Error('Additional info not implemented: ' + ai)\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`)\n          }\n          val = -1\n          break\n        default:\n          val = ai\n      }\n      switch (mt) {\n        case MT.POS_INT:\n          // val already decoded\n          break\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BN.NEG_MAX\n          } else if (val instanceof bignumber) {\n            val = BN.MINUS_ONE.minus(val)\n          } else {\n            val = -1 - val\n          }\n          break\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              val = (mt === MT.BYTE_STRING) ? Buffer.allocUnsafe(0) : ''\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentBufferStream(parent, mt)\n              depth++\n              continue\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              val = yield val\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val)\n              }\n          }\n          break\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = (mt === MT.MAP) ? {} : []\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentArray(parent, mt, -1)\n              depth++\n              continue\n            default:\n              this.emit('start', mt, val, parent_major, parent_length)\n              parent = parentArray(parent, mt, val * (mt - 3))\n              depth++\n              continue\n          }\n          break\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length)\n          parent = parentArray(parent, mt, 1)\n          parent.push(val)\n          depth++\n          continue\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if ((ai === NUMBYTES.ONE) && (val < 32)) {\n              throw new Error(\n                `Invalid two-byte encoding of simple value ${val}`\n              )\n            }\n            const hasParent = (parent != null)\n            val = Simple.decode(\n              val,\n              hasParent,\n              hasParent && (parent[COUNT] < 0))\n          } else {\n            val = utils.parseCBORfloat(val)\n          }\n      }\n      this.emit('value', val, parent_major, parent_length, ai)\n      let again = false\n      while (parent != null) {\n        switch (false) {\n          case val !== SYMS.BREAK:\n            parent[COUNT] = 1\n            break\n          case !Array.isArray(parent):\n            parent.push(val)\n            break\n          case !(parent instanceof NoFilter):\n            const pm = parent[MAJOR]\n            if ((pm != null) && (pm !== mt)) {\n              this.running = false\n              throw new Error('Invalid major type in indefinite encoding')\n            }\n            parent.write(val)\n        }\n        if ((--parent[COUNT]) !== 0) {\n          again = true\n          break\n        }\n        --depth\n        delete parent[COUNT]\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent\n              break\n            case MT.MAP:\n              let allstrings = true\n              if ((parent.length % 2) !== 0) {\n                throw new Error('Invalid map length: ' + parent.length)\n              }\n              for (let i = 0, len = parent.length; i < len; i += 2) {\n                if (typeof parent[i] !== 'string') {\n                  allstrings = false\n                  break\n                }\n              }\n              if (allstrings) {\n                val = {}\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val[parent[i]] = parent[i + 1]\n                }\n              } else {\n                val = new Map\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val.set(parent[i], parent[i + 1])\n                }\n              }\n              break\n            case MT.TAG:\n              const t = new Tagged(parent[0], parent[1])\n              val = t.convert(this.tags)\n              break\n          }\n        } else if (parent instanceof NoFilter) {\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice()\n              break\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8')\n              break\n          }\n        }\n        this.emit('stop', parent[MAJOR])\n\n        const old = parent\n        parent = parent[SYMS.PARENT]\n        delete old[SYMS.PARENT]\n        delete old[MAJOR]\n      }\n      if (!again) {\n        return val\n      }\n    }\n  }\n}\n\nDecoder.NOT_FOUND = NOT_FOUND\nmodule.exports = Decoder\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}