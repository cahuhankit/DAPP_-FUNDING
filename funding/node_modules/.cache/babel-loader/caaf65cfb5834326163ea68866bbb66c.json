{"ast":null,"code":"'use strict';\n\n// detect either spaces or tabs but not both to properly handle tabs\n// for indentation and spaces for alignment\nconst INDENT_RE = /^(?:( )+|\\t+)/;\nfunction getMostUsed(indents) {\n  let result = 0;\n  let maxUsed = 0;\n  let maxWeight = 0;\n  for (const entry of indents) {\n    // TODO: use destructuring when targeting Node.js 6\n    const key = entry[0];\n    const val = entry[1];\n    const u = val[0];\n    const w = val[1];\n    if (u > maxUsed || u === maxUsed && w > maxWeight) {\n      maxUsed = u;\n      maxWeight = w;\n      result = Number(key);\n    }\n  }\n  return result;\n}\nmodule.exports = str => {\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  // used to see if tabs or spaces are the most used\n  let tabs = 0;\n  let spaces = 0;\n\n  // remember the size of previous line's indentation\n  let prev = 0;\n\n  // remember how many indents/unindents as occurred for a given size\n  // and how much lines follow a given indentation\n  //\n  // indents = {\n  //    3: [1, 0],\n  //    4: [1, 5],\n  //    5: [1, 0],\n  //   12: [1, 0],\n  // }\n  const indents = new Map();\n\n  // pointer to the array of last used indent\n  let current;\n\n  // whether the last action was an indent (opposed to an unindent)\n  let isIndent;\n  for (const line of str.split(/\\n/g)) {\n    if (!line) {\n      // ignore empty lines\n      continue;\n    }\n    let indent;\n    const matches = line.match(INDENT_RE);\n    if (matches) {\n      indent = matches[0].length;\n      if (matches[1]) {\n        spaces++;\n      } else {\n        tabs++;\n      }\n    } else {\n      indent = 0;\n    }\n    const diff = indent - prev;\n    prev = indent;\n    if (diff) {\n      // an indent or unindent has been detected\n\n      isIndent = diff > 0;\n      current = indents.get(isIndent ? diff : -diff);\n      if (current) {\n        current[0]++;\n      } else {\n        current = [1, 0];\n        indents.set(diff, current);\n      }\n    } else if (current) {\n      // if the last action was an indent, increment the weight\n      current[1] += Number(isIndent);\n    }\n  }\n  const amount = getMostUsed(indents);\n  let type;\n  let indent;\n  if (!amount) {\n    type = null;\n    indent = '';\n  } else if (spaces >= tabs) {\n    type = 'space';\n    indent = ' '.repeat(amount);\n  } else {\n    type = 'tab';\n    indent = '\\t'.repeat(amount);\n  }\n  return {\n    amount,\n    type,\n    indent\n  };\n};","map":{"version":3,"names":["INDENT_RE","getMostUsed","indents","result","maxUsed","maxWeight","entry","key","val","u","w","Number","module","exports","str","TypeError","tabs","spaces","prev","Map","current","isIndent","line","split","indent","matches","match","length","diff","get","set","amount","type","repeat"],"sources":["C:/Users/ankit/Desktop/FUND/funding/node_modules/detect-indent/index.js"],"sourcesContent":["'use strict';\n\n// detect either spaces or tabs but not both to properly handle tabs\n// for indentation and spaces for alignment\nconst INDENT_RE = /^(?:( )+|\\t+)/;\n\nfunction getMostUsed(indents) {\n\tlet result = 0;\n\tlet maxUsed = 0;\n\tlet maxWeight = 0;\n\n\tfor (const entry of indents) {\n\t\t// TODO: use destructuring when targeting Node.js 6\n\t\tconst key = entry[0];\n\t\tconst val = entry[1];\n\n\t\tconst u = val[0];\n\t\tconst w = val[1];\n\n\t\tif (u > maxUsed || (u === maxUsed && w > maxWeight)) {\n\t\t\tmaxUsed = u;\n\t\t\tmaxWeight = w;\n\t\t\tresult = Number(key);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nmodule.exports = str => {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// used to see if tabs or spaces are the most used\n\tlet tabs = 0;\n\tlet spaces = 0;\n\n\t// remember the size of previous line's indentation\n\tlet prev = 0;\n\n\t// remember how many indents/unindents as occurred for a given size\n\t// and how much lines follow a given indentation\n\t//\n\t// indents = {\n\t//    3: [1, 0],\n\t//    4: [1, 5],\n\t//    5: [1, 0],\n\t//   12: [1, 0],\n\t// }\n\tconst indents = new Map();\n\n\t// pointer to the array of last used indent\n\tlet current;\n\n\t// whether the last action was an indent (opposed to an unindent)\n\tlet isIndent;\n\n\tfor (const line of str.split(/\\n/g)) {\n\t\tif (!line) {\n\t\t\t// ignore empty lines\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet indent;\n\t\tconst matches = line.match(INDENT_RE);\n\n\t\tif (matches) {\n\t\t\tindent = matches[0].length;\n\n\t\t\tif (matches[1]) {\n\t\t\t\tspaces++;\n\t\t\t} else {\n\t\t\t\ttabs++;\n\t\t\t}\n\t\t} else {\n\t\t\tindent = 0;\n\t\t}\n\n\t\tconst diff = indent - prev;\n\t\tprev = indent;\n\n\t\tif (diff) {\n\t\t\t// an indent or unindent has been detected\n\n\t\t\tisIndent = diff > 0;\n\n\t\t\tcurrent = indents.get(isIndent ? diff : -diff);\n\n\t\t\tif (current) {\n\t\t\t\tcurrent[0]++;\n\t\t\t} else {\n\t\t\t\tcurrent = [1, 0];\n\t\t\t\tindents.set(diff, current);\n\t\t\t}\n\t\t} else if (current) {\n\t\t\t// if the last action was an indent, increment the weight\n\t\t\tcurrent[1] += Number(isIndent);\n\t\t}\n\t}\n\n\tconst amount = getMostUsed(indents);\n\n\tlet type;\n\tlet indent;\n\tif (!amount) {\n\t\ttype = null;\n\t\tindent = '';\n\t} else if (spaces >= tabs) {\n\t\ttype = 'space';\n\t\tindent = ' '.repeat(amount);\n\t} else {\n\t\ttype = 'tab';\n\t\tindent = '\\t'.repeat(amount);\n\t}\n\n\treturn {\n\t\tamount,\n\t\ttype,\n\t\tindent\n\t};\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}