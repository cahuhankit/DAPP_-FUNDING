{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrap = exports.udvtCases = exports.txOptionsCases = exports.tupleCases = exports.arrayCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:wrap\");\nconst Format = __importStar(require(\"../format\"));\nconst errors_1 = require(\"./errors\");\nconst dispatch_1 = require(\"./dispatch\");\nconst Messages = __importStar(require(\"./messages\"));\nconst Conversion = __importStar(require(\"../conversion\"));\nconst Utils = __importStar(require(\"./utils\"));\nconst integer_1 = require(\"./integer\");\nconst decimal_1 = require(\"./decimal\");\nconst bool_1 = require(\"./bool\");\nconst bytes_1 = require(\"./bytes\");\nconst address_1 = require(\"./address\");\nconst string_1 = require(\"./string\");\nconst function_1 = require(\"./function\");\n//this file contains the main wrap function, as well as the cases\n//for arrays, tuples, udvts, and tx options.  all other types get their\n//own file.\nconst arrayCasesBasic = [arrayFromArray, arrayFromCodecArrayValue, arrayFromJson, arrayFailureCase];\nexports.arrayCases = [arrayFromTypeValueInput, ...arrayCasesBasic];\nconst tupleCasesBasic = [tupleFromArray, tupleFromCodecTupleLikeValue, tupleFromObject, tupleFromJson, tupleFailureCase];\nexports.tupleCases = [tupleFromTypeValueInput, ...tupleCasesBasic];\nconst txOptionsCasesBasic = [optionsFromCodecOptionsValue, optionsFromObject, optionsFailureCase];\nexports.txOptionsCases = [optionsFromTypeValueInput, ...txOptionsCasesBasic];\nexports.udvtCases = [\n//no separate case for udvtFromUdvtValue,\n//since underlying already handles this\nudvtFromUnderlying];\nfunction* wrap(dataType, input, wrapOptions) {\n  if (!wrapOptions.name) {\n    wrapOptions = Object.assign(Object.assign({}, wrapOptions), {\n      name: \"<input>\"\n    });\n  }\n  switch (dataType.typeClass) {\n    case \"uint\":\n    case \"int\":\n    case \"enum\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, integer_1.integerCases);\n    case \"fixed\":\n    case \"ufixed\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, decimal_1.decimalCases);\n    case \"bool\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, bool_1.boolCases);\n    case \"bytes\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, bytes_1.bytesCases);\n    case \"address\":\n    case \"contract\":\n      //these are treated the same\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, address_1.addressCases);\n    case \"string\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, string_1.stringCases);\n    case \"function\":\n      //special check: weed out internal functions\n      if (dataType.visibility === \"internal\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5,\n        //it doesn't matter, but we'll make this error high specificity\n        `Wrapping/encoding for internal function pointers is not supported`);\n      }\n      //otherwise, go ahead\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, function_1.functionExternalCases);\n    case \"array\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.arrayCases);\n    case \"struct\":\n    case \"tuple\":\n      //these are treated the same as well\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.tupleCases);\n    case \"userDefinedValueType\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.udvtCases);\n    case \"options\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.txOptionsCases);\n    default:\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5,\n      //it doesn't matter, but we'll make this error high specificity\n      `Wrapping/encoding for type ${Format.Types.typeStringWithoutLocation(dataType)} is not supported`);\n  }\n}\nexports.wrap = wrap;\n//array cases\nfunction* arrayFromArray(dataType, input, wrapOptions) {\n  if (!Array.isArray(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an array\");\n  }\n  if (dataType.kind === \"static\" && !dataType.length.eqn(input.length)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(dataType.length, input.length));\n  }\n  //can't do yield in a map, so manual loop here\n  let value = [];\n  for (let index = 0; index < input.length; index++) {\n    value.push(yield* wrap(dataType.baseType, input[index], Object.assign(Object.assign({}, wrapOptions), {\n      name: `${wrapOptions.name}[${index}]`,\n      specificityFloor: 5 //errors in components are quite specific!\n    })));\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\nfunction* arrayFromCodecArrayValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"array\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  //we won't bother with detailed typechecking as much of it is handled\n  //either in the call to arrayFromArray or in the wrapping of the\n  //individual elements; we will check dynamic vs static though as that\n  //isn't handled elsewhere\n  if (!wrapOptions.loose && input.type.kind === dataType.kind) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  //note that we do *not* just copy over input.value, but rather we\n  //defer to arrayFromArray; this is because there might be some elements\n  //where the type is not the same but is compatible\n  const value = input.value;\n  return yield* arrayFromArray(dataType, value, wrapOptions);\n}\nfunction* arrayFromJson(dataType, input, wrapOptions) {\n  if (!wrapOptions.allowJson) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"JSON input must be explicitly enabled\");\n  }\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  let parsedInput;\n  try {\n    parsedInput = JSON.parse(input);\n  } catch (error) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Input was not valid JSON: ${error.message}`);\n  }\n  return yield* arrayFromArray(dataType, parsedInput, wrapOptions);\n}\nfunction* arrayFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n  if (input.type !== \"array\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n  //don't turn on loose here, only do that for non-container types!\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, arrayCasesBasic);\n}\nfunction* arrayFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not an array, type/value pair or wrapped array\");\n}\n//tuple/struct cases;\n//note even with loose turned off, we won't distinguish\n//between tuples and structs\nfunction* tupleFromArray(dataType, input, wrapOptions) {\n  //first: obtain the types of the members\n  if (!Array.isArray(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an array\");\n  }\n  debug(\"input is array\");\n  const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);\n  if (memberTypes.length !== input.length) {\n    debug(\"input is wrong-length array\");\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(memberTypes.length, input.length));\n  }\n  //can't do yield in a map, so manual loop here\n  let value = [];\n  for (let index = 0; index < input.length; index++) {\n    const memberName = memberTypes[index].name;\n    debug(\"wrapping %s\", memberName);\n    value.push({\n      name: memberName,\n      value: yield* wrap(memberTypes[index].type, input[index], Object.assign(Object.assign({}, wrapOptions), {\n        name: memberName ? wrapOptions.name.match(/^<.*>$/) //hack?\n        ? memberName : `${wrapOptions.name}.${memberName}` : `${wrapOptions.name}[${index}]`,\n        specificityFloor: 5\n      }))\n    });\n  }\n  //we need to coerce here because TS doesn't know that if it's a struct\n  //then everything has a name\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\nfunction* tupleFromObject(dataType, input, wrapOptions) {\n  if (!Utils.isPlainObject(input)) {\n    //just checks that it's an object & not null\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a non-null object\");\n  }\n  if (!wrapOptions.loose && Utils.isTypeValueInput(input)) {\n    //let's exclude these unless loose is turned on\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a type/value pair\");\n  }\n  if (!wrapOptions.loose && Utils.isWrappedResult(input)) {\n    //similarly here\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n  }\n  const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);\n  if (memberTypes.some(_ref => {\n    let {\n      name\n    } = _ref;\n    return !name;\n  })) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, \"Plain object input is allowed only when all elements of tuple are named\");\n  }\n  let unusedKeys = new Set(Object.keys(input));\n  let value = [];\n  for (let index = 0; index < memberTypes.length; index++) {\n    //note we had better process these in order!\n    const memberName = memberTypes[index].name;\n    if (!(memberName in input)) {\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Missing key from tuple or struct: ${memberName}`);\n    }\n    unusedKeys.delete(memberName);\n    value.push({\n      name: memberName,\n      value: yield* wrap(memberTypes[index].type, input[memberName], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${memberName}`,\n        specificityFloor: 4 //not sure this warrants a 5\n      }))\n    });\n  }\n\n  if (!wrapOptions.loose) {\n    if (unusedKeys.size > 0) {\n      //choose one arbitrarily\n      const exampleKey = unusedKeys.values().next().value;\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Unknown key ${exampleKey} included`);\n    }\n  }\n  //we need to coerce here because TS doesn't know that if it's a struct\n  //then everything has a name\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\nfunction* tupleFromJson(dataType, input, wrapOptions) {\n  if (!wrapOptions.allowJson) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"JSON input must be explicitly enabled\");\n  }\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  let parsedInput;\n  try {\n    parsedInput = JSON.parse(input);\n  } catch (error) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Input was not valid JSON: ${error.message}`);\n  }\n  debug(\"input is JSON\");\n  debug(\"parses to: %O\", parsedInput);\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, parsedInput, wrapOptions, [tupleFromObject, tupleFromArray]);\n}\nfunction* tupleFromCodecTupleLikeValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"tuple\" && input.type.typeClass !== \"struct\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  //not going to do much typechecking here as it'll be handled in the call\n  //to tupleFromArray\n  //Typescript complains if I try to say it can be either struct or\n  //tuple, so, uh, let's just tell it it's a tuple <shrug>\n  const coercedInput = input; //HACK!\n  //note that we do *not* just copy over input.value, but rather we\n  //defer to tupleFromArray; this is because there might be some elements\n  //where the type is not the same but is compatible\n  return yield* tupleFromArray(dataType, coercedInput.value.map(_ref2 => {\n    let {\n      value\n    } = _ref2;\n    return value;\n  }), wrapOptions);\n}\nfunction* tupleFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n  if (input.type !== \"tuple\" && input.type !== \"struct\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n  //don't turn on loose here, only do that for non-container types!\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, tupleCasesBasic);\n}\nfunction* tupleFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not an array, plain object, type/value pair or wrapped tuple or struct\");\n}\nfunction memberTypesForType(dataType, userDefinedTypes) {\n  switch (dataType.typeClass) {\n    case \"tuple\":\n      return dataType.memberTypes;\n      break;\n    case \"struct\":\n      debug(\"wrapping for struct %s\", dataType.typeName);\n      return Format.Types.fullType(dataType, userDefinedTypes).memberTypes;\n  }\n}\n//udvt cases\nfunction* udvtFromUnderlying(dataType, input, wrapOptions) {\n  const {\n    underlyingType\n  } = Format.Types.fullType(dataType, wrapOptions.userDefinedTypes);\n  const value = yield* wrap(underlyingType, input, wrapOptions);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: value\n  };\n}\n//tx options cases\nfunction* optionsFromObject(dataType, input, wrapOptions) {\n  if (!Utils.isPlainObject(input)) {\n    //just checks that it's an object & not null\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a non-null object\");\n  }\n  debug(\"options input is object: %O\", input);\n  debug(\"wrapOptions: %O\", wrapOptions);\n  if (!wrapOptions.loose && Utils.isWrappedResult(input)) {\n    //similarly here\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n  }\n  //now... the main case\n  let value = {};\n  const uintKeys = [\"gas\", \"gasPrice\", \"value\", \"nonce\", \"maxFeePerGas\", \"maxPriorityFeePerGas\"];\n  const uint8Keys = [\"type\"];\n  const addressKeys = [\"from\", \"to\"];\n  const bytesKeys = [\"data\"];\n  const boolKeys = [\"overwrite\"];\n  const accessListKeys = [\"accessList\"];\n  const specialKeys = [\"privateFor\"];\n  const allKeys = [...uintKeys, ...uint8Keys, ...addressKeys, ...bytesKeys, ...boolKeys, ...accessListKeys, ...specialKeys];\n  const badKey = Object.keys(input).find(key => !allKeys.includes(key));\n  const goodKey = Object.keys(input).find(key => allKeys.includes(key));\n  if (badKey !== undefined && !wrapOptions.oldOptionsBehavior) {\n    //note we allow extra keys if oldOptionsBehavior is on -- this is a HACK\n    //to preserve existing behavior of Truffle Contract (perhaps we can\n    //change this in Truffle 6)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included unknown option ${badKey}`);\n  }\n  if (wrapOptions.oldOptionsBehavior && goodKey === undefined) {\n    //similarly, if oldOptionsBehavior is on, we require at least\n    //one *legit* key (again, HACK to preserve existing behavior,\n    //maybe remove this in Truffle 6)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included no recognized options`);\n  }\n  //otherwise, if all keys are transaction options, let's process them...\n  //part 1: uint options\n  for (const key of uintKeys) {\n    //note we check input[key] !== undefined, rather than key in input,\n    //because if one of them is undefined we want to just allow that but ignore it\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"uint\",\n        bits: 256\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), integer_1.integerCases);\n      value[key] = wrappedOption.value.asBN;\n    }\n  }\n  //part 2: uint8 options (just type for now)\n  for (const key of uint8Keys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"uint\",\n        bits: 8\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), integer_1.integerCases);\n      const asBN = wrappedOption.value.asBN;\n      //since this is just type right now, we're going to reject illegal types\n      if (asBN.gten(0xc0)) {\n        //not making a constant for this, this is its only use here\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.type`, 4, \"Transaction types must be less than 0xc0\");\n      }\n      //for compatibility, we give type as a hex string rather than\n      //leaving it as a BN.  Since it's unsigned we don't have to\n      //worry about negatives.\n      value[key] = Conversion.toHexString(asBN);\n    }\n  }\n  //part 3: address options\n  for (const key of addressKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"address\",\n        kind: \"general\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), address_1.addressCases);\n      value[key] = wrappedOption.value.asAddress;\n    }\n  }\n  //part 4: bytestring options\n  for (const key of bytesKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"bytes\",\n        kind: \"dynamic\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), bytes_1.bytesCases);\n      value[key] = wrappedOption.value.asHex;\n    }\n  }\n  //part 5: boolean options\n  for (const key of boolKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"bool\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), bool_1.boolCases);\n      value[key] = wrappedOption.value.asBoolean;\n    }\n  }\n  //part 6: the access list\n  for (const key of accessListKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"array\",\n        kind: \"dynamic\",\n        baseType: {\n          typeClass: \"tuple\",\n          memberTypes: [{\n            name: \"address\",\n            type: {\n              typeClass: \"address\",\n              kind: \"general\"\n            }\n          }, {\n            name: \"storageKeys\",\n            type: {\n              typeClass: \"array\",\n              kind: \"dynamic\",\n              baseType: {\n                //we use uint256 rather than bytes32 to allow\n                //abbreviating and left-padding\n                typeClass: \"uint\",\n                bits: 256\n              }\n            }\n          }]\n        }\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), exports.arrayCases);\n      value[key] = Format.Utils.Inspect.nativizeAccessList(wrappedOption);\n    }\n  }\n  //part 7: the special case of privateFor\n  if (input.privateFor !== undefined) {\n    //this doesn't correspond to any of our usual types, so we have to handle it specially\n    if (!Array.isArray(input.privateFor)) {\n      throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, \"Transaction option privateFor should be an array of base64-encoded bytestrings of 32 bytes\");\n    }\n    value.privateFor = input.privateFor.map((publicKey, index) => {\n      if (Utils.isBoxedString(publicKey)) {\n        publicKey = publicKey.valueOf();\n      }\n      if (typeof publicKey !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not a string`);\n      }\n      if (!Utils.isBase64(publicKey)) {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not base64-encoded`);\n      }\n      const length = Utils.base64Length(publicKey);\n      if (length !== 32) {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} should encode a bytestring of 32 bytes; got ${length} bytes instead`);\n      }\n      return publicKey;\n    });\n  }\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\nfunction* optionsFromCodecOptionsValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"options\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  const value = input.value;\n  //unlike in the array or tuple cases, here should not have\n  //to worry about compatible-but-not-identical types, so it's\n  //safe to just copy value over\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\nfunction* optionsFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n  if (input.type !== \"options\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n  //because options, unlike other containers, has specific types, we *will* turn on loose\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), txOptionsCasesBasic);\n}\nfunction* optionsFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Transaction options input was not a plain object, type/value pair or wrapped options object\");\n}","map":{"version":3,"mappings":"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","names":["debug","arrayCasesBasic","arrayFromArray","arrayFromCodecArrayValue","arrayFromJson","arrayFailureCase","exports","arrayFromTypeValueInput","tupleCasesBasic","tupleFromArray","tupleFromCodecTupleLikeValue","tupleFromObject","tupleFromJson","tupleFailureCase","tupleFromTypeValueInput","txOptionsCasesBasic","optionsFromCodecOptionsValue","optionsFromObject","optionsFailureCase","optionsFromTypeValueInput","udvtFromUnderlying","wrap","dataType","input","wrapOptions","name","typeClass","integer_1","decimal_1","bool_1","bytes_1","address_1","string_1","visibility","errors_1","function_1","Format","Types","typeStringWithoutLocation","Array","isArray","kind","length","eqn","Messages","wrongArrayLengthMessage","value","index","push","baseType","specificityFloor","type","Utils","isWrappedResult","wrappedTypeMessage","errorResultMessage","loose","allowJson","parsedInput","JSON","parse","error","message","isTypeValueInput","specifiedTypeMessage","memberTypes","memberTypesForType","userDefinedTypes","memberName","match","isPlainObject","some","unusedKeys","Set","Object","keys","delete","size","exampleKey","values","next","coercedInput","map","typeName","fullType","underlyingType","uintKeys","uint8Keys","addressKeys","bytesKeys","boolKeys","accessListKeys","specialKeys","allKeys","badKey","find","key","includes","goodKey","undefined","oldOptionsBehavior","wrappedOption","bits","asBN","gten","Conversion","toHexString","asAddress","asHex","asBoolean","Inspect","nativizeAccessList","privateFor","publicKey","isBoxedString","valueOf","isBase64","base64Length"],"sourceRoot":"","sources":["../../../lib/wrap/wrap.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}