{"ast":null,"code":"const debug = require(\"debug\")(\"contract:manual-send\");\nconst ethers = require(\"ethers\");\nconst Utils = require(\"./utils\");\nconst {\n  formatters\n} = require(\"web3-core-helpers\"); //used for reproducing web3's behavior\n\n//this is less manual now, it uses ethers, whew\n//(it's still more manual than using web3)\nasync function sendTransactionManual(web3, params, promiEvent) {\n  debug(\"executing manually!\");\n  //set up ethers provider\n  const ethersProvider = new ethers.providers.Web3Provider(web3.currentProvider);\n  //let's clone params and set it up properly\n  const {\n    transaction,\n    from\n  } = setUpParameters(params, web3);\n  //now: if the from address is in the wallet, web3 will sign the transaction before\n  //sending, so we have to account for that\n  const account = web3.eth.accounts.wallet[from];\n  const ethersSigner = account ? new ethers.Wallet(account.privateKey, ethersProvider) : ethersProvider.getSigner(from);\n  debug(\"got signer\");\n  let txHash, receipt, ethersResponse;\n  try {\n    //note: the following code won't work with ethers v5.\n    //wth ethers v5, in the getSigner() case, you'll need to\n    //use sendUncheckedTransaction instead of sendTransaction.\n    //I don't know why.\n    ethersResponse = await ethersSigner.sendTransaction(transaction);\n    txHash = ethersResponse.hash;\n    receipt = await ethersProvider.waitForTransaction(txHash);\n    debug(\"no error\");\n  } catch (error) {\n    ({\n      txHash,\n      receipt\n    } = handleError(error));\n    if (!receipt) {\n      receipt = await ethersProvider.waitForTransaction(txHash);\n    }\n  }\n  debug(\"txHash: %s\", txHash);\n  receipt = translateReceipt(receipt);\n  promiEvent.setTransactionHash(txHash); //this here is why I wrote this function @_@\n  return await handleResult(receipt, transaction.to == null);\n}\nfunction handleError(error) {\n  debug(\"error: %O\", error);\n  if (error.data && error.data.hash) {\n    //ganache v7.x\n    return {\n      txHash: error.data.hash\n    };\n  } else if (error.data && Object.keys(error.data).length === 3) {\n    //ganache v2.x\n    //error.data will have 3 keys: stack, name, and the txHash\n    const transactionHash = Object.keys(error.data).find(key => key !== \"stack\" && key !== \"name\");\n    return {\n      txHash: transactionHash\n    };\n  } else if (error.transactionHash && error.receipt) {\n    return {\n      txHash: error.transactionHash,\n      receipt: error.receipt\n    };\n  } else {\n    throw error; //rethrow unexpected errors\n  }\n}\n\nasync function handleResult(receipt, isDeployment) {\n  const deploymentFailedMessage = \"The contract code couldn't be stored, please check your gas limit.\";\n  if (receipt.status) {\n    if (isDeployment) {\n      //in the deployment case, web3 might error even when technically successful @_@\n      if ((await web3.eth.getCode(receipt.contractAddress)) === \"0x\") {\n        throw new Error(deploymentFailedMessage);\n      }\n    }\n    return receipt;\n  } else {\n    //otherwise: we have to mimic web3's errors @_@\n    if (isDeployment) {\n      //deployment case\n      throw new Error(deploymentFailedMessage);\n    }\n    throw new Error(\"Transaction has been reverted by the EVM:\" + \"\\n\" + JSON.stringify(receipt));\n  }\n}\nfunction setUpParameters(params, web3) {\n  let transaction = Object.assign({}, params);\n  transaction.from = transaction.from != undefined ? transaction.from : web3.eth.defaultAccount;\n  //now let's have web3 check our inputs\n  transaction = formatters.inputTransactionFormatter(transaction); //warning, not a pure fn\n  //...but ethers uses gasLimit instead of gas like web3\n  transaction.gasLimit = transaction.gas;\n  delete transaction.gas;\n  //also, it insists \"from\" be kept separate\n  const {\n    from\n  } = transaction;\n  delete transaction.from;\n  return {\n    transaction,\n    from\n  };\n}\n\n//translate the receipt to web3 format by converting BigNumbers\n//(note: these are *ethers* BigNumbers) to numbers\nfunction translateReceipt(receipt) {\n  return Object.assign({}, ...Object.entries(receipt).map(_ref => {\n    let [key, value] = _ref;\n    return {\n      [key]: Utils.is_big_number(value) ? value.toNumber() : value\n    };\n  }));\n}\nmodule.exports = {\n  sendTransactionManual\n};","map":{"version":3,"names":["debug","require","ethers","Utils","formatters","sendTransactionManual","web3","params","promiEvent","ethersProvider","providers","Web3Provider","currentProvider","transaction","from","setUpParameters","account","eth","accounts","wallet","ethersSigner","Wallet","privateKey","getSigner","txHash","receipt","ethersResponse","sendTransaction","hash","waitForTransaction","error","handleError","translateReceipt","setTransactionHash","handleResult","to","data","Object","keys","length","transactionHash","find","key","isDeployment","deploymentFailedMessage","status","getCode","contractAddress","Error","JSON","stringify","assign","undefined","defaultAccount","inputTransactionFormatter","gasLimit","gas","entries","map","value","is_big_number","toNumber","module","exports"],"sources":["C:/Users/ankit/Desktop/FUND/funding/node_modules/@truffle/contract/lib/manual-send.js"],"sourcesContent":["const debug = require(\"debug\")(\"contract:manual-send\");\nconst ethers = require(\"ethers\");\nconst Utils = require (\"./utils\");\nconst { formatters } = require(\"web3-core-helpers\"); //used for reproducing web3's behavior\n\n//this is less manual now, it uses ethers, whew\n//(it's still more manual than using web3)\nasync function sendTransactionManual(web3, params, promiEvent) {\n  debug(\"executing manually!\");\n  //set up ethers provider\n  const ethersProvider = new ethers.providers.Web3Provider(\n    web3.currentProvider\n  );\n  //let's clone params and set it up properly\n  const { transaction, from } = setUpParameters(params, web3);\n  //now: if the from address is in the wallet, web3 will sign the transaction before\n  //sending, so we have to account for that\n  const account = web3.eth.accounts.wallet[from];\n  const ethersSigner = account\n    ? new ethers.Wallet(account.privateKey, ethersProvider)\n    : ethersProvider.getSigner(from);\n  debug(\"got signer\");\n  let txHash, receipt, ethersResponse;\n  try {\n    //note: the following code won't work with ethers v5.\n    //wth ethers v5, in the getSigner() case, you'll need to\n    //use sendUncheckedTransaction instead of sendTransaction.\n    //I don't know why.\n    ethersResponse = await ethersSigner.sendTransaction(transaction);\n    txHash = ethersResponse.hash;\n    receipt = await ethersProvider.waitForTransaction(txHash);\n    debug(\"no error\");\n  } catch (error) {\n    ({ txHash, receipt } = handleError(error));\n    if (!receipt) {\n      receipt = await ethersProvider.waitForTransaction(txHash);\n    }\n  }\n  debug(\"txHash: %s\", txHash);\n  receipt = translateReceipt(receipt);\n  promiEvent.setTransactionHash(txHash); //this here is why I wrote this function @_@\n  return await handleResult(receipt, transaction.to == null);\n}\n\nfunction handleError(error) {\n  debug(\"error: %O\", error);\n  if (error.data && error.data.hash) {\n    //ganache v7.x\n    return { txHash: error.data.hash };\n  } else if (error.data && Object.keys(error.data).length === 3) {\n    //ganache v2.x\n    //error.data will have 3 keys: stack, name, and the txHash\n    const transactionHash = Object.keys(error.data).find(\n      key => key !== \"stack\" && key !== \"name\"\n    );\n    return { txHash: transactionHash };\n  } else if (error.transactionHash && error.receipt) {\n    return {\n      txHash: error.transactionHash,\n      receipt: error.receipt\n    };\n  } else {\n    throw error; //rethrow unexpected errors\n  }\n}\n\nasync function handleResult(receipt, isDeployment) {\n  const deploymentFailedMessage = \"The contract code couldn't be stored, please check your gas limit.\";\n  if (receipt.status) {\n    if (isDeployment) {\n      //in the deployment case, web3 might error even when technically successful @_@\n      if ((await web3.eth.getCode(receipt.contractAddress)) === \"0x\") {\n        throw new Error(deploymentFailedMessage);\n      }\n    }\n    return receipt;\n  } else {\n    //otherwise: we have to mimic web3's errors @_@\n    if (isDeployment) {\n      //deployment case\n      throw new Error(deploymentFailedMessage);\n    }\n    throw new Error(\n      \"Transaction has been reverted by the EVM:\" +\n        \"\\n\" +\n        JSON.stringify(receipt)\n    );\n  }\n}\n\nfunction setUpParameters(params, web3) {\n  let transaction = Object.assign({}, params);\n  transaction.from =\n    transaction.from != undefined\n      ? transaction.from\n      : web3.eth.defaultAccount;\n  //now let's have web3 check our inputs\n  transaction = formatters.inputTransactionFormatter(transaction); //warning, not a pure fn\n  //...but ethers uses gasLimit instead of gas like web3\n  transaction.gasLimit = transaction.gas;\n  delete transaction.gas;\n  //also, it insists \"from\" be kept separate\n  const { from } = transaction;\n  delete transaction.from;\n  return { transaction, from }\n}\n\n//translate the receipt to web3 format by converting BigNumbers\n//(note: these are *ethers* BigNumbers) to numbers\nfunction translateReceipt(receipt) {\n  return Object.assign({},\n    ...Object.entries(receipt).map(([key, value]) => ({\n      [key]: Utils.is_big_number(value)\n        ? value.toNumber()\n        : value\n    }))\n  );\n}\n\nmodule.exports = {\n  sendTransactionManual\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}