{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addressCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:address\");\nconst dispatch_1 = require(\"./dispatch\");\nconst errors_1 = require(\"./errors\");\nconst Utils = __importStar(require(\"./utils\"));\nconst EvmUtils = __importStar(require(\"../evm/utils\"));\nconst Messages = __importStar(require(\"./messages\"));\nconst web3_utils_1 = __importDefault(require(\"web3-utils\"));\n//no separate cases for contracts; even with loose turned off,\n//we consider these interchangeable\nconst addressFromStringCases = [addressFromHexString, addressFromPrefixlessHexString, addressFromOtherString //Please put after other string cases! Also, can yield\n];\n\nconst addressCasesBasic = [...addressFromStringCases, addressFromBoxedString, addressFromContractInput, addressFromCodecAddressLikeValue, addressFromCodecUdvtValue, addressFailureCase];\nexports.addressCases = [addressFromTypeValueInput, ...addressCasesBasic];\nfunction* addressFromHexString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  if (!Utils.isHexString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a 0x-prefixed hex string\");\n  }\n  return validateNormalizeAndWrap(dataType, input, input, wrapOptions.name);\n}\nfunction* addressFromPrefixlessHexString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  if (!Utils.isPrefixlessHexString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an unprefixed hex string\");\n  }\n  return validateNormalizeAndWrap(dataType, \"0x\" + input, input, wrapOptions.name);\n}\nfunction* addressFromOtherString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  const request = {\n    kind: \"address\",\n    name: input\n  };\n  const response = yield request;\n  if (response.kind !== \"address\") {\n    throw new errors_1.BadResponseTypeError(request, response);\n  }\n  if (response.address === null) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason);\n  }\n  //we should be able to skip validation & normalization here\n  return wrapAsAppropriateType(dataType, response.address);\n}\nfunction* addressFromBoxedString(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n  }\n  //unbox and try again\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, addressFromStringCases);\n}\nfunction* addressFromContractInput(dataType, input, wrapOptions) {\n  if (!Utils.isContractInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a contract-like object\");\n  }\n  return validateNormalizeAndWrap(dataType, input.address, input, wrapOptions.name);\n}\nfunction* addressFromCodecAddressLikeValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"address\" && input.type.typeClass !== \"contract\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  let address;\n  switch (input.type.typeClass) {\n    case \"address\":\n      address = input.value.asAddress;\n      break;\n    case \"contract\":\n      address = input.value.address;\n      break;\n    //other cases are impossible at this point\n  }\n  //we should be able to skip validation/normalization here\n  return wrapAsAppropriateType(dataType, address);\n}\nfunction* addressFromCodecUdvtValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"userDefinedValueType\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  return yield* addressFromCodecAddressLikeValue(dataType, input.value, wrapOptions);\n}\nfunction* addressFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n  if (input.type !== \"address\" && input.type !== \"contract\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n  //extract value & try again, with loose option turned on\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), addressCasesBasic);\n}\nfunction* addressFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not recognizable as an address\");\n}\nfunction validateAndNormalize(asAddress, dataType,\n//for errors\ninput,\n//for errors\nname //for errors\n) {\n  if (!Utils.isByteString(asAddress)) {\n    throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.notABytestringMessage(\"Address\"));\n  }\n  if (asAddress.length !== 2 * EvmUtils.ADDRESS_SIZE + 2) {\n    throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.wrongLengthMessage(\"address\", EvmUtils.ADDRESS_SIZE, (asAddress.length - 2) / 2));\n  }\n  if (!web3_utils_1.default.isAddress(asAddress)) {\n    throw new errors_1.TypeMismatchError(dataType, input, name, 6,\n    //to beat the one from the yield case :P\n    Messages.checksumFailedMessage);\n  }\n  //and normalize\n  return web3_utils_1.default.toChecksumAddress(asAddress);\n}\nfunction wrapAsAppropriateType(dataType, asAddress) {\n  //return address or contract value as appropriate\n  switch (dataType.typeClass) {\n    case \"address\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asAddress\n        }\n      };\n    case \"contract\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          kind: \"unknown\",\n          address: asAddress\n        }\n      };\n  }\n}\nfunction validateNormalizeAndWrap(dataType, asAddress, input,\n//for errors\nname //for errors\n) {\n  return wrapAsAppropriateType(dataType, validateAndNormalize(asAddress, dataType, input, name));\n}","map":{"version":3,"mappings":"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","names":["debug","addressFromStringCases","addressFromHexString","addressFromPrefixlessHexString","addressFromOtherString","addressCasesBasic","addressFromBoxedString","addressFromContractInput","addressFromCodecAddressLikeValue","addressFromCodecUdvtValue","addressFailureCase","exports","addressFromTypeValueInput","dataType","input","wrapOptions","errors_1","name","Utils","isHexString","validateNormalizeAndWrap","isPrefixlessHexString","request","kind","response","address","partiallyRecognized","reason","wrapAsAppropriateType","isBoxedString","valueOf","isContractInput","isWrappedResult","type","typeClass","Messages","wrappedTypeMessage","errorResultMessage","value","asAddress","isTypeValueInput","specifiedTypeMessage","loose","validateAndNormalize","isByteString","notABytestringMessage","length","EvmUtils","ADDRESS_SIZE","wrongLengthMessage","web3_utils_1","isAddress","checksumFailedMessage","toChecksumAddress"],"sourceRoot":"","sources":["../../../lib/wrap/address.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}