{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateUint8ArrayLike = exports.bytesCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:bytes\");\nconst dispatch_1 = require(\"./dispatch\");\nconst errors_1 = require(\"./errors\");\nconst Conversion = __importStar(require(\"../conversion\"));\nconst Utils = __importStar(require(\"./utils\"));\nconst Messages = __importStar(require(\"./messages\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst bytesFromStringCases = [bytesFromHexString, bytesFromIntegerString //dynamic loose mode only; make sure this goes after hex string case!\n];\n\nconst bytesCasesBasic = [...bytesFromStringCases, bytesFromBoxedString, bytesFromUint8ArrayLike, bytesFromCodecBytesValue, bytesFromCodecUdvtValue, bytesFromEncodingTextInput, bytesFromNumber, bytesFromBoxedNumber, bytesFromBigint, bytesFromBN, bytesFromBig, bytesFromOther //dynamic loose mode only, is failure case otherwise. Make sure this goes last!\n];\n\nexports.bytesCases = [bytesFromTypeValueInput, ...bytesCasesBasic];\nfunction* bytesFromHexString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  const trimmed = Utils.removeUnderscoresHex(input);\n  //(but not between individual hex digits)\n  if (!Utils.isByteString(trimmed)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.notABytestringMessage(\"Input\"));\n  }\n  const asHex = validateAndPad(dataType, trimmed, input, wrapOptions.name);\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\nfunction* bytesFromIntegerString(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  if (input.trim() === \"\") {\n    //bigint accepts this but we shouldn't\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.notABytestringMessage(\"Input\"));\n  }\n  const trimmed = Utils.removeUnderscoresNumeric(input);\n  let asBigInt;\n  try {\n    //we'll use BigInt to parse integer strings, as it's pretty good at it.\n    //Note that it accepts hex/octal/binary with prefixes 0x, 0o, 0b.\n    asBigInt = BigInt(trimmed);\n  } catch (_a) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input string was not a byte string or integer string\");\n  }\n  if (asBigInt < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n  let asHex = Conversion.toHexString(asBigInt);\n  asHex = adjustZeroNumericInput(asHex);\n  //because we're in dynamic case, we can skip validateAndPad\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\nfunction* bytesFromBoxedString(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n  }\n  //defer to primitive string cases\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, bytesFromStringCases);\n}\nfunction* bytesFromUint8ArrayLike(dataType, input, wrapOptions) {\n  if (!Utils.isUint8ArrayLike(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Uint8Array-like\");\n  }\n  //the next series of checks is delegated to a helper fn\n  validateUint8ArrayLike(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)\n  let asHex = Conversion.toHexString(new Uint8Array(input)); //I am surprised TS accepts this!\n  asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\nfunction* bytesFromEncodingTextInput(dataType, input, wrapOptions) {\n  if (!Utils.isEncodingTextInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a in encoding/text form\");\n  }\n  if (input.encoding !== \"utf8\") {\n    //(the only allowed encoding :P )\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Unknown or unsupported text encoding ${input.encoding}`);\n  }\n  let asHex;\n  try {\n    asHex = Conversion.toHexString(Conversion.stringToBytes(input.text));\n  } catch (_a) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.invalidUtf16Message);\n  }\n  asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\nfunction* bytesFromCodecBytesValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"bytes\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  if (!wrapOptions.loose && !(input.type.kind === \"dynamic\" && dataType.kind === \"dynamic\") && !(input.type.kind === \"static\" && dataType.kind === \"static\" && input.type.length === dataType.length)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  let asHex = input.value.asHex;\n  asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\nfunction* bytesFromCodecUdvtValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"userDefinedValueType\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  return yield* bytesFromCodecBytesValue(dataType, input.value, wrapOptions);\n}\nfunction* bytesFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n  if (!input.type.match(/^byte(s\\d*)?$/)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n  debug(\"input.type: %s\", input.type);\n  //now: determine the specified length; we use \"null\" for dynamic\n  //note that \"byte\" is allowed, with a length of 1\n  let length = null;\n  let match = input.type.match(/^bytes(\\d+)$/);\n  if (match) {\n    length = Number(match[1]); //static case with specified number\n  } else if (input.type === \"byte\") {\n    //\"byte\" case; set length to 1\n    length = 1;\n  }\n  //otherwise, it's dynamic, so leave it at the default of null\n  debug(\"length: %o\", length);\n  //check: does the specified length match the data type length?\n  if (!(length === null && dataType.kind === \"dynamic\") && !(dataType.kind === \"static\" && length === dataType.length)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n  //extract value & try again, with loose option turned on\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), bytesCasesBasic);\n}\nfunction* bytesFromNumber(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n  if (typeof input !== \"number\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a number\");\n  }\n  if (!Number.isInteger(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);\n  }\n  if (!Number.isSafeInteger(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonSafeMessage);\n  }\n  if (input < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n  let asHex = Conversion.toHexString(input);\n  asHex = adjustZeroNumericInput(asHex);\n  //because we're in dynamic case, we can skip validateAndPad\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\nfunction* bytesFromBoxedNumber(dataType, input, wrapOptions) {\n  //skipping the wrapOptions.loose check, as that'll get checked\n  //in bytesFromNumber\n  if (!Utils.isBoxedNumber(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed number\");\n  }\n  //unbox and try again\n  return yield* bytesFromNumber(dataType, input.valueOf(), wrapOptions);\n}\nfunction* bytesFromBigint(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n  if (typeof input !== \"bigint\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a bigint\");\n  }\n  if (input < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n  let asHex = Conversion.toHexString(input);\n  asHex = adjustZeroNumericInput(asHex);\n  //because we're in dynamic case, we can skip validateAndPad\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\nfunction* bytesFromBN(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n  if (!bn_js_1.default.isBN(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a BN\");\n  }\n  if (input.isNeg()) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n  let asHex = Conversion.toHexString(input);\n  asHex = adjustZeroNumericInput(asHex);\n  //because we're in dynamic case, we can skip validateAndPad\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\nfunction* bytesFromBig(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n  if (!Conversion.isBig(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Big\");\n  }\n  if (Conversion.countDecimalPlaces(input) !== 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);\n  }\n  if (input.lt(0)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n  let asHex = Conversion.toHexString(input);\n  asHex = adjustZeroNumericInput(asHex);\n  //because we're in dynamic case, we can skip validateAndPad\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\nfunction* bytesFromOther(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    //outside of the dynamic-loose case, this is just a failure case\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not a hex string, byte-array-alike, encoding/text pair, type/value pair, or wrapped bytestring\");\n  }\n  const request = {\n    kind: \"integer\",\n    input\n  };\n  const response = yield request;\n  if (response.kind !== \"integer\") {\n    throw new errors_1.BadResponseTypeError(request, response);\n  }\n  if (response.value === null) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason || \"Input was not a hex string, byte-array-alike, encoding/text pair, type/value pair, integer input, or wrapped bytestring\");\n  }\n  if (response.value < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n  let asHex = Conversion.toHexString(response.value);\n  asHex = adjustZeroNumericInput(asHex);\n  //because we're in dynamic case, we can skip validateAndPad\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\nfunction validateUint8ArrayLike(input, dataType,\n//for error information\nname //for error information\n) {\n  //this function doesn't return anything, it just throws errors if something\n  //goes wrong\n  if (input instanceof Uint8Array) {\n    return; //honest Uint8Arrays don't need checking\n  }\n\n  if (!Number.isSafeInteger(input.length)) {\n    throw new errors_1.TypeMismatchError(dataType, input, name, 5, \"Input is byte-array-like, but its length is not a safe integer\");\n  }\n  if (input.length < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, name, 5, \"Input is byte-array-like, but its length is negative\");\n  }\n  //check: is it actually like a Uint8Array?\n  for (let index = 0; index < input.length; index++) {\n    if (typeof input[index] !== \"number\" || input[index] < 0 || input[index] >= 256 || !Number.isInteger(input[index])) {\n      throw new errors_1.TypeMismatchError(dataType, input, name, 5, `Input is byte-array-like, but byte ${index} is not a 1-byte value (number from 0 to 255)`);\n    }\n  }\n  //otherwise, we didn't throw any errors, so return\n}\n\nexports.validateUint8ArrayLike = validateUint8ArrayLike;\nfunction validateAndPad(dataType, asHex, input,\n//for errors\nname //for errors\n) {\n  asHex = asHex.toLowerCase();\n  //if static, validate and pad\n  if (dataType.kind === \"static\") {\n    if ((asHex.length - 2) / 2 > dataType.length) {\n      throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.overlongMessage(dataType.length, (asHex.length - 2) / 2));\n    } else {\n      asHex = asHex.padEnd(dataType.length * 2 + 2, \"00\");\n    }\n  }\n  return asHex;\n}\n//special case for ethers compatibility; represents 0 as 0x00 rather than 0x.\n//only for numeric input in loose mode, in dynamic case, for compatibility; not\n//for ordinary hex input, where the two are distinct!\nfunction adjustZeroNumericInput(asHex) {\n  return asHex === \"0x\" ? \"0x00\" : asHex;\n}","map":{"version":3,"mappings":"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","names":["debug","bytesFromStringCases","bytesFromHexString","bytesFromIntegerString","bytesCasesBasic","bytesFromBoxedString","bytesFromUint8ArrayLike","bytesFromCodecBytesValue","bytesFromCodecUdvtValue","bytesFromEncodingTextInput","bytesFromNumber","bytesFromBoxedNumber","bytesFromBigint","bytesFromBN","bytesFromBig","bytesFromOther","exports","bytesFromTypeValueInput","dataType","input","wrapOptions","errors_1","name","trimmed","Utils","removeUnderscoresHex","isByteString","Messages","notABytestringMessage","asHex","validateAndPad","type","kind","value","loose","looseModeOnlyMessage","trim","removeUnderscoresNumeric","asBigInt","BigInt","negativeBytesMessage","Conversion","toHexString","adjustZeroNumericInput","isBoxedString","valueOf","isUint8ArrayLike","validateUint8ArrayLike","Uint8Array","isEncodingTextInput","encoding","stringToBytes","text","invalidUtf16Message","isWrappedResult","typeClass","wrappedTypeMessage","errorResultMessage","length","isTypeValueInput","match","specifiedTypeMessage","Number","isInteger","nonIntegerMessage","isSafeInteger","nonSafeMessage","isBoxedNumber","bn_js_1","isBN","isNeg","isBig","countDecimalPlaces","lt","request","response","partiallyRecognized","reason","index","toLowerCase","overlongMessage","padEnd"],"sourceRoot":"","sources":["../../../lib/wrap/bytes.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}