{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abiEntryHasStorageParameters = exports.abiEntryIsObviouslyIllTyped = exports.topicsCount = exports.definitionMatchesAbi = exports.abisMatch = exports.abiHasPayableFallback = exports.computeSelectors = exports.DEFAULT_CONSTRUCTOR_ABI = exports.abiSelector = exports.abiTupleSignature = exports.abiTypeSignature = exports.abiSignature = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:abi-data:utils\");\nconst Ast = __importStar(require(\"../ast\"));\nconst abi_utils_1 = require(\"@truffle/abi-utils\");\nObject.defineProperty(exports, \"abiSignature\", {\n  enumerable: true,\n  get: function () {\n    return abi_utils_1.abiSignature;\n  }\n});\nObject.defineProperty(exports, \"abiTypeSignature\", {\n  enumerable: true,\n  get: function () {\n    return abi_utils_1.abiTypeSignature;\n  }\n});\nObject.defineProperty(exports, \"abiTupleSignature\", {\n  enumerable: true,\n  get: function () {\n    return abi_utils_1.abiTupleSignature;\n  }\n});\nObject.defineProperty(exports, \"abiSelector\", {\n  enumerable: true,\n  get: function () {\n    return abi_utils_1.abiSelector;\n  }\n});\nexports.DEFAULT_CONSTRUCTOR_ABI = {\n  type: \"constructor\",\n  inputs: [],\n  stateMutability: \"nonpayable\"\n};\n//note the return value only includes functions!\nfunction computeSelectors(abi) {\n  if (abi === undefined) {\n    return undefined;\n  }\n  return Object.assign({}, ...abi.filter(abiEntry => abiEntry.type === \"function\").map(abiEntry => ({\n    [(0, abi_utils_1.abiSelector)(abiEntry)]: abiEntry\n  })));\n}\nexports.computeSelectors = computeSelectors;\n//does this ABI have a payable fallback (or receive) function?\nfunction abiHasPayableFallback(abi) {\n  if (abi === undefined) {\n    return undefined;\n  }\n  return abi.some(abiEntry => (abiEntry.type === \"fallback\" || abiEntry.type === \"receive\") && abiEntry.stateMutability === \"payable\");\n}\nexports.abiHasPayableFallback = abiHasPayableFallback;\n//note: undefined does not match itself :P\nfunction abisMatch(entry1, entry2) {\n  //we'll consider two abi entries to match if they have the same\n  //type, name (if applicable), and inputs (if applicable).\n  //since there's already a signature function, we can just use that.\n  if (!entry1 || !entry2) {\n    return false;\n  }\n  if (entry1.type !== entry2.type) {\n    return false;\n  }\n  switch (entry1.type) {\n    case \"function\":\n    case \"event\":\n    case \"error\":\n      return (0, abi_utils_1.abiSignature)(entry1) === (0, abi_utils_1.abiSignature)(entry2);\n    case \"constructor\":\n      return (0, abi_utils_1.abiTupleSignature)(entry1.inputs) === (0, abi_utils_1.abiTupleSignature)(entry2.inputs);\n    case \"fallback\":\n    case \"receive\":\n      return true;\n  }\n}\nexports.abisMatch = abisMatch;\nfunction definitionMatchesAbi(abiEntry, definition, referenceDeclarations) {\n  try {\n    return abisMatch(abiEntry, Ast.Utils.definitionToAbi(definition, referenceDeclarations));\n  } catch (_) {\n    return false; //if an exception occurs, well, that's not a match!\n  }\n}\n\nexports.definitionMatchesAbi = definitionMatchesAbi;\nfunction topicsCount(abiEntry) {\n  let selectorCount = abiEntry.anonymous ? 0 : 1; //if the event is not anonymous, we must account for the selector\n  return abiEntry.inputs.filter(_ref => {\n    let {\n      indexed\n    } = _ref;\n    return indexed;\n  }).length + selectorCount;\n}\nexports.topicsCount = topicsCount;\nfunction abiEntryIsObviouslyIllTyped(abiEntry) {\n  switch (abiEntry.type) {\n    case \"fallback\":\n    case \"receive\":\n      return false;\n    case \"constructor\":\n    case \"event\":\n    case \"error\":\n      return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped);\n    case \"function\":\n      return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped) || abiEntry.outputs.some(abiParameterIsObviouslyIllTyped);\n  }\n}\nexports.abiEntryIsObviouslyIllTyped = abiEntryIsObviouslyIllTyped;\nfunction abiParameterIsObviouslyIllTyped(abiParameter) {\n  const legalBaseTypeClasses = [\"uint\", \"int\", \"fixed\", \"ufixed\", \"bool\", \"address\", \"bytes\", \"string\", \"function\", \"tuple\"];\n  const baseTypeClass = abiParameter.type.match(/^([a-z]*)/)[1];\n  const baseTypeClassIsObviouslyWrong = !legalBaseTypeClasses.includes(baseTypeClass);\n  if (abiParameter.components) {\n    return abiParameter.components.some(abiParameterIsObviouslyIllTyped) || baseTypeClassIsObviouslyWrong;\n  } else {\n    return baseTypeClassIsObviouslyWrong;\n  }\n}\nfunction abiEntryHasStorageParameters(abiEntry) {\n  const isStorage = parameter => parameter.type.endsWith(\" storage\");\n  return abiEntry.type === \"function\" && (abiEntry.inputs.some(isStorage) || abiEntry.outputs.some(isStorage));\n  //Note the lack of recursion!  Storage parameters can only occur at\n  //top level so there's no need to recurse here\n  //(they can also only occur for functions)\n}\n\nexports.abiEntryHasStorageParameters = abiEntryHasStorageParameters;","map":{"version":3,"mappings":"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","names":["debug","Object","enumerable","get","abi_utils_1","exports","type","inputs","stateMutability","computeSelectors","abi","undefined","assign","filter","abiEntry","map","abiHasPayableFallback","some","abisMatch","entry1","entry2","definitionMatchesAbi","definition","referenceDeclarations","Ast","Utils","definitionToAbi","_","topicsCount","selectorCount","anonymous","indexed","length","abiEntryIsObviouslyIllTyped","abiParameterIsObviouslyIllTyped","outputs","abiParameter","legalBaseTypeClasses","baseTypeClass","match","baseTypeClassIsObviouslyWrong","includes","components","abiEntryHasStorageParameters","isStorage","parameter","endsWith"],"sourceRoot":"","sources":["../../../lib/abi-data/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}