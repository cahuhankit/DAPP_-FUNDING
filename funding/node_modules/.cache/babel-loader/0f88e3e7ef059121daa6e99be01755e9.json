{"ast":null,"code":"const OS = require(\"os\");\nconst debug = require(\"debug\")(\"debug-utils\");\nconst util = require(\"util\");\nconst Codec = require(\"@truffle/codec\");\nconst BN = require(\"bn.js\");\nconst chromafi = require(\"@trufflesuite/chromafi\");\nconst hljsDefineSolidity = require(\"highlightjs-solidity\");\nhljsDefineSolidity(chromafi.hljs);\nconst chalk = require(\"chalk\");\nconst panicTable = {\n  0x01: \"Failed assertion\",\n  0x11: \"Arithmetic overflow\",\n  0x12: \"Division by zero\",\n  0x21: \"Enum value out of bounds\",\n  0x22: \"Malformed string\",\n  0x31: \"Array underflow\",\n  0x32: \"Index out of bounds\",\n  0x41: \"Oversized array or out of memory\",\n  0x51: \"Call to invalid function\"\n};\nconst verbosePanicTable = {\n  0x01: \"An assert() check was not satisfied.\",\n  0x11: \"An arithmetic overflow occurred outside an unchecked { ... } block.\",\n  0x12: \"A division by zero occurred.\",\n  0x21: \"An integer was cast to an enum type that cannot hold it.\",\n  0x22: \"There was an attempt to read an incorrectly-encoded string or bytestring.\",\n  0x31: \"An empty array's pop() method was called.\",\n  0x32: \"An array or bytestring was indexed or sliced with an out-of-bounds index.\",\n  0x41: \"An oversized array was created, or the contract ran out of memory.\",\n  0x51: \"An uninitialized internal function pointer was called.\"\n};\nconst commandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step line / step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction (include number to step multiple)\",\n  \"p\": \"print instruction & state (`p [mem|cal|sto]*`; see docs for more)\",\n  \"l\": \"print additional source context (`l [+<lines-ahead>] [-<lines-back>]`)\",\n  \"h\": \"print this help\",\n  \"v\": \"print variables and values (`v [bui|glo|con|loc]*`)\",\n  \":\": \"evaluate expression - see `v`\",\n  \"+\": \"add watch expression (`+:<expr>`)\",\n  \"-\": \"remove watch expression (-:<expr>)\",\n  \"?\": \"list existing watch expressions and breakpoints\",\n  \"b\": \"add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)\",\n  \"B\": \"remove breakpoint (similar to adding, or `B all` to remove all)\",\n  \"c\": \"continue until breakpoint\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load new transaction\",\n  \"T\": \"unload transaction\",\n  \"s\": \"print stacktrace\",\n  \"g\": \"turn on generated sources\",\n  \"G\": \"turn off generated sources except via `;`\",\n  \"y\": \"(if at end) reset & continue to final error\",\n  \"Y\": \"reset & continue to previous error\",\n  \"e\": \"Print recent events (`e [<number>|all]`)\"\n};\nconst shortCommandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction\",\n  \"p\": \"print state\",\n  \"l\": \"print context\",\n  \"h\": \"print help\",\n  \"v\": \"print variables\",\n  \":\": \"evaluate\",\n  \"+\": \"add watch\",\n  \"-\": \"remove watch\",\n  \"?\": \"list watches & breakpoints\",\n  \"b\": \"add breakpoint\",\n  \"B\": \"remove breakpoint\",\n  \"c\": \"continue\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load\",\n  \"T\": \"unload\",\n  \"s\": \"stacktrace\",\n  \"g\": \"turn on generated sources\",\n  \"G\": \"turn off generated sources\",\n  \"y\": \"reset & go to final error\",\n  \"Y\": \"reset & go to previous error\",\n  \"e\": \"print event log\"\n};\nconst truffleColors = {\n  mint: chalk.hex(\"#3FE0C5\"),\n  orange: chalk.hex(\"#E4A663\"),\n  pink: chalk.hex(\"#E911BD\"),\n  purple: chalk.hex(\"#8731E8\"),\n  green: chalk.hex(\"#00D717\"),\n  red: chalk.hex(\"#D60000\"),\n  yellow: chalk.hex(\"#F2E941\"),\n  blue: chalk.hex(\"#25A9E0\"),\n  comment: chalk.hsl(30, 20, 50),\n  watermelon: chalk.hex(\"#E86591\"),\n  periwinkle: chalk.hex(\"#7F9DD1\")\n};\nconst DEFAULT_TAB_WIDTH = 8;\nconst trufflePalette = {\n  /* base (chromafi special, not hljs) */\n  \"base\": chalk,\n  \"lineNumbers\": chalk,\n  \"trailingSpace\": chalk,\n  /* classes hljs-solidity actually uses */\n  \"keyword\": truffleColors.mint,\n  \"number\": truffleColors.red,\n  \"string\": truffleColors.green,\n  \"params\": truffleColors.pink,\n  \"builtIn\": truffleColors.watermelon,\n  \"built_in\": truffleColors.watermelon,\n  //just to be sure\n  \"literal\": truffleColors.watermelon,\n  \"function\": truffleColors.orange,\n  \"title\": truffleColors.orange,\n  \"class\": truffleColors.orange,\n  \"comment\": truffleColors.comment,\n  \"doctag\": truffleColors.comment,\n  \"operator\": truffleColors.blue,\n  \"punctuation\": truffleColors.purple,\n  /* classes it might soon use! */\n  \"meta\": truffleColors.pink,\n  \"metaString\": truffleColors.green,\n  \"meta-string\": truffleColors.green,\n  //similar\n  /* classes it doesn't currently use but notionally could */\n  \"type\": truffleColors.orange,\n  \"symbol\": truffleColors.orange,\n  \"metaKeyword\": truffleColors.mint,\n  \"meta-keyword\": truffleColors.mint,\n  //again, to be sure\n  \"property\": chalk,\n  //not putting any highlighting here for now\n  /* classes that don't make sense for Solidity */\n  \"regexp\": chalk,\n  //solidity does not have regexps\n  \"subst\": chalk,\n  //or string interpolation\n  \"name\": chalk,\n  //or s-expressions\n  \"builtInName\": chalk,\n  //or s-expressions, again\n  \"builtin-name\": chalk,\n  //just to be sure\n  /* classes for config, markup, CSS, templates, diffs (not programming) */\n  \"section\": chalk,\n  \"tag\": chalk,\n  \"attr\": chalk,\n  \"attribute\": chalk,\n  \"variable\": chalk,\n  \"bullet\": chalk,\n  \"code\": chalk,\n  \"emphasis\": chalk,\n  \"strong\": chalk,\n  \"formula\": chalk,\n  \"link\": chalk,\n  \"quote\": chalk,\n  \"selectorAttr\": chalk,\n  //lotta redundancy follows\n  \"selector-attr\": chalk,\n  \"selectorClass\": chalk,\n  \"selector-class\": chalk,\n  \"selectorId\": chalk,\n  \"selector-id\": chalk,\n  \"selectorPseudo\": chalk,\n  \"selector-pseudo\": chalk,\n  \"selectorTag\": chalk,\n  \"selector-tag\": chalk,\n  \"templateTag\": chalk,\n  \"template-tag\": chalk,\n  \"templateVariable\": chalk,\n  \"template-variable\": chalk,\n  \"addition\": chalk,\n  \"deletion\": chalk\n};\nvar DebugUtils = {\n  truffleColors,\n  //make these externally available\n\n  //panicCode may be either a number, BN, or decimal string\n  panicString: function (panicCode) {\n    let verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const unknownString = \"Unknown panic\";\n    const verboseUnknownString = \"A panic occurred of unrecognized type.\";\n    if (BN.isBN(panicCode)) {\n      try {\n        panicCode = panicCode.toNumber();\n      } catch (_) {\n        return verbose ? verboseUnknownString : unknownString;\n      }\n    }\n    return verbose ? verbosePanicTable[panicCode] || verboseUnknownString : panicTable[panicCode] || unknownString;\n  },\n  //attempts to test whether a given compilation is a real compilation,\n  //i.e., was compiled all at once.\n  //if it is real, it will definitely pass this test, barring a Solidity bug.\n  //(anyway worst case failing it just results in a recompilation)\n  //if it isn't real, but passes this test anyway... well, I'm hoping it should\n  //still be usable all the same!\n  isUsableCompilation: function (compilation) {\n    //check #1: is the source order reliable?\n    if (compilation.unreliableSourceOrder) {\n      debug(\"unreliable source order\");\n      return false;\n    }\n\n    //check #2: are (user) source indices consecutive?\n    //(while nonconsecutivity should not be a problem by itself, this probably\n    //indicates a name collision of a sort that will be fatal for other\n    //reasons)\n    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)\n    //to return true!  So I'm doing it this way even though it looks wrong\n    //(since the real concern is empty spots, not undefined, yet this turns\n    //this up anyhow)\n    if (compilation.sources.includes(undefined)) {\n      debug(\"nonconsecutive sources\");\n      return false;\n    }\n\n    //check #3: do generated source indices start directly after user source indices?\n    //(once again, if there's a gap between them, that's not a problem by itself,\n    //but it probably indicates that something bad is going on)\n    const lowestInternalIndex = Math.min(...compilation.contracts.map(contract => {\n      //find first defined index\n      let lowestConstructor = (contract.generatedSources || []).findIndex(x => x !== undefined);\n      if (lowestConstructor === -1) {\n        lowestConstructor = Infinity;\n      }\n      let lowestDeployed = (contract.deployedGeneratedSources || []).findIndex(x => x !== undefined);\n      if (lowestDeployed === -1) {\n        lowestDeployed = Infinity;\n      }\n      return Math.min(lowestConstructor, lowestDeployed);\n    }));\n    if (lowestInternalIndex !== Infinity) {\n      //Infinity would mean there were none\n      if (lowestInternalIndex !== compilation.sources.length) {\n        //if it's a usable compilation, these should be equal,\n        //as length = 1 + last user source\n        debug(\"gap before internal sources\");\n        return false;\n      }\n    }\n\n    //check #4: are there any AST ID collisions?\n    let astIds = new Set();\n    let allIDsUnseenSoFar = node => {\n      if (Array.isArray(node)) {\n        return node.every(allIDsUnseenSoFar);\n      } else if (node !== null && typeof node === \"object\") {\n        if (node.id !== undefined) {\n          if (astIds.has(node.id)) {\n            debug(\"id occurred twice: %o\", node.id);\n            return false;\n          } else {\n            astIds.add(node.id);\n          }\n        }\n        return Object.values(node).every(allIDsUnseenSoFar);\n      } else {\n        return true;\n      }\n    };\n\n    //now: walk each Solidity AST\n    //(and don't bother checking generated sources as they're\n    //never Solidity)\n    debug(\"checking Solidity ASTs for collisions\");\n    return compilation.sources.every(source => !source || source.language !== \"Solidity\" || allIDsUnseenSoFar(source.ast));\n  },\n  formatStartMessage: function (withTransaction) {\n    if (withTransaction) {\n      return \"Gathering information about your project and the transaction...\";\n    } else {\n      return \"Gathering information about your project...\";\n    }\n  },\n  formatTransactionStartMessage: function () {\n    return \"Gathering information about the transaction...\";\n  },\n  formatCommandDescription: function (commandId) {\n    return truffleColors.mint(`(${commandId})`) + \" \" + commandReference[commandId];\n  },\n  formatPrompt: function (network, txHash) {\n    return txHash !== undefined ? `debug(${network}:${txHash.substring(0, 10)}...)> ` : `debug(${network})> `;\n  },\n  formatAffectedInstances: function (instances) {\n    var hasAllSource = true;\n    var lines = Object.keys(instances).map(function (address) {\n      var instance = instances[address];\n      if (instance.contractName) {\n        return \" \" + address + \" - \" + instance.contractName;\n      }\n      if (!instance.source) {\n        hasAllSource = false;\n      }\n      return \" \" + address + \"(UNKNOWN)\";\n    });\n    if (lines.length === 0) {\n      lines.push(\"No affected addresses found.\");\n    }\n    if (!hasAllSource) {\n      lines.push(\"\");\n      lines.push(`${chalk.bold(\"Warning:\")} The source code for one or more contracts could not be found.`);\n    }\n    return lines.join(OS.EOL);\n  },\n  formatHelp: function () {\n    let lastCommand = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"n\";\n    var prefix = [\"Commands:\", truffleColors.mint(\"(enter)\") + \" last command entered (\" + shortCommandReference[lastCommand] + \")\"];\n    var commandSections = [[\"o\", \"i\", \"u\", \"n\"], [\"c\", \"Y\"], [\"y\"], [\";\"], [\"g\", \"G\"], [\"p\"], [\"l\"], [\"s\", \"e\"], [\"q\", \"r\", \"t\", \"T\"], [\"b\"], [\"B\"], [\"+\", \"-\"], [\"?\"], [\"v\"], [\":\", \"h\"]].map(function (shortcuts) {\n      return shortcuts.map(DebugUtils.formatCommandDescription).join(\", \");\n    });\n    var suffix = [\"\"];\n    var lines = prefix.concat(commandSections).concat(suffix);\n    return lines.join(OS.EOL);\n  },\n  tabsToSpaces: function (inputLine) {\n    let tabLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_TAB_WIDTH;\n    //note: I'm going to assume for these purposes that everything is\n    //basically ASCII and I don't have to worry about astral planes or\n    //grapheme clusters.  Sorry. :-/\n    let line = \"\";\n    let counter = 0;\n    for (let i = 0; i < inputLine.length; i++) {\n      if (inputLine[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        line += \" \".repeat(remaining);\n        counter = 0;\n      } else if (inputLine[i] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n      } else if (inputLine[i] === \"\\r\" && inputLine[i + 1] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n        i++;\n      } else {\n        line += inputLine[i];\n        counter++;\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n    }\n    return line;\n  },\n  formatLineNumberPrefix: function (line, number, cols) {\n    const prefix = String(number).padStart(cols) + \": \";\n    return prefix + line;\n  },\n  formatLinePointer: function (line, startCol, endCol, padding) {\n    let tabLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_TAB_WIDTH;\n    const prefix = \" \".repeat(padding + 2); //account for \": \"\n\n    let output = \"\";\n    let counter = 0;\n    for (let i = 0; i < line.length; i++) {\n      let pointedAt = i >= startCol && i < endCol;\n      let additional;\n      if (line[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        additional = \" \".repeat(remaining);\n        debug(\"advancing %d\", remaining);\n        counter = 0;\n      } else {\n        additional = \" \"; // just a space\n        counter++;\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n      if (pointedAt) {\n        additional = additional.replace(/./g, \"^\");\n      }\n      output += additional;\n    }\n    return truffleColors.purple(prefix + output);\n  },\n  //NOTE: source and uncolorizedSource here have already\n  //been split into lines here, they're not the raw text\n  //ALSO: assuming here that colorized source has been detabbed\n  //but that uncolorized source has not\n  formatRangeLines: function (source, range, uncolorizedSource) {\n    let contextBefore = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    let contextAfter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    // range is {\n    //   start: { line, column },\n    //   end: { line, column}\n    // }\n    //\n\n    var startIndex = Math.max(range.start.line - contextBefore, 0);\n    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);\n    var prefixLength = (endIndex + 1 + \"\").length; //+1 to account for 0-index\n\n    //note: beforeLines now includes the line itself\n    var beforeLines = source.slice(startIndex, range.start.line + 1).map((line, index) => {\n      let number = startIndex + index + 1; // 1 to account for 0-index\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var afterLines = source.slice(range.start.line + 1, endIndex + 1).map((line, index) => {\n      let number = range.start.line + 1 + index + 1; // 1 to account for 0-index\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var pointerStart = range.start.column;\n    var pointerEnd;\n    let uncolorizedLine = uncolorizedSource[range.start.line];\n\n    // range.end is undefined in some cases\n    // null/undefined check to avoid exceptions\n    if (range.end && range.start.line === range.end.line) {\n      // start and end are same line: pointer ends at column\n      pointerEnd = range.end.column;\n    } else {\n      pointerEnd = uncolorizedLine.length;\n    }\n    var allLines = beforeLines.concat([DebugUtils.formatLinePointer(\n    //the line-pointer formatter doesn't work right with colorized\n    //lines, so we pass in the uncolored version\n    uncolorizedLine, pointerStart, pointerEnd, prefixLength)], afterLines);\n    return allLines.join(OS.EOL);\n  },\n  formatBreakpointLocation: function (breakpoint, here, currentSourceId, sourceNames) {\n    let baseMessage;\n    if (breakpoint.start !== undefined && breakpoint.length !== undefined) {\n      baseMessage = here ? `this point in line ${breakpoint.line + 1}` : `a point in line ${breakpoint.line + 1}`;\n      //note we always add 1 to adjust for zero-indexing\n    } else {\n      baseMessage = `line ${breakpoint.line + 1}`;\n    }\n    if (breakpoint.sourceId !== currentSourceId) {\n      const sourceName = sourceNames[breakpoint.sourceId];\n      return baseMessage + ` in ${sourceName}`;\n    } else {\n      return baseMessage;\n    }\n  },\n  formatCurrentInstruction: function (instruction) {\n    const pc = this.formatPC(instruction.pc);\n    const formattedInstruction = this.formatInstruction(instruction);\n    return \"-> \" + truffleColors.mint(formattedInstruction) + pc;\n  },\n  formatInstruction: function (instruction) {\n    return truffleColors.mint(instruction.name + \" \" + (instruction.pushData || \"\"));\n  },\n  formatPC: function (pc) {\n    let hex = pc.toString(16);\n    if (hex.length % 2 !== 0) {\n      hex = \"0\" + hex; //ensure even length\n    }\n\n    return \" (PC=\" + pc.toString() + \", 0x\" + hex + \")\";\n  },\n  formatStack: function (stack) {\n    //stack here is an array of hex words (no \"0x\")\n    var formatted = stack.map((item, index) => {\n      item = truffleColors.orange(item);\n      item = \"  \" + item;\n      if (index === stack.length - 1) {\n        item += \" (top)\";\n      } else {\n        item += ` (${stack.length - index - 1} from top)`;\n      }\n      return item;\n    });\n    if (stack.length === 0) {\n      formatted.unshift(\"  No data on stack.\");\n    } else {\n      formatted.unshift(\"Stack:\");\n    }\n    return formatted.join(OS.EOL);\n  },\n  formatMemory: function (memory) {\n    //note memory here is an array of hex words (no \"0x\"),\n    //not a single long hex string\n\n    //get longest prefix needed;\n    //minimum of 2 so always show at least 2 hex digits\n    let maxPrefixLength = Math.max(2, ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length);\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++; //make sure to use even # of hex digits\n    }\n\n    let formatted = memory.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      return `  0x${address}:  ${truffleColors.pink(word)}`;\n    });\n    if (memory.length === 0) {\n      formatted.unshift(\"  No data in memory.\");\n    } else {\n      formatted.unshift(\"Memory:\");\n    }\n    return formatted.join(OS.EOL);\n  },\n  formatStorage: function (storage) {\n    //storage here is an object mapping hex words to hex words (no 0x)\n\n    //first: sort the keys (slice to clone as sort is in-place)\n    //note: we can use the default sort here; it will do the righ thing\n    let slots = Object.keys(storage).slice().sort();\n    let formatted = slots.map((slot, index) => {\n      if (index === 0 || !Codec.Conversion.toBN(slot).eq(Codec.Conversion.toBN(slots[index - 1]).addn(1))) {\n        return `0x${slot}:\\n` + `  ${truffleColors.blue(storage[slot])}`;\n      } else {\n        return `  ${truffleColors.blue(storage[slot])}`;\n      }\n    });\n    if (slots.length === 0) {\n      formatted.unshift(\"  No known relevant data found in storage.\");\n    } else {\n      formatted.unshift(\"Storage (partial view):\");\n    }\n    return formatted.join(OS.EOL);\n  },\n  formatCalldata: function (calldata) {\n    //takes a Uint8Array\n    let selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);\n    let words = [];\n    for (let wordIndex = Codec.Evm.Utils.SELECTOR_SIZE; wordIndex < calldata.length; wordIndex += Codec.Evm.Utils.WORD_SIZE) {\n      words.push(calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE));\n    }\n    let maxWordIndex = (words.length - 1) * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE;\n    let maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++;\n    }\n    let formattedSelector;\n    if (selector.length > 0) {\n      formattedSelector = \"Calldata:\\n\" + `  0x${\"00\".padStart(maxPrefixLength, \"0\")}:  ` + truffleColors.pink(Codec.Conversion.toHexString(selector).slice(2).padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"  \"));\n    } else {\n      formattedSelector = \"  No data in calldata.\";\n    }\n    let formatted = words.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      let data = Codec.Conversion.toHexString(word).slice(2).padEnd(2 * Codec.Evm.Utils.WORD_SIZE);\n      return `  0x${address}:  ${truffleColors.pink(data)}`;\n    });\n    formatted.unshift(formattedSelector);\n    return formatted.join(OS.EOL);\n  },\n  formatValue: function (value) {\n    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let nativized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    let valueToInspect = nativized ? value : new Codec.Export.ResultInspector(value);\n    return util.inspect(valueToInspect, inspectOptions).split(/\\r?\\n/g).map((line, i) => {\n      // don't indent first line\n      const padding = i > 0 ? Array(indent).join(\" \") : \"\";\n      return padding + line;\n    }).join(OS.EOL);\n  },\n  //note: only intended to be used for *custom* errors :)\n  formatCustomError: function (decoding) {\n    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    const name = decoding.definedIn ? `${decoding.definedIn.typeName}.${decoding.abi.name}` : decoding.abi.name;\n    return Codec.Export.formatFunctionLike(name, decoding.arguments, inspectOptions, false, indent);\n  },\n  formatStacktrace: function (stacktrace) {\n    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    //get message or panic code from stacktrace\n    const {\n      message,\n      panic,\n      custom\n    } = stacktrace[0];\n    //we want to print inner to outer, so first, let's\n    //reverse\n    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first\n    let lines = stacktrace.map(_ref => {\n      let {\n        functionName,\n        contractName,\n        address,\n        location,\n        isConstructor,\n        type\n      } = _ref;\n      let name;\n      if (contractName && functionName) {\n        name = `${contractName}.${functionName}`;\n      } else if (contractName) {\n        name = type === \"external\" && isConstructor ? `new ${contractName}` : contractName;\n        //for internal calls, it doesn't really make sense\n        //to write \"new Contract\"\n      } else if (functionName) {\n        name = functionName;\n      } else {\n        name = \"unknown function\";\n      }\n      let locationString;\n      if (location) {\n        let {\n          source: {\n            sourcePath\n          },\n          sourceRange: {\n            lines: {\n              start: {\n                line,\n                column\n              }\n            }\n          }\n        } = location;\n        locationString = sourcePath ? `${sourcePath}:${line + 1}:${column + 1}` //add 1 to account for 0-indexing\n        : \"unknown location\";\n      } else {\n        locationString = \"unknown location\";\n      }\n      let addressString = type === \"external\" ? address !== undefined ? ` [address ${address}]` : \" [unknown address]\" : \"\";\n      return `at ${name}${addressString} (${locationString})`;\n    });\n    let status = stacktrace[0].status;\n    if (status != undefined) {\n      let statusLine;\n      if (message !== undefined) {\n        statusLine = status ? `Error: Improper return (caused message: ${message})` : `Error: Revert (message: ${message})`;\n      } else if (panic !== undefined) {\n        statusLine = status ? `Panic: Improper return (caused ${DebugUtils.panicString(panic).toLowerCase()} (code 0x${panic.toString(16)}))` : `Panic: ${DebugUtils.panicString(panic)} (code 0x${panic.toString(16)})`;\n      } else if (custom !== undefined) {\n        statusLine = status ? `Error: Improper return (caused custom error)` : `Error: Revert (custom error)`;\n      } else {\n        statusLine = status ? \"Error: Improper return (may be an unexpected self-destruct)\" : \"Error: Revert or exceptional halt\";\n      }\n      lines.unshift(statusLine);\n    }\n    let indented = lines.map((line, index) => index === 0 ? line : \" \".repeat(indent) + line);\n    return indented.join(OS.EOL);\n  },\n  colorize: function (code) {\n    let language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Solidity\";\n    const options = {\n      lang: \"solidity\",\n      colors: trufflePalette,\n      //we want to turn off basically everything else, as we're\n      //handling padding & numbering manually\n      lineNumbers: false,\n      stripIndent: false,\n      codePad: 0,\n      tabsToSpaces: false,\n      //we handle this ourself and don't\n      //want chromafi's padding\n      lineEndPad: false\n    };\n    switch (language) {\n      case \"Solidity\":\n        return chromafi(code, options);\n      case \"Yul\":\n        options.lang = \"yul\"; //registered along with Solidity :)\n        return chromafi(code, options);\n      case \"Vyper\":\n        options.lang = \"python\"; //HACK -- close enough for now!\n        return chromafi(code, options);\n      default:\n        //don't highlight\n        return code;\n    }\n  },\n  //HACK\n  cleanThis: function (variables, replacement) {\n    return Object.assign({}, ...Object.entries(variables).map(_ref2 => {\n      let [variable, value] = _ref2;\n      return variable === \"this\" ? {\n        [replacement]: value\n      } : {\n        [variable]: value\n      };\n    }));\n  },\n  /**\n   * HACK warning!  This function modifies the debugger state\n   * and should only be used in light mode, at startup, in a very specific way!\n   *\n   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });\n   * const sources = await getTransactionSourcesBeforeStarting(bugger);\n   * await bugger.startFullMode();\n   *\n   * Don't go switching transactions after doing this, because there's no\n   * way at the moment to switch back into light mode in order to re-run\n   * this function.  You do *not* want to run this in full mode.\n   */\n  getTransactionSourcesBeforeStarting: async function (bugger) {\n    await bugger.reset();\n    let sources = {};\n    const {\n      controller\n    } = bugger.selectors;\n    while (!bugger.view(controller.current.trace.finished)) {\n      const source = bugger.view(controller.current.location.source);\n      const {\n        compilationId,\n        id,\n        internal\n      } = source;\n      //stepInto should skip internal sources, but there still might be\n      //one at the end\n      if (!internal && compilationId !== undefined && id !== undefined) {\n        sources[compilationId] = {\n          ...sources[compilationId],\n          [id]: source\n        };\n      }\n      await bugger.stepInto();\n    }\n    await bugger.reset();\n    //flatten sources before returning\n    return [].concat(...Object.values(sources).map(Object.values));\n  }\n};\nmodule.exports = DebugUtils;","map":{"version":3,"names":["OS","require","debug","util","Codec","BN","chromafi","hljsDefineSolidity","hljs","chalk","panicTable","verbosePanicTable","commandReference","shortCommandReference","truffleColors","mint","hex","orange","pink","purple","green","red","yellow","blue","comment","hsl","watermelon","periwinkle","DEFAULT_TAB_WIDTH","trufflePalette","DebugUtils","panicString","panicCode","verbose","unknownString","verboseUnknownString","isBN","toNumber","_","isUsableCompilation","compilation","unreliableSourceOrder","sources","includes","undefined","lowestInternalIndex","Math","min","contracts","map","contract","lowestConstructor","generatedSources","findIndex","x","Infinity","lowestDeployed","deployedGeneratedSources","length","astIds","Set","allIDsUnseenSoFar","node","Array","isArray","every","id","has","add","Object","values","source","language","ast","formatStartMessage","withTransaction","formatTransactionStartMessage","formatCommandDescription","commandId","formatPrompt","network","txHash","substring","formatAffectedInstances","instances","hasAllSource","lines","keys","address","instance","contractName","push","bold","join","EOL","formatHelp","lastCommand","prefix","commandSections","shortcuts","suffix","concat","tabsToSpaces","inputLine","tabLength","line","counter","i","remaining","repeat","formatLineNumberPrefix","number","cols","String","padStart","formatLinePointer","startCol","endCol","padding","output","pointedAt","additional","replace","formatRangeLines","range","uncolorizedSource","contextBefore","contextAfter","startIndex","max","start","endIndex","prefixLength","beforeLines","slice","index","afterLines","pointerStart","column","pointerEnd","uncolorizedLine","end","allLines","formatBreakpointLocation","breakpoint","here","currentSourceId","sourceNames","baseMessage","sourceId","sourceName","formatCurrentInstruction","instruction","pc","formatPC","formattedInstruction","formatInstruction","name","pushData","toString","formatStack","stack","formatted","item","unshift","formatMemory","memory","maxPrefixLength","Evm","Utils","WORD_SIZE","word","formatStorage","storage","slots","sort","slot","Conversion","toBN","eq","addn","formatCalldata","calldata","selector","SELECTOR_SIZE","words","wordIndex","maxWordIndex","formattedSelector","toHexString","data","padEnd","formatValue","value","indent","nativized","inspectOptions","colors","depth","maxArrayLength","breakLength","valueToInspect","Export","ResultInspector","inspect","split","formatCustomError","decoding","definedIn","typeName","abi","formatFunctionLike","arguments","formatStacktrace","stacktrace","message","panic","custom","reverse","functionName","location","isConstructor","type","locationString","sourcePath","sourceRange","addressString","status","statusLine","toLowerCase","indented","colorize","code","options","lang","lineNumbers","stripIndent","codePad","lineEndPad","cleanThis","variables","replacement","assign","entries","variable","getTransactionSourcesBeforeStarting","bugger","reset","controller","selectors","view","current","trace","finished","compilationId","internal","stepInto","module","exports"],"sources":["C:/Users/ankit/Desktop/FUND/funding/node_modules/@truffle/debug-utils/index.js"],"sourcesContent":["const OS = require(\"os\");\nconst debug = require(\"debug\")(\"debug-utils\");\nconst util = require(\"util\");\nconst Codec = require(\"@truffle/codec\");\nconst BN = require(\"bn.js\");\n\nconst chromafi = require(\"@trufflesuite/chromafi\");\nconst hljsDefineSolidity = require(\"highlightjs-solidity\");\nhljsDefineSolidity(chromafi.hljs);\nconst chalk = require(\"chalk\");\n\nconst panicTable = {\n  0x01: \"Failed assertion\",\n  0x11: \"Arithmetic overflow\",\n  0x12: \"Division by zero\",\n  0x21: \"Enum value out of bounds\",\n  0x22: \"Malformed string\",\n  0x31: \"Array underflow\",\n  0x32: \"Index out of bounds\",\n  0x41: \"Oversized array or out of memory\",\n  0x51: \"Call to invalid function\"\n};\n\nconst verbosePanicTable = {\n  0x01: \"An assert() check was not satisfied.\",\n  0x11: \"An arithmetic overflow occurred outside an unchecked { ... } block.\",\n  0x12: \"A division by zero occurred.\",\n  0x21: \"An integer was cast to an enum type that cannot hold it.\",\n  0x22: \"There was an attempt to read an incorrectly-encoded string or bytestring.\",\n  0x31: \"An empty array's pop() method was called.\",\n  0x32: \"An array or bytestring was indexed or sliced with an out-of-bounds index.\",\n  0x41: \"An oversized array was created, or the contract ran out of memory.\",\n  0x51: \"An uninitialized internal function pointer was called.\"\n};\n\nconst commandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step line / step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction (include number to step multiple)\",\n  \"p\": \"print instruction & state (`p [mem|cal|sto]*`; see docs for more)\",\n  \"l\": \"print additional source context (`l [+<lines-ahead>] [-<lines-back>]`)\",\n  \"h\": \"print this help\",\n  \"v\": \"print variables and values (`v [bui|glo|con|loc]*`)\",\n  \":\": \"evaluate expression - see `v`\",\n  \"+\": \"add watch expression (`+:<expr>`)\",\n  \"-\": \"remove watch expression (-:<expr>)\",\n  \"?\": \"list existing watch expressions and breakpoints\",\n  \"b\": \"add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)\",\n  \"B\": \"remove breakpoint (similar to adding, or `B all` to remove all)\",\n  \"c\": \"continue until breakpoint\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load new transaction\",\n  \"T\": \"unload transaction\",\n  \"s\": \"print stacktrace\",\n  \"g\": \"turn on generated sources\",\n  \"G\": \"turn off generated sources except via `;`\",\n  \"y\": \"(if at end) reset & continue to final error\",\n  \"Y\": \"reset & continue to previous error\",\n  \"e\": \"Print recent events (`e [<number>|all]`)\"\n};\n\nconst shortCommandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction\",\n  \"p\": \"print state\",\n  \"l\": \"print context\",\n  \"h\": \"print help\",\n  \"v\": \"print variables\",\n  \":\": \"evaluate\",\n  \"+\": \"add watch\",\n  \"-\": \"remove watch\",\n  \"?\": \"list watches & breakpoints\",\n  \"b\": \"add breakpoint\",\n  \"B\": \"remove breakpoint\",\n  \"c\": \"continue\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load\",\n  \"T\": \"unload\",\n  \"s\": \"stacktrace\",\n  \"g\": \"turn on generated sources\",\n  \"G\": \"turn off generated sources\",\n  \"y\": \"reset & go to final error\",\n  \"Y\": \"reset & go to previous error\",\n  \"e\": \"print event log\"\n};\n\nconst truffleColors = {\n  mint: chalk.hex(\"#3FE0C5\"),\n  orange: chalk.hex(\"#E4A663\"),\n  pink: chalk.hex(\"#E911BD\"),\n  purple: chalk.hex(\"#8731E8\"),\n  green: chalk.hex(\"#00D717\"),\n  red: chalk.hex(\"#D60000\"),\n  yellow: chalk.hex(\"#F2E941\"),\n  blue: chalk.hex(\"#25A9E0\"),\n  comment: chalk.hsl(30, 20, 50),\n  watermelon: chalk.hex(\"#E86591\"),\n  periwinkle: chalk.hex(\"#7F9DD1\")\n};\n\nconst DEFAULT_TAB_WIDTH = 8;\n\nconst trufflePalette = {\n  /* base (chromafi special, not hljs) */\n  \"base\": chalk,\n  \"lineNumbers\": chalk,\n  \"trailingSpace\": chalk,\n  /* classes hljs-solidity actually uses */\n  \"keyword\": truffleColors.mint,\n  \"number\": truffleColors.red,\n  \"string\": truffleColors.green,\n  \"params\": truffleColors.pink,\n  \"builtIn\": truffleColors.watermelon,\n  \"built_in\": truffleColors.watermelon, //just to be sure\n  \"literal\": truffleColors.watermelon,\n  \"function\": truffleColors.orange,\n  \"title\": truffleColors.orange,\n  \"class\": truffleColors.orange,\n  \"comment\": truffleColors.comment,\n  \"doctag\": truffleColors.comment,\n  \"operator\": truffleColors.blue,\n  \"punctuation\": truffleColors.purple,\n  /* classes it might soon use! */\n  \"meta\": truffleColors.pink,\n  \"metaString\": truffleColors.green,\n  \"meta-string\": truffleColors.green, //similar\n  /* classes it doesn't currently use but notionally could */\n  \"type\": truffleColors.orange,\n  \"symbol\": truffleColors.orange,\n  \"metaKeyword\": truffleColors.mint,\n  \"meta-keyword\": truffleColors.mint, //again, to be sure\n  \"property\": chalk, //not putting any highlighting here for now\n  /* classes that don't make sense for Solidity */\n  \"regexp\": chalk, //solidity does not have regexps\n  \"subst\": chalk, //or string interpolation\n  \"name\": chalk, //or s-expressions\n  \"builtInName\": chalk, //or s-expressions, again\n  \"builtin-name\": chalk, //just to be sure\n  /* classes for config, markup, CSS, templates, diffs (not programming) */\n  \"section\": chalk,\n  \"tag\": chalk,\n  \"attr\": chalk,\n  \"attribute\": chalk,\n  \"variable\": chalk,\n  \"bullet\": chalk,\n  \"code\": chalk,\n  \"emphasis\": chalk,\n  \"strong\": chalk,\n  \"formula\": chalk,\n  \"link\": chalk,\n  \"quote\": chalk,\n  \"selectorAttr\": chalk, //lotta redundancy follows\n  \"selector-attr\": chalk,\n  \"selectorClass\": chalk,\n  \"selector-class\": chalk,\n  \"selectorId\": chalk,\n  \"selector-id\": chalk,\n  \"selectorPseudo\": chalk,\n  \"selector-pseudo\": chalk,\n  \"selectorTag\": chalk,\n  \"selector-tag\": chalk,\n  \"templateTag\": chalk,\n  \"template-tag\": chalk,\n  \"templateVariable\": chalk,\n  \"template-variable\": chalk,\n  \"addition\": chalk,\n  \"deletion\": chalk\n};\n\nvar DebugUtils = {\n  truffleColors, //make these externally available\n\n  //panicCode may be either a number, BN, or decimal string\n  panicString: function (panicCode, verbose = false) {\n    const unknownString = \"Unknown panic\";\n    const verboseUnknownString = \"A panic occurred of unrecognized type.\";\n    if (BN.isBN(panicCode)) {\n      try {\n        panicCode = panicCode.toNumber();\n      } catch (_) {\n        return verbose ? verboseUnknownString : unknownString;\n      }\n    }\n    return verbose\n      ? verbosePanicTable[panicCode] || verboseUnknownString\n      : panicTable[panicCode] || unknownString;\n  },\n\n  //attempts to test whether a given compilation is a real compilation,\n  //i.e., was compiled all at once.\n  //if it is real, it will definitely pass this test, barring a Solidity bug.\n  //(anyway worst case failing it just results in a recompilation)\n  //if it isn't real, but passes this test anyway... well, I'm hoping it should\n  //still be usable all the same!\n  isUsableCompilation: function (compilation) {\n    //check #1: is the source order reliable?\n    if (compilation.unreliableSourceOrder) {\n      debug(\"unreliable source order\");\n      return false;\n    }\n\n    //check #2: are (user) source indices consecutive?\n    //(while nonconsecutivity should not be a problem by itself, this probably\n    //indicates a name collision of a sort that will be fatal for other\n    //reasons)\n    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)\n    //to return true!  So I'm doing it this way even though it looks wrong\n    //(since the real concern is empty spots, not undefined, yet this turns\n    //this up anyhow)\n    if (compilation.sources.includes(undefined)) {\n      debug(\"nonconsecutive sources\");\n      return false;\n    }\n\n    //check #3: do generated source indices start directly after user source indices?\n    //(once again, if there's a gap between them, that's not a problem by itself,\n    //but it probably indicates that something bad is going on)\n    const lowestInternalIndex = Math.min(\n      ...compilation.contracts.map(contract => {\n        //find first defined index\n        let lowestConstructor = (contract.generatedSources || []).findIndex(\n          x => x !== undefined\n        );\n        if (lowestConstructor === -1) {\n          lowestConstructor = Infinity;\n        }\n        let lowestDeployed = (\n          contract.deployedGeneratedSources || []\n        ).findIndex(x => x !== undefined);\n        if (lowestDeployed === -1) {\n          lowestDeployed = Infinity;\n        }\n        return Math.min(lowestConstructor, lowestDeployed);\n      })\n    );\n    if (lowestInternalIndex !== Infinity) {\n      //Infinity would mean there were none\n      if (lowestInternalIndex !== compilation.sources.length) {\n        //if it's a usable compilation, these should be equal,\n        //as length = 1 + last user source\n        debug(\"gap before internal sources\");\n        return false;\n      }\n    }\n\n    //check #4: are there any AST ID collisions?\n    let astIds = new Set();\n\n    let allIDsUnseenSoFar = node => {\n      if (Array.isArray(node)) {\n        return node.every(allIDsUnseenSoFar);\n      } else if (node !== null && typeof node === \"object\") {\n        if (node.id !== undefined) {\n          if (astIds.has(node.id)) {\n            debug(\"id occurred twice: %o\", node.id);\n            return false;\n          } else {\n            astIds.add(node.id);\n          }\n        }\n        return Object.values(node).every(allIDsUnseenSoFar);\n      } else {\n        return true;\n      }\n    };\n\n    //now: walk each Solidity AST\n    //(and don't bother checking generated sources as they're\n    //never Solidity)\n    debug(\"checking Solidity ASTs for collisions\");\n    return compilation.sources.every(\n      source =>\n        !source ||\n        source.language !== \"Solidity\" ||\n        allIDsUnseenSoFar(source.ast)\n    );\n  },\n\n  formatStartMessage: function (withTransaction) {\n    if (withTransaction) {\n      return \"Gathering information about your project and the transaction...\";\n    } else {\n      return \"Gathering information about your project...\";\n    }\n  },\n\n  formatTransactionStartMessage: function () {\n    return \"Gathering information about the transaction...\";\n  },\n\n  formatCommandDescription: function (commandId) {\n    return (\n      truffleColors.mint(`(${commandId})`) + \" \" + commandReference[commandId]\n    );\n  },\n\n  formatPrompt: function (network, txHash) {\n    return txHash !== undefined\n      ? `debug(${network}:${txHash.substring(0, 10)}...)> `\n      : `debug(${network})> `;\n  },\n\n  formatAffectedInstances: function (instances) {\n    var hasAllSource = true;\n\n    var lines = Object.keys(instances).map(function (address) {\n      var instance = instances[address];\n\n      if (instance.contractName) {\n        return \" \" + address + \" - \" + instance.contractName;\n      }\n\n      if (!instance.source) {\n        hasAllSource = false;\n      }\n\n      return \" \" + address + \"(UNKNOWN)\";\n    });\n\n    if (lines.length === 0) {\n      lines.push(\"No affected addresses found.\");\n    }\n\n    if (!hasAllSource) {\n      lines.push(\"\");\n      lines.push(\n        `${chalk.bold(\n          \"Warning:\"\n        )} The source code for one or more contracts could not be found.`\n      );\n    }\n\n    return lines.join(OS.EOL);\n  },\n\n  formatHelp: function (lastCommand = \"n\") {\n    var prefix = [\n      \"Commands:\",\n      truffleColors.mint(\"(enter)\") +\n        \" last command entered (\" +\n        shortCommandReference[lastCommand] +\n        \")\"\n    ];\n\n    var commandSections = [\n      [\"o\", \"i\", \"u\", \"n\"],\n      [\"c\", \"Y\"],\n      [\"y\"],\n      [\";\"],\n      [\"g\", \"G\"],\n      [\"p\"],\n      [\"l\"],\n      [\"s\", \"e\"],\n      [\"q\", \"r\", \"t\", \"T\"],\n      [\"b\"],\n      [\"B\"],\n      [\"+\", \"-\"],\n      [\"?\"],\n      [\"v\"],\n      [\":\", \"h\"]\n    ].map(function (shortcuts) {\n      return shortcuts.map(DebugUtils.formatCommandDescription).join(\", \");\n    });\n\n    var suffix = [\"\"];\n\n    var lines = prefix.concat(commandSections).concat(suffix);\n\n    return lines.join(OS.EOL);\n  },\n\n  tabsToSpaces: function (inputLine, tabLength = DEFAULT_TAB_WIDTH) {\n    //note: I'm going to assume for these purposes that everything is\n    //basically ASCII and I don't have to worry about astral planes or\n    //grapheme clusters.  Sorry. :-/\n    let line = \"\";\n    let counter = 0;\n    for (let i = 0; i < inputLine.length; i++) {\n      if (inputLine[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        line += \" \".repeat(remaining);\n        counter = 0;\n      } else if (inputLine[i] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n      } else if (inputLine[i] === \"\\r\" && inputLine[i + 1] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n        i++;\n      } else {\n        line += inputLine[i];\n        counter++;\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n    }\n    return line;\n  },\n\n  formatLineNumberPrefix: function (line, number, cols) {\n    const prefix = String(number).padStart(cols) + \": \";\n\n    return prefix + line;\n  },\n\n  formatLinePointer: function (\n    line,\n    startCol,\n    endCol,\n    padding,\n    tabLength = DEFAULT_TAB_WIDTH\n  ) {\n    const prefix = \" \".repeat(padding + 2); //account for \": \"\n\n    let output = \"\";\n    let counter = 0;\n    for (let i = 0; i < line.length; i++) {\n      let pointedAt = i >= startCol && i < endCol;\n\n      let additional;\n      if (line[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        additional = \" \".repeat(remaining);\n        debug(\"advancing %d\", remaining);\n        counter = 0;\n      } else {\n        additional = \" \"; // just a space\n        counter++;\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n\n      if (pointedAt) {\n        additional = additional.replace(/./g, \"^\");\n      }\n\n      output += additional;\n    }\n\n    return truffleColors.purple(prefix + output);\n  },\n\n  //NOTE: source and uncolorizedSource here have already\n  //been split into lines here, they're not the raw text\n  //ALSO: assuming here that colorized source has been detabbed\n  //but that uncolorized source has not\n  formatRangeLines: function (\n    source,\n    range,\n    uncolorizedSource,\n    contextBefore = 2,\n    contextAfter = 0\n  ) {\n    // range is {\n    //   start: { line, column },\n    //   end: { line, column}\n    // }\n    //\n\n    var startIndex = Math.max(range.start.line - contextBefore, 0);\n    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);\n\n    var prefixLength = (endIndex + 1 + \"\").length; //+1 to account for 0-index\n\n    //note: beforeLines now includes the line itself\n    var beforeLines = source\n      .slice(startIndex, range.start.line + 1)\n      .map((line, index) => {\n        let number = startIndex + index + 1; // 1 to account for 0-index\n        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n      });\n    var afterLines = source\n      .slice(range.start.line + 1, endIndex + 1)\n      .map((line, index) => {\n        let number = range.start.line + 1 + index + 1; // 1 to account for 0-index\n        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n      });\n\n    var pointerStart = range.start.column;\n    var pointerEnd;\n\n    let uncolorizedLine = uncolorizedSource[range.start.line];\n\n    // range.end is undefined in some cases\n    // null/undefined check to avoid exceptions\n    if (range.end && range.start.line === range.end.line) {\n      // start and end are same line: pointer ends at column\n      pointerEnd = range.end.column;\n    } else {\n      pointerEnd = uncolorizedLine.length;\n    }\n\n    var allLines = beforeLines.concat(\n      [\n        DebugUtils.formatLinePointer(\n          //the line-pointer formatter doesn't work right with colorized\n          //lines, so we pass in the uncolored version\n          uncolorizedLine,\n          pointerStart,\n          pointerEnd,\n          prefixLength\n        )\n      ],\n      afterLines\n    );\n\n    return allLines.join(OS.EOL);\n  },\n\n  formatBreakpointLocation: function (\n    breakpoint,\n    here,\n    currentSourceId,\n    sourceNames\n  ) {\n    let baseMessage;\n    if (breakpoint.start !== undefined && breakpoint.length !== undefined) {\n      baseMessage = here\n        ? `this point in line ${breakpoint.line + 1}`\n        : `a point in line ${breakpoint.line + 1}`;\n      //note we always add 1 to adjust for zero-indexing\n    } else {\n      baseMessage = `line ${breakpoint.line + 1}`;\n    }\n    if (breakpoint.sourceId !== currentSourceId) {\n      const sourceName = sourceNames[breakpoint.sourceId];\n      return baseMessage + ` in ${sourceName}`;\n    } else {\n      return baseMessage;\n    }\n  },\n\n  formatCurrentInstruction: function (instruction) {\n    const pc = this.formatPC(instruction.pc);\n    const formattedInstruction = this.formatInstruction(instruction);\n    return \"-> \" + truffleColors.mint(formattedInstruction) + pc;\n  },\n\n  formatInstruction: function (instruction) {\n    return truffleColors.mint(\n      instruction.name + \" \" + (instruction.pushData || \"\")\n    );\n  },\n\n  formatPC: function (pc) {\n    let hex = pc.toString(16);\n    if (hex.length % 2 !== 0) {\n      hex = \"0\" + hex; //ensure even length\n    }\n    return \" (PC=\" + pc.toString() + \", 0x\" + hex + \")\";\n  },\n\n  formatStack: function (stack) {\n    //stack here is an array of hex words (no \"0x\")\n    var formatted = stack.map((item, index) => {\n      item = truffleColors.orange(item);\n      item = \"  \" + item;\n      if (index === stack.length - 1) {\n        item += \" (top)\";\n      } else {\n        item += ` (${stack.length - index - 1} from top)`;\n      }\n\n      return item;\n    });\n\n    if (stack.length === 0) {\n      formatted.unshift(\"  No data on stack.\");\n    } else {\n      formatted.unshift(\"Stack:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatMemory: function (memory) {\n    //note memory here is an array of hex words (no \"0x\"),\n    //not a single long hex string\n\n    //get longest prefix needed;\n    //minimum of 2 so always show at least 2 hex digits\n    let maxPrefixLength = Math.max(\n      2,\n      ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length\n    );\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++; //make sure to use even # of hex digits\n    }\n\n    let formatted = memory.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE)\n        .toString(16)\n        .padStart(maxPrefixLength, \"0\");\n      return `  0x${address}:  ${truffleColors.pink(word)}`;\n    });\n\n    if (memory.length === 0) {\n      formatted.unshift(\"  No data in memory.\");\n    } else {\n      formatted.unshift(\"Memory:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatStorage: function (storage) {\n    //storage here is an object mapping hex words to hex words (no 0x)\n\n    //first: sort the keys (slice to clone as sort is in-place)\n    //note: we can use the default sort here; it will do the righ thing\n    let slots = Object.keys(storage).slice().sort();\n\n    let formatted = slots.map((slot, index) => {\n      if (\n        index === 0 ||\n        !Codec.Conversion.toBN(slot).eq(\n          Codec.Conversion.toBN(slots[index - 1]).addn(1)\n        )\n      ) {\n        return `0x${slot}:\\n` + `  ${truffleColors.blue(storage[slot])}`;\n      } else {\n        return `  ${truffleColors.blue(storage[slot])}`;\n      }\n    });\n\n    if (slots.length === 0) {\n      formatted.unshift(\"  No known relevant data found in storage.\");\n    } else {\n      formatted.unshift(\"Storage (partial view):\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatCalldata: function (calldata) {\n    //takes a Uint8Array\n    let selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);\n    let words = [];\n    for (\n      let wordIndex = Codec.Evm.Utils.SELECTOR_SIZE;\n      wordIndex < calldata.length;\n      wordIndex += Codec.Evm.Utils.WORD_SIZE\n    ) {\n      words.push(\n        calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE)\n      );\n    }\n    let maxWordIndex =\n      (words.length - 1) * Codec.Evm.Utils.WORD_SIZE +\n      Codec.Evm.Utils.SELECTOR_SIZE;\n    let maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++;\n    }\n    let formattedSelector;\n    if (selector.length > 0) {\n      formattedSelector =\n        \"Calldata:\\n\" +\n        `  0x${\"00\".padStart(maxPrefixLength, \"0\")}:  ` +\n        truffleColors.pink(\n          Codec.Conversion.toHexString(selector)\n            .slice(2)\n            .padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"  \")\n        );\n    } else {\n      formattedSelector = \"  No data in calldata.\";\n    }\n\n    let formatted = words.map((word, index) => {\n      let address = (\n        index * Codec.Evm.Utils.WORD_SIZE +\n        Codec.Evm.Utils.SELECTOR_SIZE\n      )\n        .toString(16)\n        .padStart(maxPrefixLength, \"0\");\n      let data = Codec.Conversion.toHexString(word)\n        .slice(2)\n        .padEnd(2 * Codec.Evm.Utils.WORD_SIZE);\n      return `  0x${address}:  ${truffleColors.pink(data)}`;\n    });\n\n    formatted.unshift(formattedSelector);\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatValue: function (value, indent = 0, nativized = false) {\n    let inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    let valueToInspect = nativized\n      ? value\n      : new Codec.Export.ResultInspector(value);\n    return util\n      .inspect(valueToInspect, inspectOptions)\n      .split(/\\r?\\n/g)\n      .map((line, i) => {\n        // don't indent first line\n        const padding = i > 0 ? Array(indent).join(\" \") : \"\";\n        return padding + line;\n      })\n      .join(OS.EOL);\n  },\n\n  //note: only intended to be used for *custom* errors :)\n  formatCustomError: function (decoding, indent = 0) {\n    const inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    const name = decoding.definedIn\n      ? `${decoding.definedIn.typeName}.${decoding.abi.name}`\n      : decoding.abi.name;\n    return Codec.Export.formatFunctionLike(\n      name,\n      decoding.arguments,\n      inspectOptions,\n      false,\n      indent\n    );\n  },\n\n  formatStacktrace: function (stacktrace, indent = 2) {\n    //get message or panic code from stacktrace\n    const { message, panic, custom } = stacktrace[0];\n    //we want to print inner to outer, so first, let's\n    //reverse\n    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first\n    let lines = stacktrace.map(\n      ({\n        functionName,\n        contractName,\n        address,\n        location,\n        isConstructor,\n        type\n      }) => {\n        let name;\n        if (contractName && functionName) {\n          name = `${contractName}.${functionName}`;\n        } else if (contractName) {\n          name =\n            type === \"external\" && isConstructor\n              ? `new ${contractName}`\n              : contractName;\n          //for internal calls, it doesn't really make sense\n          //to write \"new Contract\"\n        } else if (functionName) {\n          name = functionName;\n        } else {\n          name = \"unknown function\";\n        }\n        let locationString;\n        if (location) {\n          let {\n            source: { sourcePath },\n            sourceRange: {\n              lines: {\n                start: { line, column }\n              }\n            }\n          } = location;\n          locationString = sourcePath\n            ? `${sourcePath}:${line + 1}:${column + 1}` //add 1 to account for 0-indexing\n            : \"unknown location\";\n        } else {\n          locationString = \"unknown location\";\n        }\n        let addressString =\n          type === \"external\"\n            ? address !== undefined\n              ? ` [address ${address}]`\n              : \" [unknown address]\"\n            : \"\";\n        return `at ${name}${addressString} (${locationString})`;\n      }\n    );\n    let status = stacktrace[0].status;\n    if (status != undefined) {\n      let statusLine;\n      if (message !== undefined) {\n        statusLine = status\n          ? `Error: Improper return (caused message: ${message})`\n          : `Error: Revert (message: ${message})`;\n      } else if (panic !== undefined) {\n        statusLine = status\n          ? `Panic: Improper return (caused ${DebugUtils.panicString(\n              panic\n            ).toLowerCase()} (code 0x${panic.toString(16)}))`\n          : `Panic: ${DebugUtils.panicString(panic)} (code 0x${panic.toString(\n              16\n            )})`;\n      } else if (custom !== undefined) {\n        statusLine = status\n          ? `Error: Improper return (caused custom error)`\n          : `Error: Revert (custom error)`;\n      } else {\n        statusLine = status\n          ? \"Error: Improper return (may be an unexpected self-destruct)\"\n          : \"Error: Revert or exceptional halt\";\n      }\n      lines.unshift(statusLine);\n    }\n    let indented = lines.map((line, index) =>\n      index === 0 ? line : \" \".repeat(indent) + line\n    );\n    return indented.join(OS.EOL);\n  },\n\n  colorize: function (code, language = \"Solidity\") {\n    const options = {\n      lang: \"solidity\",\n      colors: trufflePalette,\n      //we want to turn off basically everything else, as we're\n      //handling padding & numbering manually\n      lineNumbers: false,\n      stripIndent: false,\n      codePad: 0,\n      tabsToSpaces: false, //we handle this ourself and don't\n      //want chromafi's padding\n      lineEndPad: false\n    };\n    switch (language) {\n      case \"Solidity\":\n        return chromafi(code, options);\n      case \"Yul\":\n        options.lang = \"yul\"; //registered along with Solidity :)\n        return chromafi(code, options);\n      case \"Vyper\":\n        options.lang = \"python\"; //HACK -- close enough for now!\n        return chromafi(code, options);\n      default:\n        //don't highlight\n        return code;\n    }\n  },\n\n  //HACK\n  cleanThis: function (variables, replacement) {\n    return Object.assign(\n      {},\n      ...Object.entries(variables).map(([variable, value]) =>\n        variable === \"this\" ? { [replacement]: value } : { [variable]: value }\n      )\n    );\n  },\n\n  /**\n   * HACK warning!  This function modifies the debugger state\n   * and should only be used in light mode, at startup, in a very specific way!\n   *\n   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });\n   * const sources = await getTransactionSourcesBeforeStarting(bugger);\n   * await bugger.startFullMode();\n   *\n   * Don't go switching transactions after doing this, because there's no\n   * way at the moment to switch back into light mode in order to re-run\n   * this function.  You do *not* want to run this in full mode.\n   */\n  getTransactionSourcesBeforeStarting: async function (bugger) {\n    await bugger.reset();\n    let sources = {};\n    const { controller } = bugger.selectors;\n    while (!bugger.view(controller.current.trace.finished)) {\n      const source = bugger.view(controller.current.location.source);\n      const { compilationId, id, internal } = source;\n      //stepInto should skip internal sources, but there still might be\n      //one at the end\n      if (!internal && compilationId !== undefined && id !== undefined) {\n        sources[compilationId] = {\n          ...sources[compilationId],\n          [id]: source\n        };\n      }\n      await bugger.stepInto();\n    }\n    await bugger.reset();\n    //flatten sources before returning\n    return [].concat(...Object.values(sources).map(Object.values));\n  }\n};\n\nmodule.exports = DebugUtils;\n"],"mappings":"AAAA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC;AACxB,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAO,CAAC,CAAC,aAAa,CAAC;AAC7C,MAAME,IAAI,GAAGF,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMG,KAAK,GAAGH,OAAO,CAAC,gBAAgB,CAAC;AACvC,MAAMI,EAAE,GAAGJ,OAAO,CAAC,OAAO,CAAC;AAE3B,MAAMK,QAAQ,GAAGL,OAAO,CAAC,wBAAwB,CAAC;AAClD,MAAMM,kBAAkB,GAAGN,OAAO,CAAC,sBAAsB,CAAC;AAC1DM,kBAAkB,CAACD,QAAQ,CAACE,IAAI,CAAC;AACjC,MAAMC,KAAK,GAAGR,OAAO,CAAC,OAAO,CAAC;AAE9B,MAAMS,UAAU,GAAG;EACjB,IAAI,EAAE,kBAAkB;EACxB,IAAI,EAAE,qBAAqB;EAC3B,IAAI,EAAE,kBAAkB;EACxB,IAAI,EAAE,0BAA0B;EAChC,IAAI,EAAE,kBAAkB;EACxB,IAAI,EAAE,iBAAiB;EACvB,IAAI,EAAE,qBAAqB;EAC3B,IAAI,EAAE,kCAAkC;EACxC,IAAI,EAAE;AACR,CAAC;AAED,MAAMC,iBAAiB,GAAG;EACxB,IAAI,EAAE,sCAAsC;EAC5C,IAAI,EAAE,qEAAqE;EAC3E,IAAI,EAAE,8BAA8B;EACpC,IAAI,EAAE,0DAA0D;EAChE,IAAI,EAAE,2EAA2E;EACjF,IAAI,EAAE,2CAA2C;EACjD,IAAI,EAAE,2EAA2E;EACjF,IAAI,EAAE,oEAAoE;EAC1E,IAAI,EAAE;AACR,CAAC;AAED,MAAMC,gBAAgB,GAAG;EACvB,GAAG,EAAE,WAAW;EAChB,GAAG,EAAE,uBAAuB;EAC5B,GAAG,EAAE,UAAU;EACf,GAAG,EAAE,WAAW;EAChB,GAAG,EAAE,oDAAoD;EACzD,GAAG,EAAE,mEAAmE;EACxE,GAAG,EAAE,wEAAwE;EAC7E,GAAG,EAAE,iBAAiB;EACtB,GAAG,EAAE,qDAAqD;EAC1D,GAAG,EAAE,+BAA+B;EACpC,GAAG,EAAE,mCAAmC;EACxC,GAAG,EAAE,oCAAoC;EACzC,GAAG,EAAE,iDAAiD;EACtD,GAAG,EAAE,yEAAyE;EAC9E,GAAG,EAAE,iEAAiE;EACtE,GAAG,EAAE,2BAA2B;EAChC,GAAG,EAAE,MAAM;EACX,GAAG,EAAE,OAAO;EACZ,GAAG,EAAE,sBAAsB;EAC3B,GAAG,EAAE,oBAAoB;EACzB,GAAG,EAAE,kBAAkB;EACvB,GAAG,EAAE,2BAA2B;EAChC,GAAG,EAAE,2CAA2C;EAChD,GAAG,EAAE,6CAA6C;EAClD,GAAG,EAAE,oCAAoC;EACzC,GAAG,EAAE;AACP,CAAC;AAED,MAAMC,qBAAqB,GAAG;EAC5B,GAAG,EAAE,WAAW;EAChB,GAAG,EAAE,WAAW;EAChB,GAAG,EAAE,UAAU;EACf,GAAG,EAAE,WAAW;EAChB,GAAG,EAAE,kBAAkB;EACvB,GAAG,EAAE,aAAa;EAClB,GAAG,EAAE,eAAe;EACpB,GAAG,EAAE,YAAY;EACjB,GAAG,EAAE,iBAAiB;EACtB,GAAG,EAAE,UAAU;EACf,GAAG,EAAE,WAAW;EAChB,GAAG,EAAE,cAAc;EACnB,GAAG,EAAE,4BAA4B;EACjC,GAAG,EAAE,gBAAgB;EACrB,GAAG,EAAE,mBAAmB;EACxB,GAAG,EAAE,UAAU;EACf,GAAG,EAAE,MAAM;EACX,GAAG,EAAE,OAAO;EACZ,GAAG,EAAE,MAAM;EACX,GAAG,EAAE,QAAQ;EACb,GAAG,EAAE,YAAY;EACjB,GAAG,EAAE,2BAA2B;EAChC,GAAG,EAAE,4BAA4B;EACjC,GAAG,EAAE,2BAA2B;EAChC,GAAG,EAAE,8BAA8B;EACnC,GAAG,EAAE;AACP,CAAC;AAED,MAAMC,aAAa,GAAG;EACpBC,IAAI,EAAEN,KAAK,CAACO,GAAG,CAAC,SAAS,CAAC;EAC1BC,MAAM,EAAER,KAAK,CAACO,GAAG,CAAC,SAAS,CAAC;EAC5BE,IAAI,EAAET,KAAK,CAACO,GAAG,CAAC,SAAS,CAAC;EAC1BG,MAAM,EAAEV,KAAK,CAACO,GAAG,CAAC,SAAS,CAAC;EAC5BI,KAAK,EAAEX,KAAK,CAACO,GAAG,CAAC,SAAS,CAAC;EAC3BK,GAAG,EAAEZ,KAAK,CAACO,GAAG,CAAC,SAAS,CAAC;EACzBM,MAAM,EAAEb,KAAK,CAACO,GAAG,CAAC,SAAS,CAAC;EAC5BO,IAAI,EAAEd,KAAK,CAACO,GAAG,CAAC,SAAS,CAAC;EAC1BQ,OAAO,EAAEf,KAAK,CAACgB,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;EAC9BC,UAAU,EAAEjB,KAAK,CAACO,GAAG,CAAC,SAAS,CAAC;EAChCW,UAAU,EAAElB,KAAK,CAACO,GAAG,CAAC,SAAS;AACjC,CAAC;AAED,MAAMY,iBAAiB,GAAG,CAAC;AAE3B,MAAMC,cAAc,GAAG;EACrB;EACA,MAAM,EAAEpB,KAAK;EACb,aAAa,EAAEA,KAAK;EACpB,eAAe,EAAEA,KAAK;EACtB;EACA,SAAS,EAAEK,aAAa,CAACC,IAAI;EAC7B,QAAQ,EAAED,aAAa,CAACO,GAAG;EAC3B,QAAQ,EAAEP,aAAa,CAACM,KAAK;EAC7B,QAAQ,EAAEN,aAAa,CAACI,IAAI;EAC5B,SAAS,EAAEJ,aAAa,CAACY,UAAU;EACnC,UAAU,EAAEZ,aAAa,CAACY,UAAU;EAAE;EACtC,SAAS,EAAEZ,aAAa,CAACY,UAAU;EACnC,UAAU,EAAEZ,aAAa,CAACG,MAAM;EAChC,OAAO,EAAEH,aAAa,CAACG,MAAM;EAC7B,OAAO,EAAEH,aAAa,CAACG,MAAM;EAC7B,SAAS,EAAEH,aAAa,CAACU,OAAO;EAChC,QAAQ,EAAEV,aAAa,CAACU,OAAO;EAC/B,UAAU,EAAEV,aAAa,CAACS,IAAI;EAC9B,aAAa,EAAET,aAAa,CAACK,MAAM;EACnC;EACA,MAAM,EAAEL,aAAa,CAACI,IAAI;EAC1B,YAAY,EAAEJ,aAAa,CAACM,KAAK;EACjC,aAAa,EAAEN,aAAa,CAACM,KAAK;EAAE;EACpC;EACA,MAAM,EAAEN,aAAa,CAACG,MAAM;EAC5B,QAAQ,EAAEH,aAAa,CAACG,MAAM;EAC9B,aAAa,EAAEH,aAAa,CAACC,IAAI;EACjC,cAAc,EAAED,aAAa,CAACC,IAAI;EAAE;EACpC,UAAU,EAAEN,KAAK;EAAE;EACnB;EACA,QAAQ,EAAEA,KAAK;EAAE;EACjB,OAAO,EAAEA,KAAK;EAAE;EAChB,MAAM,EAAEA,KAAK;EAAE;EACf,aAAa,EAAEA,KAAK;EAAE;EACtB,cAAc,EAAEA,KAAK;EAAE;EACvB;EACA,SAAS,EAAEA,KAAK;EAChB,KAAK,EAAEA,KAAK;EACZ,MAAM,EAAEA,KAAK;EACb,WAAW,EAAEA,KAAK;EAClB,UAAU,EAAEA,KAAK;EACjB,QAAQ,EAAEA,KAAK;EACf,MAAM,EAAEA,KAAK;EACb,UAAU,EAAEA,KAAK;EACjB,QAAQ,EAAEA,KAAK;EACf,SAAS,EAAEA,KAAK;EAChB,MAAM,EAAEA,KAAK;EACb,OAAO,EAAEA,KAAK;EACd,cAAc,EAAEA,KAAK;EAAE;EACvB,eAAe,EAAEA,KAAK;EACtB,eAAe,EAAEA,KAAK;EACtB,gBAAgB,EAAEA,KAAK;EACvB,YAAY,EAAEA,KAAK;EACnB,aAAa,EAAEA,KAAK;EACpB,gBAAgB,EAAEA,KAAK;EACvB,iBAAiB,EAAEA,KAAK;EACxB,aAAa,EAAEA,KAAK;EACpB,cAAc,EAAEA,KAAK;EACrB,aAAa,EAAEA,KAAK;EACpB,cAAc,EAAEA,KAAK;EACrB,kBAAkB,EAAEA,KAAK;EACzB,mBAAmB,EAAEA,KAAK;EAC1B,UAAU,EAAEA,KAAK;EACjB,UAAU,EAAEA;AACd,CAAC;AAED,IAAIqB,UAAU,GAAG;EACfhB,aAAa;EAAE;;EAEf;EACAiB,WAAW,EAAE,UAAUC,SAAS,EAAmB;IAAA,IAAjBC,OAAO,uEAAG,KAAK;IAC/C,MAAMC,aAAa,GAAG,eAAe;IACrC,MAAMC,oBAAoB,GAAG,wCAAwC;IACrE,IAAI9B,EAAE,CAAC+B,IAAI,CAACJ,SAAS,CAAC,EAAE;MACtB,IAAI;QACFA,SAAS,GAAGA,SAAS,CAACK,QAAQ,EAAE;MAClC,CAAC,CAAC,OAAOC,CAAC,EAAE;QACV,OAAOL,OAAO,GAAGE,oBAAoB,GAAGD,aAAa;MACvD;IACF;IACA,OAAOD,OAAO,GACVtB,iBAAiB,CAACqB,SAAS,CAAC,IAAIG,oBAAoB,GACpDzB,UAAU,CAACsB,SAAS,CAAC,IAAIE,aAAa;EAC5C,CAAC;EAED;EACA;EACA;EACA;EACA;EACA;EACAK,mBAAmB,EAAE,UAAUC,WAAW,EAAE;IAC1C;IACA,IAAIA,WAAW,CAACC,qBAAqB,EAAE;MACrCvC,KAAK,CAAC,yBAAyB,CAAC;MAChC,OAAO,KAAK;IACd;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIsC,WAAW,CAACE,OAAO,CAACC,QAAQ,CAACC,SAAS,CAAC,EAAE;MAC3C1C,KAAK,CAAC,wBAAwB,CAAC;MAC/B,OAAO,KAAK;IACd;;IAEA;IACA;IACA;IACA,MAAM2C,mBAAmB,GAAGC,IAAI,CAACC,GAAG,CAClC,GAAGP,WAAW,CAACQ,SAAS,CAACC,GAAG,CAACC,QAAQ,IAAI;MACvC;MACA,IAAIC,iBAAiB,GAAG,CAACD,QAAQ,CAACE,gBAAgB,IAAI,EAAE,EAAEC,SAAS,CACjEC,CAAC,IAAIA,CAAC,KAAKV,SAAS,CACrB;MACD,IAAIO,iBAAiB,KAAK,CAAC,CAAC,EAAE;QAC5BA,iBAAiB,GAAGI,QAAQ;MAC9B;MACA,IAAIC,cAAc,GAAG,CACnBN,QAAQ,CAACO,wBAAwB,IAAI,EAAE,EACvCJ,SAAS,CAACC,CAAC,IAAIA,CAAC,KAAKV,SAAS,CAAC;MACjC,IAAIY,cAAc,KAAK,CAAC,CAAC,EAAE;QACzBA,cAAc,GAAGD,QAAQ;MAC3B;MACA,OAAOT,IAAI,CAACC,GAAG,CAACI,iBAAiB,EAAEK,cAAc,CAAC;IACpD,CAAC,CAAC,CACH;IACD,IAAIX,mBAAmB,KAAKU,QAAQ,EAAE;MACpC;MACA,IAAIV,mBAAmB,KAAKL,WAAW,CAACE,OAAO,CAACgB,MAAM,EAAE;QACtD;QACA;QACAxD,KAAK,CAAC,6BAA6B,CAAC;QACpC,OAAO,KAAK;MACd;IACF;;IAEA;IACA,IAAIyD,MAAM,GAAG,IAAIC,GAAG,EAAE;IAEtB,IAAIC,iBAAiB,GAAGC,IAAI,IAAI;MAC9B,IAAIC,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAE;QACvB,OAAOA,IAAI,CAACG,KAAK,CAACJ,iBAAiB,CAAC;MACtC,CAAC,MAAM,IAAIC,IAAI,KAAK,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;QACpD,IAAIA,IAAI,CAACI,EAAE,KAAKtB,SAAS,EAAE;UACzB,IAAIe,MAAM,CAACQ,GAAG,CAACL,IAAI,CAACI,EAAE,CAAC,EAAE;YACvBhE,KAAK,CAAC,uBAAuB,EAAE4D,IAAI,CAACI,EAAE,CAAC;YACvC,OAAO,KAAK;UACd,CAAC,MAAM;YACLP,MAAM,CAACS,GAAG,CAACN,IAAI,CAACI,EAAE,CAAC;UACrB;QACF;QACA,OAAOG,MAAM,CAACC,MAAM,CAACR,IAAI,CAAC,CAACG,KAAK,CAACJ,iBAAiB,CAAC;MACrD,CAAC,MAAM;QACL,OAAO,IAAI;MACb;IACF,CAAC;;IAED;IACA;IACA;IACA3D,KAAK,CAAC,uCAAuC,CAAC;IAC9C,OAAOsC,WAAW,CAACE,OAAO,CAACuB,KAAK,CAC9BM,MAAM,IACJ,CAACA,MAAM,IACPA,MAAM,CAACC,QAAQ,KAAK,UAAU,IAC9BX,iBAAiB,CAACU,MAAM,CAACE,GAAG,CAAC,CAChC;EACH,CAAC;EAEDC,kBAAkB,EAAE,UAAUC,eAAe,EAAE;IAC7C,IAAIA,eAAe,EAAE;MACnB,OAAO,iEAAiE;IAC1E,CAAC,MAAM;MACL,OAAO,6CAA6C;IACtD;EACF,CAAC;EAEDC,6BAA6B,EAAE,YAAY;IACzC,OAAO,gDAAgD;EACzD,CAAC;EAEDC,wBAAwB,EAAE,UAAUC,SAAS,EAAE;IAC7C,OACEhE,aAAa,CAACC,IAAI,CAAE,IAAG+D,SAAU,GAAE,CAAC,GAAG,GAAG,GAAGlE,gBAAgB,CAACkE,SAAS,CAAC;EAE5E,CAAC;EAEDC,YAAY,EAAE,UAAUC,OAAO,EAAEC,MAAM,EAAE;IACvC,OAAOA,MAAM,KAAKrC,SAAS,GACtB,SAAQoC,OAAQ,IAAGC,MAAM,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAE,QAAO,GAClD,SAAQF,OAAQ,KAAI;EAC3B,CAAC;EAEDG,uBAAuB,EAAE,UAAUC,SAAS,EAAE;IAC5C,IAAIC,YAAY,GAAG,IAAI;IAEvB,IAAIC,KAAK,GAAGjB,MAAM,CAACkB,IAAI,CAACH,SAAS,CAAC,CAACnC,GAAG,CAAC,UAAUuC,OAAO,EAAE;MACxD,IAAIC,QAAQ,GAAGL,SAAS,CAACI,OAAO,CAAC;MAEjC,IAAIC,QAAQ,CAACC,YAAY,EAAE;QACzB,OAAO,GAAG,GAAGF,OAAO,GAAG,KAAK,GAAGC,QAAQ,CAACC,YAAY;MACtD;MAEA,IAAI,CAACD,QAAQ,CAAClB,MAAM,EAAE;QACpBc,YAAY,GAAG,KAAK;MACtB;MAEA,OAAO,GAAG,GAAGG,OAAO,GAAG,WAAW;IACpC,CAAC,CAAC;IAEF,IAAIF,KAAK,CAAC5B,MAAM,KAAK,CAAC,EAAE;MACtB4B,KAAK,CAACK,IAAI,CAAC,8BAA8B,CAAC;IAC5C;IAEA,IAAI,CAACN,YAAY,EAAE;MACjBC,KAAK,CAACK,IAAI,CAAC,EAAE,CAAC;MACdL,KAAK,CAACK,IAAI,CACP,GAAElF,KAAK,CAACmF,IAAI,CACX,UAAU,CACV,gEAA+D,CAClE;IACH;IAEA,OAAON,KAAK,CAACO,IAAI,CAAC7F,EAAE,CAAC8F,GAAG,CAAC;EAC3B,CAAC;EAEDC,UAAU,EAAE,YAA6B;IAAA,IAAnBC,WAAW,uEAAG,GAAG;IACrC,IAAIC,MAAM,GAAG,CACX,WAAW,EACXnF,aAAa,CAACC,IAAI,CAAC,SAAS,CAAC,GAC3B,yBAAyB,GACzBF,qBAAqB,CAACmF,WAAW,CAAC,GAClC,GAAG,CACN;IAED,IAAIE,eAAe,GAAG,CACpB,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,EACpB,CAAC,GAAG,EAAE,GAAG,CAAC,EACV,CAAC,GAAG,CAAC,EACL,CAAC,GAAG,CAAC,EACL,CAAC,GAAG,EAAE,GAAG,CAAC,EACV,CAAC,GAAG,CAAC,EACL,CAAC,GAAG,CAAC,EACL,CAAC,GAAG,EAAE,GAAG,CAAC,EACV,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,EACpB,CAAC,GAAG,CAAC,EACL,CAAC,GAAG,CAAC,EACL,CAAC,GAAG,EAAE,GAAG,CAAC,EACV,CAAC,GAAG,CAAC,EACL,CAAC,GAAG,CAAC,EACL,CAAC,GAAG,EAAE,GAAG,CAAC,CACX,CAACjD,GAAG,CAAC,UAAUkD,SAAS,EAAE;MACzB,OAAOA,SAAS,CAAClD,GAAG,CAACnB,UAAU,CAAC+C,wBAAwB,CAAC,CAACgB,IAAI,CAAC,IAAI,CAAC;IACtE,CAAC,CAAC;IAEF,IAAIO,MAAM,GAAG,CAAC,EAAE,CAAC;IAEjB,IAAId,KAAK,GAAGW,MAAM,CAACI,MAAM,CAACH,eAAe,CAAC,CAACG,MAAM,CAACD,MAAM,CAAC;IAEzD,OAAOd,KAAK,CAACO,IAAI,CAAC7F,EAAE,CAAC8F,GAAG,CAAC;EAC3B,CAAC;EAEDQ,YAAY,EAAE,UAAUC,SAAS,EAAiC;IAAA,IAA/BC,SAAS,uEAAG5E,iBAAiB;IAC9D;IACA;IACA;IACA,IAAI6E,IAAI,GAAG,EAAE;IACb,IAAIC,OAAO,GAAG,CAAC;IACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,SAAS,CAAC7C,MAAM,EAAEiD,CAAC,EAAE,EAAE;MACzC,IAAIJ,SAAS,CAACI,CAAC,CAAC,KAAK,IAAI,EAAE;QACzB,MAAMC,SAAS,GAAGJ,SAAS,GAAGE,OAAO;QACrCD,IAAI,IAAI,GAAG,CAACI,MAAM,CAACD,SAAS,CAAC;QAC7BF,OAAO,GAAG,CAAC;MACb,CAAC,MAAM,IAAIH,SAAS,CAACI,CAAC,CAAC,KAAK,IAAI,EAAE;QAChCF,IAAI,IAAI,IAAI;QACZC,OAAO,GAAG,CAAC;MACb,CAAC,MAAM,IAAIH,SAAS,CAACI,CAAC,CAAC,KAAK,IAAI,IAAIJ,SAAS,CAACI,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;QAC7DF,IAAI,IAAI,IAAI;QACZC,OAAO,GAAG,CAAC;QACXC,CAAC,EAAE;MACL,CAAC,MAAM;QACLF,IAAI,IAAIF,SAAS,CAACI,CAAC,CAAC;QACpBD,OAAO,EAAE;QACT,IAAIA,OAAO,KAAKF,SAAS,EAAE;UACzBE,OAAO,GAAG,CAAC;QACb;MACF;IACF;IACA,OAAOD,IAAI;EACb,CAAC;EAEDK,sBAAsB,EAAE,UAAUL,IAAI,EAAEM,MAAM,EAAEC,IAAI,EAAE;IACpD,MAAMf,MAAM,GAAGgB,MAAM,CAACF,MAAM,CAAC,CAACG,QAAQ,CAACF,IAAI,CAAC,GAAG,IAAI;IAEnD,OAAOf,MAAM,GAAGQ,IAAI;EACtB,CAAC;EAEDU,iBAAiB,EAAE,UACjBV,IAAI,EACJW,QAAQ,EACRC,MAAM,EACNC,OAAO,EAEP;IAAA,IADAd,SAAS,uEAAG5E,iBAAiB;IAE7B,MAAMqE,MAAM,GAAG,GAAG,CAACY,MAAM,CAACS,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;;IAExC,IAAIC,MAAM,GAAG,EAAE;IACf,IAAIb,OAAO,GAAG,CAAC;IACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,CAAC/C,MAAM,EAAEiD,CAAC,EAAE,EAAE;MACpC,IAAIa,SAAS,GAAGb,CAAC,IAAIS,QAAQ,IAAIT,CAAC,GAAGU,MAAM;MAE3C,IAAII,UAAU;MACd,IAAIhB,IAAI,CAACE,CAAC,CAAC,KAAK,IAAI,EAAE;QACpB,MAAMC,SAAS,GAAGJ,SAAS,GAAGE,OAAO;QACrCe,UAAU,GAAG,GAAG,CAACZ,MAAM,CAACD,SAAS,CAAC;QAClC1G,KAAK,CAAC,cAAc,EAAE0G,SAAS,CAAC;QAChCF,OAAO,GAAG,CAAC;MACb,CAAC,MAAM;QACLe,UAAU,GAAG,GAAG,CAAC,CAAC;QAClBf,OAAO,EAAE;QACT,IAAIA,OAAO,KAAKF,SAAS,EAAE;UACzBE,OAAO,GAAG,CAAC;QACb;MACF;MAEA,IAAIc,SAAS,EAAE;QACbC,UAAU,GAAGA,UAAU,CAACC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC;MAC5C;MAEAH,MAAM,IAAIE,UAAU;IACtB;IAEA,OAAO3G,aAAa,CAACK,MAAM,CAAC8E,MAAM,GAAGsB,MAAM,CAAC;EAC9C,CAAC;EAED;EACA;EACA;EACA;EACAI,gBAAgB,EAAE,UAChBpD,MAAM,EACNqD,KAAK,EACLC,iBAAiB,EAGjB;IAAA,IAFAC,aAAa,uEAAG,CAAC;IAAA,IACjBC,YAAY,uEAAG,CAAC;IAEhB;IACA;IACA;IACA;IACA;;IAEA,IAAIC,UAAU,GAAGlF,IAAI,CAACmF,GAAG,CAACL,KAAK,CAACM,KAAK,CAACzB,IAAI,GAAGqB,aAAa,EAAE,CAAC,CAAC;IAC9D,IAAIK,QAAQ,GAAGrF,IAAI,CAACC,GAAG,CAAC6E,KAAK,CAACM,KAAK,CAACzB,IAAI,GAAGsB,YAAY,EAAExD,MAAM,CAACb,MAAM,GAAG,CAAC,CAAC;IAE3E,IAAI0E,YAAY,GAAG,CAACD,QAAQ,GAAG,CAAC,GAAG,EAAE,EAAEzE,MAAM,CAAC,CAAC;;IAE/C;IACA,IAAI2E,WAAW,GAAG9D,MAAM,CACrB+D,KAAK,CAACN,UAAU,EAAEJ,KAAK,CAACM,KAAK,CAACzB,IAAI,GAAG,CAAC,CAAC,CACvCxD,GAAG,CAAC,CAACwD,IAAI,EAAE8B,KAAK,KAAK;MACpB,IAAIxB,MAAM,GAAGiB,UAAU,GAAGO,KAAK,GAAG,CAAC,CAAC,CAAC;MACrC,OAAOzG,UAAU,CAACgF,sBAAsB,CAACL,IAAI,EAAEM,MAAM,EAAEqB,YAAY,CAAC;IACtE,CAAC,CAAC;IACJ,IAAII,UAAU,GAAGjE,MAAM,CACpB+D,KAAK,CAACV,KAAK,CAACM,KAAK,CAACzB,IAAI,GAAG,CAAC,EAAE0B,QAAQ,GAAG,CAAC,CAAC,CACzClF,GAAG,CAAC,CAACwD,IAAI,EAAE8B,KAAK,KAAK;MACpB,IAAIxB,MAAM,GAAGa,KAAK,CAACM,KAAK,CAACzB,IAAI,GAAG,CAAC,GAAG8B,KAAK,GAAG,CAAC,CAAC,CAAC;MAC/C,OAAOzG,UAAU,CAACgF,sBAAsB,CAACL,IAAI,EAAEM,MAAM,EAAEqB,YAAY,CAAC;IACtE,CAAC,CAAC;IAEJ,IAAIK,YAAY,GAAGb,KAAK,CAACM,KAAK,CAACQ,MAAM;IACrC,IAAIC,UAAU;IAEd,IAAIC,eAAe,GAAGf,iBAAiB,CAACD,KAAK,CAACM,KAAK,CAACzB,IAAI,CAAC;;IAEzD;IACA;IACA,IAAImB,KAAK,CAACiB,GAAG,IAAIjB,KAAK,CAACM,KAAK,CAACzB,IAAI,KAAKmB,KAAK,CAACiB,GAAG,CAACpC,IAAI,EAAE;MACpD;MACAkC,UAAU,GAAGf,KAAK,CAACiB,GAAG,CAACH,MAAM;IAC/B,CAAC,MAAM;MACLC,UAAU,GAAGC,eAAe,CAAClF,MAAM;IACrC;IAEA,IAAIoF,QAAQ,GAAGT,WAAW,CAAChC,MAAM,CAC/B,CACEvE,UAAU,CAACqF,iBAAiB;IAC1B;IACA;IACAyB,eAAe,EACfH,YAAY,EACZE,UAAU,EACVP,YAAY,CACb,CACF,EACDI,UAAU,CACX;IAED,OAAOM,QAAQ,CAACjD,IAAI,CAAC7F,EAAE,CAAC8F,GAAG,CAAC;EAC9B,CAAC;EAEDiD,wBAAwB,EAAE,UACxBC,UAAU,EACVC,IAAI,EACJC,eAAe,EACfC,WAAW,EACX;IACA,IAAIC,WAAW;IACf,IAAIJ,UAAU,CAACd,KAAK,KAAKtF,SAAS,IAAIoG,UAAU,CAACtF,MAAM,KAAKd,SAAS,EAAE;MACrEwG,WAAW,GAAGH,IAAI,GACb,sBAAqBD,UAAU,CAACvC,IAAI,GAAG,CAAE,EAAC,GAC1C,mBAAkBuC,UAAU,CAACvC,IAAI,GAAG,CAAE,EAAC;MAC5C;IACF,CAAC,MAAM;MACL2C,WAAW,GAAI,QAAOJ,UAAU,CAACvC,IAAI,GAAG,CAAE,EAAC;IAC7C;IACA,IAAIuC,UAAU,CAACK,QAAQ,KAAKH,eAAe,EAAE;MAC3C,MAAMI,UAAU,GAAGH,WAAW,CAACH,UAAU,CAACK,QAAQ,CAAC;MACnD,OAAOD,WAAW,GAAI,OAAME,UAAW,EAAC;IAC1C,CAAC,MAAM;MACL,OAAOF,WAAW;IACpB;EACF,CAAC;EAEDG,wBAAwB,EAAE,UAAUC,WAAW,EAAE;IAC/C,MAAMC,EAAE,GAAG,IAAI,CAACC,QAAQ,CAACF,WAAW,CAACC,EAAE,CAAC;IACxC,MAAME,oBAAoB,GAAG,IAAI,CAACC,iBAAiB,CAACJ,WAAW,CAAC;IAChE,OAAO,KAAK,GAAG1I,aAAa,CAACC,IAAI,CAAC4I,oBAAoB,CAAC,GAAGF,EAAE;EAC9D,CAAC;EAEDG,iBAAiB,EAAE,UAAUJ,WAAW,EAAE;IACxC,OAAO1I,aAAa,CAACC,IAAI,CACvByI,WAAW,CAACK,IAAI,GAAG,GAAG,IAAIL,WAAW,CAACM,QAAQ,IAAI,EAAE,CAAC,CACtD;EACH,CAAC;EAEDJ,QAAQ,EAAE,UAAUD,EAAE,EAAE;IACtB,IAAIzI,GAAG,GAAGyI,EAAE,CAACM,QAAQ,CAAC,EAAE,CAAC;IACzB,IAAI/I,GAAG,CAAC0C,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;MACxB1C,GAAG,GAAG,GAAG,GAAGA,GAAG,CAAC,CAAC;IACnB;;IACA,OAAO,OAAO,GAAGyI,EAAE,CAACM,QAAQ,EAAE,GAAG,MAAM,GAAG/I,GAAG,GAAG,GAAG;EACrD,CAAC;EAEDgJ,WAAW,EAAE,UAAUC,KAAK,EAAE;IAC5B;IACA,IAAIC,SAAS,GAAGD,KAAK,CAAChH,GAAG,CAAC,CAACkH,IAAI,EAAE5B,KAAK,KAAK;MACzC4B,IAAI,GAAGrJ,aAAa,CAACG,MAAM,CAACkJ,IAAI,CAAC;MACjCA,IAAI,GAAG,IAAI,GAAGA,IAAI;MAClB,IAAI5B,KAAK,KAAK0B,KAAK,CAACvG,MAAM,GAAG,CAAC,EAAE;QAC9ByG,IAAI,IAAI,QAAQ;MAClB,CAAC,MAAM;QACLA,IAAI,IAAK,KAAIF,KAAK,CAACvG,MAAM,GAAG6E,KAAK,GAAG,CAAE,YAAW;MACnD;MAEA,OAAO4B,IAAI;IACb,CAAC,CAAC;IAEF,IAAIF,KAAK,CAACvG,MAAM,KAAK,CAAC,EAAE;MACtBwG,SAAS,CAACE,OAAO,CAAC,qBAAqB,CAAC;IAC1C,CAAC,MAAM;MACLF,SAAS,CAACE,OAAO,CAAC,QAAQ,CAAC;IAC7B;IAEA,OAAOF,SAAS,CAACrE,IAAI,CAAC7F,EAAE,CAAC8F,GAAG,CAAC;EAC/B,CAAC;EAEDuE,YAAY,EAAE,UAAUC,MAAM,EAAE;IAC9B;IACA;;IAEA;IACA;IACA,IAAIC,eAAe,GAAGzH,IAAI,CAACmF,GAAG,CAC5B,CAAC,EACD,CAAC,CAACqC,MAAM,CAAC5G,MAAM,GAAG,CAAC,IAAItD,KAAK,CAACoK,GAAG,CAACC,KAAK,CAACC,SAAS,EAAEX,QAAQ,CAAC,EAAE,CAAC,CAACrG,MAAM,CACtE;IACD,IAAI6G,eAAe,GAAG,CAAC,KAAK,CAAC,EAAE;MAC7BA,eAAe,EAAE,CAAC,CAAC;IACrB;;IAEA,IAAIL,SAAS,GAAGI,MAAM,CAACrH,GAAG,CAAC,CAAC0H,IAAI,EAAEpC,KAAK,KAAK;MAC1C,IAAI/C,OAAO,GAAG,CAAC+C,KAAK,GAAGnI,KAAK,CAACoK,GAAG,CAACC,KAAK,CAACC,SAAS,EAC7CX,QAAQ,CAAC,EAAE,CAAC,CACZ7C,QAAQ,CAACqD,eAAe,EAAE,GAAG,CAAC;MACjC,OAAQ,OAAM/E,OAAQ,MAAK1E,aAAa,CAACI,IAAI,CAACyJ,IAAI,CAAE,EAAC;IACvD,CAAC,CAAC;IAEF,IAAIL,MAAM,CAAC5G,MAAM,KAAK,CAAC,EAAE;MACvBwG,SAAS,CAACE,OAAO,CAAC,sBAAsB,CAAC;IAC3C,CAAC,MAAM;MACLF,SAAS,CAACE,OAAO,CAAC,SAAS,CAAC;IAC9B;IAEA,OAAOF,SAAS,CAACrE,IAAI,CAAC7F,EAAE,CAAC8F,GAAG,CAAC;EAC/B,CAAC;EAED8E,aAAa,EAAE,UAAUC,OAAO,EAAE;IAChC;;IAEA;IACA;IACA,IAAIC,KAAK,GAAGzG,MAAM,CAACkB,IAAI,CAACsF,OAAO,CAAC,CAACvC,KAAK,EAAE,CAACyC,IAAI,EAAE;IAE/C,IAAIb,SAAS,GAAGY,KAAK,CAAC7H,GAAG,CAAC,CAAC+H,IAAI,EAAEzC,KAAK,KAAK;MACzC,IACEA,KAAK,KAAK,CAAC,IACX,CAACnI,KAAK,CAAC6K,UAAU,CAACC,IAAI,CAACF,IAAI,CAAC,CAACG,EAAE,CAC7B/K,KAAK,CAAC6K,UAAU,CAACC,IAAI,CAACJ,KAAK,CAACvC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC6C,IAAI,CAAC,CAAC,CAAC,CAChD,EACD;QACA,OAAQ,KAAIJ,IAAK,KAAI,GAAI,KAAIlK,aAAa,CAACS,IAAI,CAACsJ,OAAO,CAACG,IAAI,CAAC,CAAE,EAAC;MAClE,CAAC,MAAM;QACL,OAAQ,KAAIlK,aAAa,CAACS,IAAI,CAACsJ,OAAO,CAACG,IAAI,CAAC,CAAE,EAAC;MACjD;IACF,CAAC,CAAC;IAEF,IAAIF,KAAK,CAACpH,MAAM,KAAK,CAAC,EAAE;MACtBwG,SAAS,CAACE,OAAO,CAAC,4CAA4C,CAAC;IACjE,CAAC,MAAM;MACLF,SAAS,CAACE,OAAO,CAAC,yBAAyB,CAAC;IAC9C;IAEA,OAAOF,SAAS,CAACrE,IAAI,CAAC7F,EAAE,CAAC8F,GAAG,CAAC;EAC/B,CAAC;EAEDuF,cAAc,EAAE,UAAUC,QAAQ,EAAE;IAClC;IACA,IAAIC,QAAQ,GAAGD,QAAQ,CAAChD,KAAK,CAAC,CAAC,EAAElI,KAAK,CAACoK,GAAG,CAACC,KAAK,CAACe,aAAa,CAAC;IAC/D,IAAIC,KAAK,GAAG,EAAE;IACd,KACE,IAAIC,SAAS,GAAGtL,KAAK,CAACoK,GAAG,CAACC,KAAK,CAACe,aAAa,EAC7CE,SAAS,GAAGJ,QAAQ,CAAC5H,MAAM,EAC3BgI,SAAS,IAAItL,KAAK,CAACoK,GAAG,CAACC,KAAK,CAACC,SAAS,EACtC;MACAe,KAAK,CAAC9F,IAAI,CACR2F,QAAQ,CAAChD,KAAK,CAACoD,SAAS,EAAEA,SAAS,GAAGtL,KAAK,CAACoK,GAAG,CAACC,KAAK,CAACC,SAAS,CAAC,CACjE;IACH;IACA,IAAIiB,YAAY,GACd,CAACF,KAAK,CAAC/H,MAAM,GAAG,CAAC,IAAItD,KAAK,CAACoK,GAAG,CAACC,KAAK,CAACC,SAAS,GAC9CtK,KAAK,CAACoK,GAAG,CAACC,KAAK,CAACe,aAAa;IAC/B,IAAIjB,eAAe,GAAGzH,IAAI,CAACmF,GAAG,CAAC,CAAC,EAAE0D,YAAY,CAAC5B,QAAQ,CAAC,EAAE,CAAC,CAACrG,MAAM,CAAC;IACnE,IAAI6G,eAAe,GAAG,CAAC,KAAK,CAAC,EAAE;MAC7BA,eAAe,EAAE;IACnB;IACA,IAAIqB,iBAAiB;IACrB,IAAIL,QAAQ,CAAC7H,MAAM,GAAG,CAAC,EAAE;MACvBkI,iBAAiB,GACf,aAAa,GACZ,OAAM,IAAI,CAAC1E,QAAQ,CAACqD,eAAe,EAAE,GAAG,CAAE,KAAI,GAC/CzJ,aAAa,CAACI,IAAI,CAChBd,KAAK,CAAC6K,UAAU,CAACY,WAAW,CAACN,QAAQ,CAAC,CACnCjD,KAAK,CAAC,CAAC,CAAC,CACRpB,QAAQ,CAAC,CAAC,GAAG9G,KAAK,CAACoK,GAAG,CAACC,KAAK,CAACC,SAAS,EAAE,IAAI,CAAC,CACjD;IACL,CAAC,MAAM;MACLkB,iBAAiB,GAAG,wBAAwB;IAC9C;IAEA,IAAI1B,SAAS,GAAGuB,KAAK,CAACxI,GAAG,CAAC,CAAC0H,IAAI,EAAEpC,KAAK,KAAK;MACzC,IAAI/C,OAAO,GAAG,CACZ+C,KAAK,GAAGnI,KAAK,CAACoK,GAAG,CAACC,KAAK,CAACC,SAAS,GACjCtK,KAAK,CAACoK,GAAG,CAACC,KAAK,CAACe,aAAa,EAE5BzB,QAAQ,CAAC,EAAE,CAAC,CACZ7C,QAAQ,CAACqD,eAAe,EAAE,GAAG,CAAC;MACjC,IAAIuB,IAAI,GAAG1L,KAAK,CAAC6K,UAAU,CAACY,WAAW,CAAClB,IAAI,CAAC,CAC1CrC,KAAK,CAAC,CAAC,CAAC,CACRyD,MAAM,CAAC,CAAC,GAAG3L,KAAK,CAACoK,GAAG,CAACC,KAAK,CAACC,SAAS,CAAC;MACxC,OAAQ,OAAMlF,OAAQ,MAAK1E,aAAa,CAACI,IAAI,CAAC4K,IAAI,CAAE,EAAC;IACvD,CAAC,CAAC;IAEF5B,SAAS,CAACE,OAAO,CAACwB,iBAAiB,CAAC;IAEpC,OAAO1B,SAAS,CAACrE,IAAI,CAAC7F,EAAE,CAAC8F,GAAG,CAAC;EAC/B,CAAC;EAEDkG,WAAW,EAAE,UAAUC,KAAK,EAAiC;IAAA,IAA/BC,MAAM,uEAAG,CAAC;IAAA,IAAEC,SAAS,uEAAG,KAAK;IACzD,IAAIC,cAAc,GAAG;MACnBC,MAAM,EAAE,IAAI;MACZC,KAAK,EAAE,IAAI;MACXC,cAAc,EAAE,IAAI;MACpBC,WAAW,EAAE;IACf,CAAC;IACD,IAAIC,cAAc,GAAGN,SAAS,GAC1BF,KAAK,GACL,IAAI7L,KAAK,CAACsM,MAAM,CAACC,eAAe,CAACV,KAAK,CAAC;IAC3C,OAAO9L,IAAI,CACRyM,OAAO,CAACH,cAAc,EAAEL,cAAc,CAAC,CACvCS,KAAK,CAAC,QAAQ,CAAC,CACf5J,GAAG,CAAC,CAACwD,IAAI,EAAEE,CAAC,KAAK;MAChB;MACA,MAAMW,OAAO,GAAGX,CAAC,GAAG,CAAC,GAAG5C,KAAK,CAACmI,MAAM,CAAC,CAACrG,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE;MACpD,OAAOyB,OAAO,GAAGb,IAAI;IACvB,CAAC,CAAC,CACDZ,IAAI,CAAC7F,EAAE,CAAC8F,GAAG,CAAC;EACjB,CAAC;EAED;EACAgH,iBAAiB,EAAE,UAAUC,QAAQ,EAAc;IAAA,IAAZb,MAAM,uEAAG,CAAC;IAC/C,MAAME,cAAc,GAAG;MACrBC,MAAM,EAAE,IAAI;MACZC,KAAK,EAAE,IAAI;MACXC,cAAc,EAAE,IAAI;MACpBC,WAAW,EAAE;IACf,CAAC;IACD,MAAM3C,IAAI,GAAGkD,QAAQ,CAACC,SAAS,GAC1B,GAAED,QAAQ,CAACC,SAAS,CAACC,QAAS,IAAGF,QAAQ,CAACG,GAAG,CAACrD,IAAK,EAAC,GACrDkD,QAAQ,CAACG,GAAG,CAACrD,IAAI;IACrB,OAAOzJ,KAAK,CAACsM,MAAM,CAACS,kBAAkB,CACpCtD,IAAI,EACJkD,QAAQ,CAACK,SAAS,EAClBhB,cAAc,EACd,KAAK,EACLF,MAAM,CACP;EACH,CAAC;EAEDmB,gBAAgB,EAAE,UAAUC,UAAU,EAAc;IAAA,IAAZpB,MAAM,uEAAG,CAAC;IAChD;IACA,MAAM;MAAEqB,OAAO;MAAEC,KAAK;MAAEC;IAAO,CAAC,GAAGH,UAAU,CAAC,CAAC,CAAC;IAChD;IACA;IACAA,UAAU,GAAGA,UAAU,CAAChF,KAAK,EAAE,CAACoF,OAAO,EAAE,CAAC,CAAC;IAC3C,IAAIpI,KAAK,GAAGgI,UAAU,CAACrK,GAAG,CACxB,QAOM;MAAA,IAPL;QACC0K,YAAY;QACZjI,YAAY;QACZF,OAAO;QACPoI,QAAQ;QACRC,aAAa;QACbC;MACF,CAAC;MACC,IAAIjE,IAAI;MACR,IAAInE,YAAY,IAAIiI,YAAY,EAAE;QAChC9D,IAAI,GAAI,GAAEnE,YAAa,IAAGiI,YAAa,EAAC;MAC1C,CAAC,MAAM,IAAIjI,YAAY,EAAE;QACvBmE,IAAI,GACFiE,IAAI,KAAK,UAAU,IAAID,aAAa,GAC/B,OAAMnI,YAAa,EAAC,GACrBA,YAAY;QAClB;QACA;MACF,CAAC,MAAM,IAAIiI,YAAY,EAAE;QACvB9D,IAAI,GAAG8D,YAAY;MACrB,CAAC,MAAM;QACL9D,IAAI,GAAG,kBAAkB;MAC3B;MACA,IAAIkE,cAAc;MAClB,IAAIH,QAAQ,EAAE;QACZ,IAAI;UACFrJ,MAAM,EAAE;YAAEyJ;UAAW,CAAC;UACtBC,WAAW,EAAE;YACX3I,KAAK,EAAE;cACL4C,KAAK,EAAE;gBAAEzB,IAAI;gBAAEiC;cAAO;YACxB;UACF;QACF,CAAC,GAAGkF,QAAQ;QACZG,cAAc,GAAGC,UAAU,GACtB,GAAEA,UAAW,IAAGvH,IAAI,GAAG,CAAE,IAAGiC,MAAM,GAAG,CAAE,EAAC,CAAC;QAAA,EAC1C,kBAAkB;MACxB,CAAC,MAAM;QACLqF,cAAc,GAAG,kBAAkB;MACrC;MACA,IAAIG,aAAa,GACfJ,IAAI,KAAK,UAAU,GACftI,OAAO,KAAK5C,SAAS,GAClB,aAAY4C,OAAQ,GAAE,GACvB,oBAAoB,GACtB,EAAE;MACR,OAAQ,MAAKqE,IAAK,GAAEqE,aAAc,KAAIH,cAAe,GAAE;IACzD,CAAC,CACF;IACD,IAAII,MAAM,GAAGb,UAAU,CAAC,CAAC,CAAC,CAACa,MAAM;IACjC,IAAIA,MAAM,IAAIvL,SAAS,EAAE;MACvB,IAAIwL,UAAU;MACd,IAAIb,OAAO,KAAK3K,SAAS,EAAE;QACzBwL,UAAU,GAAGD,MAAM,GACd,2CAA0CZ,OAAQ,GAAE,GACpD,2BAA0BA,OAAQ,GAAE;MAC3C,CAAC,MAAM,IAAIC,KAAK,KAAK5K,SAAS,EAAE;QAC9BwL,UAAU,GAAGD,MAAM,GACd,kCAAiCrM,UAAU,CAACC,WAAW,CACtDyL,KAAK,CACN,CAACa,WAAW,EAAG,YAAWb,KAAK,CAACzD,QAAQ,CAAC,EAAE,CAAE,IAAG,GAChD,UAASjI,UAAU,CAACC,WAAW,CAACyL,KAAK,CAAE,YAAWA,KAAK,CAACzD,QAAQ,CAC/D,EAAE,CACF,GAAE;MACV,CAAC,MAAM,IAAI0D,MAAM,KAAK7K,SAAS,EAAE;QAC/BwL,UAAU,GAAGD,MAAM,GACd,8CAA6C,GAC7C,8BAA6B;MACpC,CAAC,MAAM;QACLC,UAAU,GAAGD,MAAM,GACf,6DAA6D,GAC7D,mCAAmC;MACzC;MACA7I,KAAK,CAAC8E,OAAO,CAACgE,UAAU,CAAC;IAC3B;IACA,IAAIE,QAAQ,GAAGhJ,KAAK,CAACrC,GAAG,CAAC,CAACwD,IAAI,EAAE8B,KAAK,KACnCA,KAAK,KAAK,CAAC,GAAG9B,IAAI,GAAG,GAAG,CAACI,MAAM,CAACqF,MAAM,CAAC,GAAGzF,IAAI,CAC/C;IACD,OAAO6H,QAAQ,CAACzI,IAAI,CAAC7F,EAAE,CAAC8F,GAAG,CAAC;EAC9B,CAAC;EAEDyI,QAAQ,EAAE,UAAUC,IAAI,EAAyB;IAAA,IAAvBhK,QAAQ,uEAAG,UAAU;IAC7C,MAAMiK,OAAO,GAAG;MACdC,IAAI,EAAE,UAAU;MAChBrC,MAAM,EAAExK,cAAc;MACtB;MACA;MACA8M,WAAW,EAAE,KAAK;MAClBC,WAAW,EAAE,KAAK;MAClBC,OAAO,EAAE,CAAC;MACVvI,YAAY,EAAE,KAAK;MAAE;MACrB;MACAwI,UAAU,EAAE;IACd,CAAC;IACD,QAAQtK,QAAQ;MACd,KAAK,UAAU;QACb,OAAOlE,QAAQ,CAACkO,IAAI,EAAEC,OAAO,CAAC;MAChC,KAAK,KAAK;QACRA,OAAO,CAACC,IAAI,GAAG,KAAK,CAAC,CAAC;QACtB,OAAOpO,QAAQ,CAACkO,IAAI,EAAEC,OAAO,CAAC;MAChC,KAAK,OAAO;QACVA,OAAO,CAACC,IAAI,GAAG,QAAQ,CAAC,CAAC;QACzB,OAAOpO,QAAQ,CAACkO,IAAI,EAAEC,OAAO,CAAC;MAChC;QACE;QACA,OAAOD,IAAI;IAAC;EAElB,CAAC;EAED;EACAO,SAAS,EAAE,UAAUC,SAAS,EAAEC,WAAW,EAAE;IAC3C,OAAO5K,MAAM,CAAC6K,MAAM,CAClB,CAAC,CAAC,EACF,GAAG7K,MAAM,CAAC8K,OAAO,CAACH,SAAS,CAAC,CAAC/L,GAAG,CAAC;MAAA,IAAC,CAACmM,QAAQ,EAAEnD,KAAK,CAAC;MAAA,OACjDmD,QAAQ,KAAK,MAAM,GAAG;QAAE,CAACH,WAAW,GAAGhD;MAAM,CAAC,GAAG;QAAE,CAACmD,QAAQ,GAAGnD;MAAM,CAAC;IAAA,EACvE,CACF;EACH,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEoD,mCAAmC,EAAE,gBAAgBC,MAAM,EAAE;IAC3D,MAAMA,MAAM,CAACC,KAAK,EAAE;IACpB,IAAI7M,OAAO,GAAG,CAAC,CAAC;IAChB,MAAM;MAAE8M;IAAW,CAAC,GAAGF,MAAM,CAACG,SAAS;IACvC,OAAO,CAACH,MAAM,CAACI,IAAI,CAACF,UAAU,CAACG,OAAO,CAACC,KAAK,CAACC,QAAQ,CAAC,EAAE;MACtD,MAAMtL,MAAM,GAAG+K,MAAM,CAACI,IAAI,CAACF,UAAU,CAACG,OAAO,CAAC/B,QAAQ,CAACrJ,MAAM,CAAC;MAC9D,MAAM;QAAEuL,aAAa;QAAE5L,EAAE;QAAE6L;MAAS,CAAC,GAAGxL,MAAM;MAC9C;MACA;MACA,IAAI,CAACwL,QAAQ,IAAID,aAAa,KAAKlN,SAAS,IAAIsB,EAAE,KAAKtB,SAAS,EAAE;QAChEF,OAAO,CAACoN,aAAa,CAAC,GAAG;UACvB,GAAGpN,OAAO,CAACoN,aAAa,CAAC;UACzB,CAAC5L,EAAE,GAAGK;QACR,CAAC;MACH;MACA,MAAM+K,MAAM,CAACU,QAAQ,EAAE;IACzB;IACA,MAAMV,MAAM,CAACC,KAAK,EAAE;IACpB;IACA,OAAO,EAAE,CAAClJ,MAAM,CAAC,GAAGhC,MAAM,CAACC,MAAM,CAAC5B,OAAO,CAAC,CAACO,GAAG,CAACoB,MAAM,CAACC,MAAM,CAAC,CAAC;EAChE;AACF,CAAC;AAED2L,MAAM,CAACC,OAAO,GAAGpO,UAAU"},"metadata":{},"sourceType":"script"}