{"ast":null,"code":"\"use strict\";\n\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readStorage = exports.readSlot = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:storage:read\");\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nfunction* readSlot(storage, slot) {\n  const address = Utils.slotAddress(slot);\n  // debug(\"reading slot: %o\", Conversion.toHexString(address));\n  const hexAddress = Conversion.toHexString(address, Evm.Utils.WORD_SIZE);\n  let word = storage[hexAddress];\n  //if we can't find the word in the map, we place a request to the invoker to supply it\n  //(contract-decoder will look it up from the blockchain, while the debugger will just\n  //say 0)\n  if (word === undefined) {\n    word = yield {\n      type: \"storage\",\n      slot: address\n    };\n    if (word === null) {\n      //check for null as a way to deliberately indicate an error\n      throw new errors_1.DecodingError({\n        kind: \"StorageNotSuppliedError\",\n        slot: address\n      });\n    }\n  }\n  return word;\n}\nexports.readSlot = readSlot;\nfunction* readStorage(pointer, state) {\n  const {\n    storage\n  } = state;\n  const {\n    range\n  } = pointer;\n  debug(\"readRange %o\", range);\n  let {\n    from,\n    to,\n    length\n  } = range;\n  from = {\n    slot: from.slot,\n    index: from.index || 0\n  };\n  if (length !== undefined) {\n    to = {\n      slot: {\n        path: from.slot.path || undefined,\n        offset: from.slot.offset.addn(Math.floor((from.index + length - 1) / Evm.Utils.WORD_SIZE))\n      },\n      index: (from.index + length - 1) % Evm.Utils.WORD_SIZE\n    };\n  }\n  debug(\"normalized readRange %o\", {\n    from,\n    to\n  });\n  let totalWordsAsBN = to.slot.offset.sub(from.slot.offset).addn(1);\n  let totalWords;\n  try {\n    totalWords = totalWordsAsBN.toNumber();\n  } catch (_) {\n    throw new errors_1.DecodingError({\n      kind: \"ReadErrorStorage\",\n      range\n    });\n  }\n  let data = new Uint8Array(totalWords * Evm.Utils.WORD_SIZE);\n  for (let i = 0; i < totalWords; i++) {\n    let offset = from.slot.offset.addn(i);\n    const word = yield* readSlot(storage, Object.assign(Object.assign({}, from.slot), {\n      offset\n    }));\n    data.set(word, i * Evm.Utils.WORD_SIZE);\n  }\n  debug(\"words %o\", data);\n  data = data.slice(from.index, (totalWords - 1) * Evm.Utils.WORD_SIZE + to.index + 1);\n  debug(\"data: %o\", data);\n  return data;\n}\nexports.readStorage = readStorage;","map":{"version":3,"mappings":"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","names":["debug","readSlot","storage","slot","address","Utils","slotAddress","hexAddress","Conversion","toHexString","Evm","WORD_SIZE","word","undefined","type","errors_1","kind","exports","readStorage","pointer","state","range","from","to","length","index","path","offset","addn","Math","floor","totalWordsAsBN","sub","totalWords","toNumber","_","data","Uint8Array","i","set","slice"],"sourceRoot":"","sources":["../../../../lib/storage/read/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}