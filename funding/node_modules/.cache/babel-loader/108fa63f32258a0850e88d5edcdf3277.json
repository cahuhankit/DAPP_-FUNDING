{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findRepeatCompilationIds = exports.infoToCompilations = exports.findCompilationAndContract = exports.collectUserDefinedTypesAndTaggedOutputs = exports.simpleShimSourceMap = exports.getContractNode = exports.shimContracts = exports.shimArtifacts = exports.shimCompilation = exports.shimCompilations = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:compilations:utils\");\nconst Ast = __importStar(require(\"../ast\"));\nconst compile_common_1 = require(\"@truffle/compile-common\");\nconst Format = __importStar(require(\"../format\"));\nconst errors_1 = require(\"../errors\");\nfunction shimCompilations(inputCompilations) {\n  let shimmedCompilationIdPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"shimmedcompilation\";\n  return inputCompilations.map((compilation, compilationIndex) => shimCompilation(compilation, `${shimmedCompilationIdPrefix}Number(${compilationIndex})`));\n}\nexports.shimCompilations = shimCompilations;\nfunction shimCompilation(inputCompilation) {\n  let shimmedCompilationId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"shimmedcompilation\";\n  return Object.assign(Object.assign({}, shimContracts(inputCompilation.contracts, {\n    files: inputCompilation.sourceIndexes,\n    sources: inputCompilation.sources,\n    shimmedCompilationId,\n    compiler: inputCompilation.compiler\n  })), {\n    compiler: inputCompilation.compiler\n  });\n}\nexports.shimCompilation = shimCompilation;\n/**\n * wrapper around shimContracts that just returns\n * the result in a one-element array (keeping the old name\n * shimArtifacts for compatibility)\n */\nfunction shimArtifacts(artifacts, files) {\n  let shimmedCompilationId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"shimmedcompilation\";\n  return [shimContracts(artifacts, {\n    files,\n    shimmedCompilationId\n  })];\n}\nexports.shimArtifacts = shimArtifacts;\n/**\n * shims a bunch of contracts (\"artifacts\", though not necessarily)\n * to a compilation.  usually used via one of the above functions.\n * Note: if you pass in options.sources, options.files will be ignored.\n * Note: if you pass in options.sources, sources will not have\n * compiler set unless you also pass in options.compiler; in this case\n * you should set that up separately, as in shimCompilation().\n */\nfunction shimContracts(artifacts) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    files,\n    sources: inputSources\n  } = options;\n  const shimmedCompilationId = options.shimmedCompilationId || \"shimmedcompilation\";\n  let contracts = [];\n  let sources = [];\n  let unreliableSourceOrder = false;\n  for (let artifact of artifacts) {\n    let {\n      contractName,\n      bytecode,\n      sourceMap,\n      deployedBytecode,\n      deployedSourceMap,\n      immutableReferences,\n      sourcePath,\n      source,\n      ast,\n      abi,\n      compiler,\n      generatedSources,\n      deployedGeneratedSources,\n      metadata\n    } = artifact;\n    if (artifact.contract_name) {\n      //just in case\n      contractName = artifact.contract_name;\n      //dunno what's up w/ the type of contract_name, but it needs coercing\n    }\n\n    debug(\"contractName: %s\", contractName);\n    let contractObject = {\n      contractName,\n      bytecode,\n      sourceMap,\n      deployedBytecode,\n      deployedSourceMap,\n      immutableReferences,\n      abi,\n      generatedSources: normalizeGeneratedSources(generatedSources, compiler),\n      deployedGeneratedSources: normalizeGeneratedSources(deployedGeneratedSources, compiler),\n      compiler\n    };\n    let sourceObject = {\n      sourcePath,\n      source,\n      ast: ast,\n      compiler,\n      language: inferLanguage(ast, compiler, sourcePath)\n    };\n    //ast needs to be coerced because schema doesn't quite match our types here...\n    if (metadata) {\n      try {\n        const parsedMetadata = JSON.parse(metadata); //sorry\n        const settings = parsedMetadata.settings;\n        const viaIR = settings.viaIR;\n        contractObject.settings = {\n          viaIR\n        };\n        sourceObject.settings = {\n          viaIR\n        };\n      } catch (_a) {\n        //if metadata doesn't parse, or we hit undefineds, ignore it\n      }\n    }\n    //if files or sources was passed, trust that to determine the source index\n    //(assuming we have a sourcePath! currently it will be absent when dealing with\n    //Solidity versions <0.4.9; presumably we will fix this if we ever properly\n    //support versions that old, but for now this is necessary to get debug -x to work)\n    if ((files || inputSources) && sourcePath) {\n      //note: we never set the unreliableSourceOrder flag in this branch;\n      //we just trust files/sources.  If this info is bad, then, uh, too bad.\n      debug(\"inputSources: %O\", inputSources);\n      debug(\"files: %O\", files);\n      debug(\"sourcePath: %O\", sourcePath);\n      const index = inputSources ? inputSources.findIndex(source => source.sourcePath === sourcePath) : files.indexOf(sourcePath);\n      if (!inputSources) {\n        //if inputSources was passed, we'll handle this separately below\n        sourceObject.id = index.toString(); //HACK\n        sources[index] = sourceObject;\n      }\n      debug(\"files || inputSources; index: %d\", index);\n      contractObject.primarySourceId = index.toString(); //HACK\n    } else {\n      //if neither was passed, attempt to determine it from the ast\n      let index;\n      let needsAdding;\n      if (sourceObject.ast) {\n        //note: this works for both Solidity and Vyper\n        index = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons\n      } else if (compiler && compiler.name === \"vyper\") {\n        index = 0; //if it's Vyper but there's no AST, we can\n        //assume that it was compiled alone and therefore has index 0\n      }\n      //if that didn't work, try the source map\n      if (index === undefined && (sourceMap || deployedSourceMap)) {\n        const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n        index = extractPrimarySource(sourceMapString);\n      }\n      //else leave undefined for now\n      ({\n        index,\n        needsAdding,\n        unreliableSourceOrder\n      } = getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder));\n      if (needsAdding) {\n        //if we're in this case, inputSources was not passed\n        sourceObject.id = index.toString(); //HACK\n        sources[index] = sourceObject;\n        debug(\"else; index: %d\", index);\n      }\n      //whether needed adding or not, set the source ID on the contract object\n      contractObject.primarySourceId = index.toString(); //HACK\n      debug(\"(no index unless mentioned)\");\n    }\n    contracts.push(contractObject);\n  }\n  //now: check for id overlap with internal sources\n  //(don't bother if inputSources or files was passed)\n  if (!inputSources && !files) {\n    for (let contract of contracts) {\n      const {\n        generatedSources,\n        deployedGeneratedSources\n      } = contract;\n      for (let index in generatedSources) {\n        if (index in sources) {\n          unreliableSourceOrder = true;\n        }\n      }\n      for (let index in deployedGeneratedSources) {\n        if (index in sources) {\n          unreliableSourceOrder = true;\n        }\n      }\n    }\n  }\n  let compiler;\n  if (options.compiler) {\n    compiler = options.compiler;\n  } else if (!unreliableSourceOrder && contracts.length > 0) {\n    //if things were actually compiled together, we should just be able\n    //to pick an arbitrary one\n    compiler = contracts[0].compiler;\n  }\n  let settings; //we'll do the same thing with settings\n  if (options.settings) {\n    settings = options.settings;\n  } else if (!unreliableSourceOrder && contracts.length > 0) {\n    //if things were actually compiled together, we should just be able\n    //to pick an arbitrary one\n    settings = contracts[0].settings;\n  }\n  //if input sources was passed, set up the sources object directly :)\n  if (inputSources) {\n    sources = inputSources.map((_ref, index) => {\n      let {\n        sourcePath,\n        contents: source,\n        ast,\n        language\n      } = _ref;\n      return {\n        sourcePath,\n        source,\n        ast: ast,\n        language,\n        id: index.toString(),\n        compiler //redundant but let's include it\n      };\n    });\n  }\n\n  return {\n    id: shimmedCompilationId,\n    unreliableSourceOrder,\n    sources,\n    contracts,\n    compiler,\n    settings\n  };\n}\nexports.shimContracts = shimContracts;\n//note: this works for Vyper too!\nfunction sourceIndexForAst(ast) {\n  if (Array.isArray(ast)) {\n    //special handling for old Vyper versions\n    ast = ast[0];\n  }\n  if (!ast) {\n    return undefined;\n  }\n  return parseInt(ast.src.split(\":\")[2]);\n  //src is given as start:length:file.\n  //we want just the file.\n}\n\nfunction getContractNode(contract, compilation) {\n  const {\n    contractName,\n    sourceMap,\n    deployedSourceMap,\n    primarySourceId\n  } = contract;\n  const {\n    unreliableSourceOrder,\n    sources\n  } = compilation;\n  let sourcesToCheck;\n  //we will attempt to locate the primary source;\n  //if we can't find it, we'll just check every source in this\n  //compilation.\n  if (primarySourceId !== undefined) {\n    sourcesToCheck = [sources.find(source => source && source.id === primarySourceId)];\n  } else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {\n    const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n    let sourceId = extractPrimarySource(sourceMapString);\n    sourcesToCheck = [sources[sourceId]];\n  } else {\n    //WARNING: if we end up in this case, we could get the wrong contract!\n    //(but we shouldn't end up here)\n    sourcesToCheck = sources;\n  }\n  return sourcesToCheck.reduce((foundNode, source) => {\n    if (foundNode || !source) {\n      return foundNode;\n    }\n    if (!source.ast || source.language !== \"Solidity\") {\n      //ignore non-Solidity ASTs for now, we don't support them yet\n      return undefined;\n    }\n    return source.ast.nodes.find(node => node.nodeType === \"ContractDefinition\" && node.name === contractName);\n  }, undefined);\n}\nexports.getContractNode = getContractNode;\n/**\n * extract the primary source from a source map\n * (i.e., the source for the first instruction, found\n * between the second and third colons)\n */\nfunction extractPrimarySource(sourceMap) {\n  if (!sourceMap) {\n    //HACK?\n    return 0; //in this case (e.g. a Vyper contract with an old-style\n    //source map) we infer that it was compiled by itself\n  }\n\n  return parseInt(sourceMap.match(/^[^:]*:[^:]*:([^:]*):/)[1] || \"0\");\n}\nfunction normalizeGeneratedSources(generatedSources, compiler) {\n  if (!generatedSources) {\n    return [];\n  }\n  if (!isGeneratedSources(generatedSources)) {\n    return generatedSources; //if already normalizeed, leave alone\n  }\n\n  let sources = []; //output\n  for (let source of generatedSources) {\n    sources[source.id] = {\n      id: source.id.toString(),\n      sourcePath: source.name,\n      source: source.contents,\n      //ast needs to be coerced because schema doesn't quite match our types here...\n      ast: source.ast,\n      compiler: compiler,\n      language: source.language\n    };\n  }\n  return sources;\n}\n//HACK\nfunction isGeneratedSources(sources) {\n  //note: for some reason arr.includes(undefined) returns true on sparse arrays\n  //if sources.length === 0, it's ambiguous; we'll exclude it as not needing normalization\n  return sources.length > 0 && !sources.includes(undefined) && (sources[0].contents !== undefined || sources[0].name !== undefined);\n}\n//HACK, maybe?\nfunction inferLanguage(ast, compiler, sourcePath) {\n  if (ast) {\n    if (ast.nodeType === \"SourceUnit\") {\n      return \"Solidity\";\n    } else if (ast.nodeType && ast.nodeType.startsWith(\"Yul\")) {\n      //Every Yul source I've seen has YulBlock as the root, but\n      //I'm not sure that that's *always* the case\n      return \"Yul\";\n    } else if (Array.isArray(ast) || ast.ast_type === \"Module\") {\n      return \"Vyper\";\n    }\n  } else if (compiler) {\n    if (compiler.name === \"vyper\") {\n      return \"Vyper\";\n    } else if (compiler.name === \"solc\") {\n      //assuming sources compiled with solc without sourcePath are Solidity\n      if (sourcePath && sourcePath.endsWith(\".yul\")) {\n        return \"Yul\";\n      } else {\n        return \"Solidity\";\n      }\n    } else {\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n}\nfunction getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder) {\n  debug(\"sourcePath: %s\", sourceObject.sourcePath);\n  debug(\"given index: %d\", index);\n  debug(\"sources: %o\", sources.map(source => source.sourcePath));\n  //first: is this already there? only add it if it's not.\n  //(we determine this by sourcePath if present, and the actual source\n  //contents if not)\n  const existingIndex = sources.findIndex(existingSource => existingSource && (\n  //findIndex treats absent as undefined, so we need this guard\n  // (array may be sparse)\n  existingSource.sourcePath === sourceObject.sourcePath || !sourceObject.sourcePath && !existingSource.sourcePath && existingSource.source === sourceObject.source));\n  if (existingIndex === -1) {\n    //it's not already there, let's add it\n    if (unreliableSourceOrder || index === undefined || index in sources) {\n      //if we can't add it at the correct spot, set the\n      //unreliable source order flag\n      debug(\"collision!\");\n      unreliableSourceOrder = true;\n    }\n    if (unreliableSourceOrder) {\n      //in case of unreliable source order, we'll ignore what indices\n      //things are *supposed* to have and just append things to the end\n      index = sources.length;\n    }\n    //otherwise, just leave things alone\n    return {\n      index,\n      needsAdding: true,\n      unreliableSourceOrder\n    };\n  } else {\n    debug(\"already present, not adding\");\n    return {\n      index: existingIndex,\n      needsAdding: false,\n      unreliableSourceOrder\n    };\n  }\n}\n/**\n * convert Vyper source maps to solidity ones\n * (note we won't bother handling the case where the compressed\n * version doesn't exist; that will have to wait for a later version)\n */\nfunction simpleShimSourceMap(sourceMap) {\n  if (sourceMap === undefined) {\n    return undefined; //undefined case\n  } else if (typeof sourceMap === \"object\") {\n    return sourceMap.pc_pos_map_compressed; //Vyper object case\n  } else {\n    try {\n      return JSON.parse(sourceMap).pc_pos_map_compressed; //Vyper JSON case\n    } catch (_) {\n      return sourceMap; //Solidity case\n    }\n  }\n}\n\nexports.simpleShimSourceMap = simpleShimSourceMap;\n/**\n * collects user defined types & tagged outputs for a given set of compilations,\n * returning both the definition nodes and (for the types) the type objects\n *\n * \"Tagged outputs\" means user-defined things that are output by a contract\n * (not input to a contract), and which are distinguished by (potentially\n * ambiguous) selectors.  So, events and custom errors are tagged outputs.\n * Function arguments are not tagged outputs (they're not outputs).\n * Return values are not tagged outputs (they don't have a selector).\n * Built-in errors (Error(string) and Panic(uint))... OK I guess those could\n * be considered tagged outputs, but we're only looking at user-defined ones\n * here.\n */\nfunction collectUserDefinedTypesAndTaggedOutputs(compilations) {\n  let references = {};\n  let types = {};\n  for (const compilation of compilations) {\n    references[compilation.id] = {};\n    types[compilation.id] = {\n      compiler: compilation.compiler,\n      types: {}\n    };\n    for (const source of compilation.sources) {\n      if (!source) {\n        continue; //remember, sources could be empty if shimmed!\n      }\n\n      const {\n        ast,\n        compiler,\n        language\n      } = source;\n      if (language === \"Solidity\" && ast) {\n        //don't check Yul or Vyper sources!\n        for (const node of ast.nodes) {\n          if (node.nodeType === \"StructDefinition\" || node.nodeType === \"EnumDefinition\" || node.nodeType === \"UserDefinedValueTypeDefinition\" || node.nodeType === \"ContractDefinition\") {\n            references[compilation.id][node.id] = node;\n            //we don't have all the references yet, but we actually don't need them :)\n            const dataType = Ast.Import.definitionToStoredType(node, compilation.id, compiler, references[compilation.id]);\n            types[compilation.id].types[dataType.id] = dataType;\n          } else if (node.nodeType === \"EventDefinition\" || node.nodeType === \"ErrorDefinition\") {\n            references[compilation.id][node.id] = node;\n          }\n          if (node.nodeType === \"ContractDefinition\") {\n            for (const subNode of node.nodes) {\n              if (subNode.nodeType === \"StructDefinition\" || subNode.nodeType === \"EnumDefinition\" || subNode.nodeType === \"UserDefinedValueTypeDefinition\") {\n                references[compilation.id][subNode.id] = subNode;\n                //we don't have all the references yet, but we only need the\n                //reference to the defining contract, which we just added above!\n                const dataType = Ast.Import.definitionToStoredType(subNode, compilation.id, compiler, references[compilation.id]);\n                types[compilation.id].types[dataType.id] = dataType;\n              } else if (subNode.nodeType === \"EventDefinition\" || subNode.nodeType === \"ErrorDefinition\") {\n                references[compilation.id][subNode.id] = subNode;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return {\n    definitions: references,\n    typesByCompilation: types,\n    types: Format.Types.forgetCompilations(types)\n  };\n}\nexports.collectUserDefinedTypesAndTaggedOutputs = collectUserDefinedTypesAndTaggedOutputs;\n/**\n * Given a list of compilations, and an artifact appearing in one\n * of those compilations, finds the compilation and the corresponding\n * contract object\n * (these may be undefined if they can't be found)\n */\nfunction findCompilationAndContract(compilations, artifact) {\n  const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(artifact.deployedBytecode);\n  const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(artifact.bytecode);\n  let firstNameMatch;\n  let multipleNameMatches = false;\n  for (const compilation of compilations) {\n    for (const contract of compilation.contracts) {\n      const nameMatches = contract.contractName === (artifact.contractName || artifact.contract_name);\n      if (nameMatches) {\n        if (bytecode) {\n          if (compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode) === bytecode) {\n            return {\n              compilation,\n              contract\n            };\n          }\n        } else if (deployedBytecode) {\n          if (compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode) === deployedBytecode) {\n            return {\n              compilation,\n              contract\n            };\n          }\n        } else if (!firstNameMatch) {\n          //if we have a name match, but no bytecode to go by, record this one.\n          //if it turns out to be the only one, we'll return it later.\n          firstNameMatch = {\n            compilation,\n            contract\n          };\n        } else if (!multipleNameMatches) {\n          //on the other hand, if there *is* an existing name match already,\n          //record that we've got multiple.\n          multipleNameMatches = true;\n        }\n      }\n    }\n  }\n  //once the loop is done, if we haven't returned a bytecode match,\n  //check if we've got a unique name match, and return it if so\n  if (firstNameMatch && !multipleNameMatches) {\n    return firstNameMatch;\n  }\n  //otherwise, if there's no bytecode match, and either no name match\n  //or multiple name matches, just return a default fallback\n  const defaultContract = {\n    contractName: artifact.contractName || artifact.contract_name,\n    abi: artifact.abi\n  };\n  const defaultCompilation = {\n    id: \"defaultCompilation\",\n    sources: [],\n    contracts: [defaultContract]\n  };\n  return {\n    compilation: defaultCompilation,\n    contract: defaultContract\n  };\n}\nexports.findCompilationAndContract = findCompilationAndContract;\nfunction projectInfoIsCodecStyle(info) {\n  return Boolean(info.compilations);\n}\nfunction projectInfoIsCommonStyle(info) {\n  return Boolean(info.commonCompilations);\n}\nfunction projectInfoIsArtifacts(info) {\n  return Boolean(info.artifacts);\n}\nfunction infoToCompilations(projectInfo, nonceString) {\n  if (!projectInfo) {\n    throw new errors_1.NoProjectInfoError();\n  }\n  if (projectInfoIsCodecStyle(projectInfo)) {\n    return projectInfo.compilations;\n  } else if (projectInfoIsCommonStyle(projectInfo)) {\n    return shimCompilations(projectInfo.commonCompilations, nonceString);\n  } else if (projectInfoIsArtifacts(projectInfo)) {\n    return shimArtifacts(projectInfo.artifacts, undefined, nonceString);\n  }\n}\nexports.infoToCompilations = infoToCompilations;\nfunction findRepeatCompilationIds(compilations) {\n  let repeats = new Set();\n  for (let i = 0; i < compilations.length; i++) {\n    for (let j = i + 1; j < compilations.length; j++) {\n      if (compilations[i].id === compilations[j].id) {\n        repeats.add(compilations[i].id);\n      }\n    }\n  }\n  return repeats;\n}\nexports.findRepeatCompilationIds = findRepeatCompilationIds;","map":{"version":3,"mappings":"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","names":["debug","shimCompilations","inputCompilations","shimmedCompilationIdPrefix","map","compilation","compilationIndex","shimCompilation","exports","inputCompilation","shimmedCompilationId","shimContracts","contracts","files","sourceIndexes","sources","compiler","shimArtifacts","artifacts","options","inputSources","unreliableSourceOrder","artifact","contractName","bytecode","sourceMap","deployedBytecode","deployedSourceMap","immutableReferences","sourcePath","source","ast","abi","generatedSources","deployedGeneratedSources","metadata","contract_name","contractObject","normalizeGeneratedSources","sourceObject","language","inferLanguage","parsedMetadata","JSON","parse","settings","viaIR","index","findIndex","indexOf","id","toString","primarySourceId","needsAdding","sourceIndexForAst","name","undefined","sourceMapString","simpleShimSourceMap","extractPrimarySource","getIndexToAddAt","push","contract","length","contents","Array","isArray","parseInt","src","split","getContractNode","sourcesToCheck","find","sourceId","reduce","foundNode","nodes","node","nodeType","match","isGeneratedSources","includes","startsWith","ast_type","endsWith","existingIndex","existingSource","pc_pos_map_compressed","_","collectUserDefinedTypesAndTaggedOutputs","compilations","references","types","dataType","Ast","Import","definitionToStoredType","subNode","definitions","typesByCompilation","Format","Types","forgetCompilations","findCompilationAndContract","compile_common_1","NewToLegacy","forBytecode","firstNameMatch","multipleNameMatches","nameMatches","defaultContract","defaultCompilation","projectInfoIsCodecStyle","info","Boolean","projectInfoIsCommonStyle","commonCompilations","projectInfoIsArtifacts","infoToCompilations","projectInfo","nonceString","errors_1","findRepeatCompilationIds","repeats","Set","i","j","add"],"sourceRoot":"","sources":["../../../lib/compilations/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}