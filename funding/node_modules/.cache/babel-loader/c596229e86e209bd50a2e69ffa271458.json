{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectAllocationInfo = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:abi-data:allocate:utils\");\nconst Compilations = __importStar(require(\"../../compilations\"));\nconst compile_common_1 = require(\"@truffle/compile-common\");\nconst Contexts = __importStar(require(\"../../contexts\"));\nconst Abi = __importStar(require(\"@truffle/abi-utils\"));\nfunction collectAllocationInfo(compilations) {\n  let contexts = {};\n  let deployedContexts = {};\n  let contractsAndContexts = [];\n  for (const compilation of compilations) {\n    for (const contract of compilation.contracts) {\n      const node = Compilations.Utils.getContractNode(contract, compilation);\n      let deployedContext = undefined;\n      let constructorContext = undefined;\n      const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode);\n      const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode);\n      if (deployedBytecode && deployedBytecode !== \"0x\") {\n        deployedContext = Contexts.Utils.makeContext(contract, node, compilation);\n        contexts[deployedContext.context] = deployedContext;\n        //note that we don't set up deployedContexts until after normalization!\n      }\n\n      if (bytecode && bytecode !== \"0x\") {\n        constructorContext = Contexts.Utils.makeContext(contract, node, compilation, true);\n        contexts[constructorContext.context] = constructorContext;\n      }\n      contractsAndContexts.push({\n        contract,\n        node,\n        deployedContext,\n        constructorContext,\n        compilationId: compilation.id\n      });\n    }\n  }\n  debug(\"known contexts: %o\", Object.keys(contexts));\n  contexts = Contexts.Utils.normalizeContexts(contexts);\n  deployedContexts = Object.assign({}, ...Object.values(contexts).map(context => !context.isConstructor ? {\n    [context.context]: context\n  } : {}));\n  for (const contractAndContexts of contractsAndContexts) {\n    //change everything to normalized version\n    if (contractAndContexts.deployedContext) {\n      contractAndContexts.deployedContext = contexts[contractAndContexts.deployedContext.context]; //get normalized version\n    }\n\n    if (contractAndContexts.constructorContext) {\n      contractAndContexts.constructorContext = contexts[contractAndContexts.constructorContext.context]; //get normalized version\n    }\n  }\n\n  const allocationInfo = contractsAndContexts.map(_ref => {\n    let {\n      contract: {\n        abi,\n        compiler,\n        immutableReferences\n      },\n      compilationId,\n      node,\n      deployedContext,\n      constructorContext\n    } = _ref;\n    return {\n      abi: Abi.normalize(abi),\n      compilationId,\n      compiler,\n      contractNode: node,\n      deployedContext,\n      constructorContext,\n      immutableReferences\n    };\n  });\n  return {\n    contexts,\n    deployedContexts,\n    contractsAndContexts,\n    allocationInfo\n  };\n}\nexports.collectAllocationInfo = collectAllocationInfo;","map":{"version":3,"mappings":"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","names":["debug","collectAllocationInfo","compilations","contexts","deployedContexts","contractsAndContexts","compilation","contract","contracts","node","Compilations","Utils","getContractNode","deployedContext","undefined","constructorContext","deployedBytecode","compile_common_1","NewToLegacy","forBytecode","bytecode","Contexts","makeContext","context","push","compilationId","id","Object","keys","normalizeContexts","assign","values","map","isConstructor","contractAndContexts","allocationInfo","abi","compiler","immutableReferences","Abi","normalize","contractNode","exports"],"sourceRoot":"","sources":["../../../../lib/abi-data/allocate/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}