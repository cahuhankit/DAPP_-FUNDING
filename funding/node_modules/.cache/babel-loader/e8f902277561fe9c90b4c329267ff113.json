{"ast":null,"code":"import { MaxLengthUpperBound } from '../helpers/MaxLengthFromMinLength.js';\nexport function patternsToStringMapper(tab) {\n  return tab.join('');\n}\nexport function patternsToStringUnmapperFor(patternsArb, constraints) {\n  return function patternsToStringUnmapper(value) {\n    if (typeof value !== 'string') {\n      throw new Error('Unsupported value');\n    }\n    const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;\n    const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthUpperBound;\n    if (value.length === 0) {\n      if (minLength > 0) {\n        throw new Error('Unable to unmap received string');\n      }\n      return [];\n    }\n    const stack = [{\n      endIndexChunks: 0,\n      nextStartIndex: 1,\n      chunks: []\n    }];\n    while (stack.length > 0) {\n      const last = stack.pop();\n      for (let index = last.nextStartIndex; index <= value.length; ++index) {\n        const chunk = value.substring(last.endIndexChunks, index);\n        if (patternsArb.canShrinkWithoutContext(chunk)) {\n          const newChunks = last.chunks.concat([chunk]);\n          if (index === value.length) {\n            if (newChunks.length < minLength || newChunks.length > maxLength) {\n              break;\n            }\n            return newChunks;\n          }\n          stack.push({\n            endIndexChunks: last.endIndexChunks,\n            nextStartIndex: index + 1,\n            chunks: last.chunks\n          });\n          stack.push({\n            endIndexChunks: index,\n            nextStartIndex: index + 1,\n            chunks: newChunks\n          });\n          break;\n        }\n      }\n    }\n    throw new Error('Unable to unmap received string');\n  };\n}","map":{"version":3,"names":["MaxLengthUpperBound","patternsToStringMapper","tab","join","patternsToStringUnmapperFor","patternsArb","constraints","patternsToStringUnmapper","value","Error","minLength","undefined","maxLength","length","stack","endIndexChunks","nextStartIndex","chunks","last","pop","index","chunk","substring","canShrinkWithoutContext","newChunks","concat","push"],"sources":["C:/Users/ankit/Desktop/FUND/funding/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PatternsToString.js"],"sourcesContent":["import { MaxLengthUpperBound } from '../helpers/MaxLengthFromMinLength.js';\nexport function patternsToStringMapper(tab) {\n    return tab.join('');\n}\nexport function patternsToStringUnmapperFor(patternsArb, constraints) {\n    return function patternsToStringUnmapper(value) {\n        if (typeof value !== 'string') {\n            throw new Error('Unsupported value');\n        }\n        const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;\n        const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthUpperBound;\n        if (value.length === 0) {\n            if (minLength > 0) {\n                throw new Error('Unable to unmap received string');\n            }\n            return [];\n        }\n        const stack = [{ endIndexChunks: 0, nextStartIndex: 1, chunks: [] }];\n        while (stack.length > 0) {\n            const last = stack.pop();\n            for (let index = last.nextStartIndex; index <= value.length; ++index) {\n                const chunk = value.substring(last.endIndexChunks, index);\n                if (patternsArb.canShrinkWithoutContext(chunk)) {\n                    const newChunks = last.chunks.concat([chunk]);\n                    if (index === value.length) {\n                        if (newChunks.length < minLength || newChunks.length > maxLength) {\n                            break;\n                        }\n                        return newChunks;\n                    }\n                    stack.push({ endIndexChunks: last.endIndexChunks, nextStartIndex: index + 1, chunks: last.chunks });\n                    stack.push({ endIndexChunks: index, nextStartIndex: index + 1, chunks: newChunks });\n                    break;\n                }\n            }\n        }\n        throw new Error('Unable to unmap received string');\n    };\n}\n"],"mappings":"AAAA,SAASA,mBAAmB,QAAQ,sCAAsC;AAC1E,OAAO,SAASC,sBAAsB,CAACC,GAAG,EAAE;EACxC,OAAOA,GAAG,CAACC,IAAI,CAAC,EAAE,CAAC;AACvB;AACA,OAAO,SAASC,2BAA2B,CAACC,WAAW,EAAEC,WAAW,EAAE;EAClE,OAAO,SAASC,wBAAwB,CAACC,KAAK,EAAE;IAC5C,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC3B,MAAM,IAAIC,KAAK,CAAC,mBAAmB,CAAC;IACxC;IACA,MAAMC,SAAS,GAAGJ,WAAW,CAACI,SAAS,KAAKC,SAAS,GAAGL,WAAW,CAACI,SAAS,GAAG,CAAC;IACjF,MAAME,SAAS,GAAGN,WAAW,CAACM,SAAS,KAAKD,SAAS,GAAGL,WAAW,CAACM,SAAS,GAAGZ,mBAAmB;IACnG,IAAIQ,KAAK,CAACK,MAAM,KAAK,CAAC,EAAE;MACpB,IAAIH,SAAS,GAAG,CAAC,EAAE;QACf,MAAM,IAAID,KAAK,CAAC,iCAAiC,CAAC;MACtD;MACA,OAAO,EAAE;IACb;IACA,MAAMK,KAAK,GAAG,CAAC;MAAEC,cAAc,EAAE,CAAC;MAAEC,cAAc,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAG,CAAC,CAAC;IACpE,OAAOH,KAAK,CAACD,MAAM,GAAG,CAAC,EAAE;MACrB,MAAMK,IAAI,GAAGJ,KAAK,CAACK,GAAG,EAAE;MACxB,KAAK,IAAIC,KAAK,GAAGF,IAAI,CAACF,cAAc,EAAEI,KAAK,IAAIZ,KAAK,CAACK,MAAM,EAAE,EAAEO,KAAK,EAAE;QAClE,MAAMC,KAAK,GAAGb,KAAK,CAACc,SAAS,CAACJ,IAAI,CAACH,cAAc,EAAEK,KAAK,CAAC;QACzD,IAAIf,WAAW,CAACkB,uBAAuB,CAACF,KAAK,CAAC,EAAE;UAC5C,MAAMG,SAAS,GAAGN,IAAI,CAACD,MAAM,CAACQ,MAAM,CAAC,CAACJ,KAAK,CAAC,CAAC;UAC7C,IAAID,KAAK,KAAKZ,KAAK,CAACK,MAAM,EAAE;YACxB,IAAIW,SAAS,CAACX,MAAM,GAAGH,SAAS,IAAIc,SAAS,CAACX,MAAM,GAAGD,SAAS,EAAE;cAC9D;YACJ;YACA,OAAOY,SAAS;UACpB;UACAV,KAAK,CAACY,IAAI,CAAC;YAAEX,cAAc,EAAEG,IAAI,CAACH,cAAc;YAAEC,cAAc,EAAEI,KAAK,GAAG,CAAC;YAAEH,MAAM,EAAEC,IAAI,CAACD;UAAO,CAAC,CAAC;UACnGH,KAAK,CAACY,IAAI,CAAC;YAAEX,cAAc,EAAEK,KAAK;YAAEJ,cAAc,EAAEI,KAAK,GAAG,CAAC;YAAEH,MAAM,EAAEO;UAAU,CAAC,CAAC;UACnF;QACJ;MACJ;IACJ;IACA,MAAM,IAAIf,KAAK,CAAC,iCAAiC,CAAC;EACtD,CAAC;AACL"},"metadata":{},"sourceType":"module"}