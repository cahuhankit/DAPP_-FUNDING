{"ast":null,"code":"const debug = require(\"debug\")(\"contract:handlers\");\nconst StatusError = require(\"./statuserror\");\nconst Utils = require(\"./utils\");\nconst Reason = require(\"./reason\");\n\n/*\n  Handlers for events emitted by `send` / `call` etc.\n */\nconst handlers = {\n  // ----------------------------------- Constants -------------------------------------------------\n\n  maxConfirmations: 24,\n  // Maximum number of confirmation web3 emits\n  defaultTimeoutBlocks: 50,\n  // Maximum number of blocks web3 will wait before abandoning tx\n  timeoutMessage: \"50 blocks\",\n  // Substring of web3 timeout error.\n  defaultWeb3Error: \"please check your gas limit\",\n  // Substring of default Web3 error\n\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Parses error message and determines if we should squash web3 timeout errors at user's request.\n   * @param  {Object} contract contract instance\n   * @param  {Object} message  error message\n   * @return {Boolean}\n   */\n  ignoreTimeoutError(_ref, _ref2) {\n    let {\n      contract\n    } = _ref;\n    let {\n      message\n    } = _ref2;\n    const timedOut = message && message.includes(handlers.timeoutMessage);\n    const shouldWait = contract && contract.timeoutBlocks && contract.timeoutBlocks > handlers.defaultTimeoutBlocks;\n    const waitForTxPropagation = message && message.includes(handlers.defaultWeb3Error);\n    return shouldWait && (timedOut || waitForTxPropagation);\n  },\n  /**\n   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.\n   * @param {Object}       context  execution state\n   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call\n   */\n  setup: function (emitter, context) {\n    emitter.on(\"error\", handlers.error.bind(emitter, context));\n    emitter.on(\"transactionHash\", handlers.hash.bind(emitter, context));\n    // web3 block polls if the confirmation listener is enabled so we want to\n    // give users a way of opting out of this behavior - it causes problems in testing\n    if (!context.contract.disableConfirmationListener) {\n      emitter.on(\"confirmation\", handlers.confirmation.bind(emitter, context));\n    }\n    emitter.on(\"receipt\", handlers.receipt.bind(emitter, context));\n  },\n  // -----------------------------------  Handlers -------------------------------------------------\n  /**\n   * Error event handler. Emits error unless error is block timeout and user has\n   * specified we should wait longer\n   * @param  {Object} context   execution state\n   * @param  {Object} error     error\n   */\n  error: function (context, error) {\n    if (!handlers.ignoreTimeoutError(context, error)) {\n      context.promiEvent.eventEmitter.emit(\"error\", error);\n      this.removeListener(\"error\", handlers.error);\n    }\n  },\n  /**\n   * Transaction hash event handler. Attaches the hash to the context object\n   * so it can be attached to the contract instance after a deployment resolves.\n   * @param  {Object} context   execution state\n   * @param  {String} hash      transaction hash\n   */\n  hash: function (context, hash) {\n    context.transactionHash = hash;\n    context.promiEvent.eventEmitter.emit(\"transactionHash\", hash);\n    this.removeListener(\"transactionHash\", handlers.hash);\n  },\n  confirmation: function (context, number, receipt) {\n    context.promiEvent.eventEmitter.emit(\"confirmation\", number, receipt);\n\n    // Per web3: initial confirmation index is 0\n    if (number === handlers.maxConfirmations + 1) {\n      this.removeListener(\"confirmation\", handlers.confirmation);\n    }\n  },\n  /**\n   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,\n   * and (for method calls only) resolves/rejects the promiEvent with the receipt.\n   * @param  {Object} context   execution state\n   * @param  {Object} receipt   transaction receipt\n   */\n  receipt: async function (context, receipt) {\n    // keep around the raw (not decoded) logs in the raw logs field as a\n    // stopgap until we can get the ABI for all events, not just the current\n    // contract\n    receipt.rawLogs = receipt.logs;\n\n    // Decode logs, use as receipt.logs for ease of use.\n    try {\n      receipt.logs = receipt.logs ? Utils.decodeLogs.call(context.contract, receipt.logs) : [];\n    } catch (error) {\n      return context.promiEvent.reject(error);\n    }\n\n    // Emit receipt\n    context.promiEvent.eventEmitter.emit(\"receipt\", receipt);\n\n    // .new(): Exit early. We need the promiEvent to resolve a contract instance.\n    if (context.onlyEmitReceipt) {\n      context.receipt = receipt;\n      return;\n    }\n\n    // .method(): resolve/reject receipt in handler\n    if (receipt.status !== undefined && !receipt.status) {\n      const reason = await Reason.get(context.params, context.contract.web3, context.contract.interfaceAdapter);\n      const error = new StatusError(context.params, receipt.transactionHash, receipt, reason);\n      return context.promiEvent.reject(error);\n    }\n\n    // This object has some duplicate data but is backward compatible.\n    context.promiEvent.resolve({\n      tx: receipt.transactionHash,\n      receipt: receipt,\n      logs: receipt.logs\n    });\n\n    //HACK: adding this conditional for when the handler is invoked\n    //manually during stacktracing\n    if (this.removeListener) {\n      this.removeListener(\"receipt\", handlers.receipt);\n    }\n  }\n};\nmodule.exports = handlers;","map":{"version":3,"names":["debug","require","StatusError","Utils","Reason","handlers","maxConfirmations","defaultTimeoutBlocks","timeoutMessage","defaultWeb3Error","ignoreTimeoutError","contract","message","timedOut","includes","shouldWait","timeoutBlocks","waitForTxPropagation","setup","emitter","context","on","error","bind","hash","disableConfirmationListener","confirmation","receipt","promiEvent","eventEmitter","emit","removeListener","transactionHash","number","rawLogs","logs","decodeLogs","call","reject","onlyEmitReceipt","status","undefined","reason","get","params","web3","interfaceAdapter","resolve","tx","module","exports"],"sources":["C:/Users/ankit/Desktop/FUND/funding/node_modules/@truffle/contract/lib/handlers.js"],"sourcesContent":["const debug = require(\"debug\")(\"contract:handlers\");\nconst StatusError = require(\"./statuserror\");\nconst Utils = require(\"./utils\");\nconst Reason = require(\"./reason\");\n\n/*\n  Handlers for events emitted by `send` / `call` etc.\n */\nconst handlers = {\n  // ----------------------------------- Constants -------------------------------------------------\n\n  maxConfirmations: 24, // Maximum number of confirmation web3 emits\n  defaultTimeoutBlocks: 50, // Maximum number of blocks web3 will wait before abandoning tx\n  timeoutMessage: \"50 blocks\", // Substring of web3 timeout error.\n  defaultWeb3Error: \"please check your gas limit\", // Substring of default Web3 error\n\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Parses error message and determines if we should squash web3 timeout errors at user's request.\n   * @param  {Object} contract contract instance\n   * @param  {Object} message  error message\n   * @return {Boolean}\n   */\n  ignoreTimeoutError({ contract }, { message }) {\n    const timedOut = message && message.includes(handlers.timeoutMessage);\n\n    const shouldWait =\n      contract &&\n      contract.timeoutBlocks &&\n      contract.timeoutBlocks > handlers.defaultTimeoutBlocks;\n\n    const waitForTxPropagation =\n      message && message.includes(handlers.defaultWeb3Error);\n\n    return shouldWait && (timedOut || waitForTxPropagation);\n  },\n\n  /**\n   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.\n   * @param {Object}       context  execution state\n   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call\n   */\n  setup: function(emitter, context) {\n    emitter.on(\"error\", handlers.error.bind(emitter, context));\n    emitter.on(\"transactionHash\", handlers.hash.bind(emitter, context));\n    // web3 block polls if the confirmation listener is enabled so we want to\n    // give users a way of opting out of this behavior - it causes problems in testing\n    if (!context.contract.disableConfirmationListener) {\n      emitter.on(\"confirmation\", handlers.confirmation.bind(emitter, context));\n    }\n    emitter.on(\"receipt\", handlers.receipt.bind(emitter, context));\n  },\n\n  // -----------------------------------  Handlers -------------------------------------------------\n  /**\n   * Error event handler. Emits error unless error is block timeout and user has\n   * specified we should wait longer\n   * @param  {Object} context   execution state\n   * @param  {Object} error     error\n   */\n  error: function(context, error) {\n    if (!handlers.ignoreTimeoutError(context, error)) {\n      context.promiEvent.eventEmitter.emit(\"error\", error);\n      this.removeListener(\"error\", handlers.error);\n    }\n  },\n\n  /**\n   * Transaction hash event handler. Attaches the hash to the context object\n   * so it can be attached to the contract instance after a deployment resolves.\n   * @param  {Object} context   execution state\n   * @param  {String} hash      transaction hash\n   */\n  hash: function(context, hash) {\n    context.transactionHash = hash;\n    context.promiEvent.eventEmitter.emit(\"transactionHash\", hash);\n    this.removeListener(\"transactionHash\", handlers.hash);\n  },\n\n  confirmation: function(context, number, receipt) {\n    context.promiEvent.eventEmitter.emit(\"confirmation\", number, receipt);\n\n    // Per web3: initial confirmation index is 0\n    if (number === handlers.maxConfirmations + 1) {\n      this.removeListener(\"confirmation\", handlers.confirmation);\n    }\n  },\n\n  /**\n   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,\n   * and (for method calls only) resolves/rejects the promiEvent with the receipt.\n   * @param  {Object} context   execution state\n   * @param  {Object} receipt   transaction receipt\n   */\n  receipt: async function(context, receipt) {\n    // keep around the raw (not decoded) logs in the raw logs field as a\n    // stopgap until we can get the ABI for all events, not just the current\n    // contract\n    receipt.rawLogs = receipt.logs;\n\n    // Decode logs, use as receipt.logs for ease of use.\n    try {\n      receipt.logs = receipt.logs\n        ? Utils.decodeLogs.call(context.contract, receipt.logs)\n        : [];\n    } catch (error) {\n      return context.promiEvent.reject(error);\n    }\n\n    // Emit receipt\n    context.promiEvent.eventEmitter.emit(\"receipt\", receipt);\n\n    // .new(): Exit early. We need the promiEvent to resolve a contract instance.\n    if (context.onlyEmitReceipt) {\n      context.receipt = receipt;\n      return;\n    }\n\n    // .method(): resolve/reject receipt in handler\n    if (receipt.status !== undefined && !receipt.status) {\n      const reason = await Reason.get(\n        context.params,\n        context.contract.web3,\n        context.contract.interfaceAdapter\n      );\n\n      const error = new StatusError(\n        context.params,\n        receipt.transactionHash,\n        receipt,\n        reason\n      );\n\n      return context.promiEvent.reject(error);\n    }\n\n    // This object has some duplicate data but is backward compatible.\n    context.promiEvent.resolve({\n      tx: receipt.transactionHash,\n      receipt: receipt,\n      logs: receipt.logs\n    });\n\n    //HACK: adding this conditional for when the handler is invoked\n    //manually during stacktracing\n    if (this.removeListener) {\n      this.removeListener(\"receipt\", handlers.receipt);\n    }\n  }\n};\n\nmodule.exports = handlers;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}