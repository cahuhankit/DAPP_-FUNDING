{"ast":null,"code":"\"use strict\";\n\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:abi-data:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst errors_1 = require(\"../../errors\");\nfunction decodeAbi(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    if (Format.Types.isReferenceType(dataType) || dataType.typeClass === \"tuple\") {\n      //I don't want tuples to be considered a reference type, but it makes sense\n      //to group them for this purpose\n      let dynamic;\n      try {\n        dynamic = (0, allocate_1.abiSizeInfo)(dataType, info.allocations.abi).dynamic;\n      } catch (error) {\n        return (0, errors_1.handleDecodingError)(dataType, error, options.strictAbiMode);\n      }\n      if (dynamic) {\n        return yield* decodeAbiReferenceByAddress(dataType, pointer, info, options);\n      } else {\n        return yield* decodeAbiReferenceStatic(dataType, pointer, info, options);\n      }\n    } else {\n      debug(\"pointer %o\", pointer);\n      return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n    }\n  }();\n}\nexports.decodeAbi = decodeAbi;\nfunction decodeAbiReferenceByAddress(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    let {\n      strictAbiMode: strict,\n      abiPointerBase: base,\n      lengthOverride\n    } = options;\n    base = base || 0; //in case base was undefined\n    const {\n      allocations: {\n        abi: allocations\n      },\n      state\n    } = info;\n    debug(\"pointer %o\", pointer);\n    //this variable holds the location we should look to *next*\n    //stack pointers point to calldata; other pointers point to same location\n    const location = pointer.location === \"stack\" || pointer.location === \"stackliteral\" ? \"calldata\" : pointer.location;\n    if (pointer.location !== \"stack\" && pointer.location !== \"stackliteral\") {\n      //length overrides are only applicable when you're decoding a pointer\n      //from the stack!  otherwise they must be ignored!\n      lengthOverride = undefined;\n    }\n    let rawValue;\n    try {\n      rawValue = yield* (0, read_1.default)(pointer, state);\n    } catch (error) {\n      return (0, errors_1.handleDecodingError)(dataType, error, strict);\n    }\n    let rawValueAsBN = Conversion.toBN(rawValue);\n    debug(\"rawValue: %O\", rawValue);\n    debug(\"rawValueAsBN: %O\", rawValueAsBN);\n    let rawValueAsNumber;\n    try {\n      rawValueAsNumber = rawValueAsBN.toNumber();\n    } catch (_a) {\n      let error = {\n        kind: \"OverlargePointersNotImplementedError\",\n        pointerAsBN: rawValueAsBN\n      };\n      if (strict) {\n        throw new errors_1.StopDecodingError(error);\n      }\n      return {\n        //again with the TS failures...\n        type: dataType,\n        kind: \"error\",\n        error\n      };\n    }\n    let startPosition = rawValueAsNumber + base;\n    debug(\"startPosition %d\", startPosition);\n    let dynamic;\n    let size;\n    try {\n      ({\n        dynamic,\n        size\n      } = (0, allocate_1.abiSizeInfo)(dataType, allocations));\n    } catch (error) {\n      return (0, errors_1.handleDecodingError)(dataType, error, strict);\n    }\n    if (!dynamic) {\n      //this will only come up when called from stack.ts\n      let staticPointer = {\n        location,\n        start: startPosition,\n        length: size\n      };\n      return yield* decodeAbiReferenceStatic(dataType, staticPointer, info, options);\n    }\n    let length;\n    let lengthAsBN;\n    let rawLength;\n    switch (dataType.typeClass) {\n      case \"bytes\":\n      case \"string\":\n        //initial word contains length (unless an override was given)\n        if (lengthOverride !== undefined) {\n          lengthAsBN = lengthOverride;\n          //note in this case we do *not* increment start position;\n          //if a length override is given, that means the given start\n          //position skips over the length word!\n        } else {\n          try {\n            rawLength = yield* (0, read_1.default)({\n              location,\n              start: startPosition,\n              length: Evm.Utils.WORD_SIZE\n            }, state);\n          } catch (error) {\n            return (0, errors_1.handleDecodingError)(dataType, error, strict);\n          }\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length\n          //so it'll be set up to read the data\n        }\n\n        if (strict && lengthAsBN.gtn(state[location].length)) {\n          //you may notice that the comparison is a bit crude; that's OK, this is\n          //just to prevent huge numbers from DOSing us, other errors will still\n          //be caught regardless\n          throw new errors_1.StopDecodingError({\n            kind: \"OverlongArrayOrStringStrictModeError\",\n            lengthAsBN,\n            dataLength: state[location].length\n          });\n        }\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_b) {\n          //note: if we're in this situation, we can assume we're not in strict mode,\n          //as the strict case was handled above\n          return {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN\n            }\n          };\n        }\n        let childPointer = {\n          location,\n          start: startPosition,\n          length\n        };\n        return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info, options);\n      case \"array\":\n        if (dataType.kind === \"static\") {\n          //static-length array\n          lengthAsBN = dataType.length;\n          //note we don't increment start position; static arrays don't\n          //include a length word!\n        } else if (lengthOverride !== undefined) {\n          debug(\"override: %o\", lengthOverride);\n          //dynamic-length array, but with length override\n          lengthAsBN = lengthOverride;\n          //we don't increment start position; if a length override was\n          //given, that means the pointer skipped the length word!\n        } else {\n          //dynamic-length array, read length from data\n          //initial word contains array length\n          try {\n            rawLength = yield* (0, read_1.default)({\n              location,\n              start: startPosition,\n              length: Evm.Utils.WORD_SIZE\n            }, state);\n          } catch (error) {\n            return (0, errors_1.handleDecodingError)(dataType, error, strict);\n          }\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n          //to next word, as first word was used for length\n        }\n\n        if (strict && lengthAsBN.gtn(state[location].length)) {\n          //you may notice that the comparison is a bit crude; that's OK, this is\n          //just to prevent huge numbers from DOSing us, other errors will still\n          //be caught regardless\n          throw new errors_1.StopDecodingError({\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN,\n            dataLength: state[location].length\n          });\n        }\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_c) {\n          //again, if we get here, we can assume we're not in strict mode\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN\n            }\n          };\n        }\n        //note: I've written this fairly generically, but it is worth noting that\n        //since this array is of dynamic type, we know that if it's static length\n        //then size must be EVM.WORD_SIZE\n        let baseSize;\n        try {\n          baseSize = (0, allocate_1.abiSizeInfo)(dataType.baseType, allocations).size;\n        } catch (error) {\n          return (0, errors_1.handleDecodingError)(dataType, error, strict);\n        }\n        let decodedChildren = [];\n        for (let index = 0; index < length; index++) {\n          decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n            location,\n            start: startPosition + index * baseSize,\n            length: baseSize\n          }, info, Object.assign(Object.assign({}, options), {\n            abiPointerBase: startPosition\n          }))); //pointer base is always start of list, never the length\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedChildren\n        };\n      case \"struct\":\n        return yield* decodeAbiStructByPosition(dataType, location, startPosition, info, options);\n      case \"tuple\":\n        return yield* decodeAbiTupleByPosition(dataType, location, startPosition, info, options);\n    }\n  }();\n}\nexports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;\nfunction decodeAbiReferenceStatic(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    debug(\"static\");\n    debug(\"pointer %o\", pointer);\n    const location = pointer.location;\n    switch (dataType.typeClass) {\n      case \"array\":\n        //we're in the static case, so we know the array must be statically sized\n        const lengthAsBN = dataType.length;\n        let length;\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_a) {\n          //note: since this is the static case, we don't bother including the stronger\n          //strict-mode guard against getting DOSed by large array sizes, since in this\n          //case we're not reading the size from the input; if there's a huge static size\n          //array, well, we'll just have to deal with it\n          let error = {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN\n          };\n          if (options.strictAbiMode) {\n            throw new errors_1.StopDecodingError(error);\n          }\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n        let baseSize;\n        try {\n          baseSize = (0, allocate_1.abiSizeInfo)(dataType.baseType, info.allocations.abi).size;\n        } catch (error) {\n          return (0, errors_1.handleDecodingError)(dataType, error, options.strictAbiMode);\n        }\n        let decodedChildren = [];\n        for (let index = 0; index < length; index++) {\n          decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n            location,\n            start: pointer.start + index * baseSize,\n            length: baseSize\n          }, info, options));\n        }\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedChildren\n        };\n      case \"struct\":\n        return yield* decodeAbiStructByPosition(dataType, location, pointer.start, info, options);\n      case \"tuple\":\n        return yield* decodeAbiTupleByPosition(dataType, location, pointer.start, info, options);\n    }\n  }();\n}\nexports.decodeAbiReferenceStatic = decodeAbiReferenceStatic;\n//note that this function takes the start position as a *number*; it does not take a pointer\nfunction decodeAbiStructByPosition(dataType, location, startPosition, info) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  return function* () {\n    const {\n      allocations: {\n        abi: allocations\n      }\n    } = info;\n    const typeLocation = location === \"calldata\" ? \"calldata\" : null; //other abi locations are not valid type locations\n    const typeId = dataType.id;\n    const structAllocation = allocations[typeId];\n    if (!structAllocation) {\n      let error = {\n        kind: \"UserDefinedTypeNotFoundError\",\n        type: dataType\n      };\n      if (options.strictAbiMode || options.allowRetry) {\n        throw new errors_1.StopDecodingError(error, true);\n        //note that we allow a retry if we couldn't locate the allocation!\n      }\n\n      return {\n        type: dataType,\n        kind: \"error\",\n        error\n      };\n    }\n    let decodedMembers = [];\n    for (let index = 0; index < structAllocation.members.length; index++) {\n      const memberAllocation = structAllocation.members[index];\n      const memberPointer = memberAllocation.pointer;\n      const childPointer = {\n        location,\n        start: startPosition + memberPointer.start,\n        length: memberPointer.length\n      };\n      let memberName = memberAllocation.name;\n      let memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);\n      decodedMembers.push({\n        name: memberName,\n        value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n          abiPointerBase: startPosition\n        }))\n        //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n      });\n    }\n\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: decodedMembers\n    };\n  }();\n}\n//note that this function takes the start position as a *number*; it does not take a pointer\nfunction decodeAbiTupleByPosition(dataType, location, startPosition, info) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  return function* () {\n    //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n    //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder\n    //However it may be worth revisiting this in the future if performance turns out to be a problem\n    //(changing this may be pretty hard though)\n    let decodedMembers = [];\n    let position = startPosition;\n    for (const {\n      name,\n      type: memberType\n    } of dataType.memberTypes) {\n      const memberSize = (0, allocate_1.abiSizeInfo)(memberType, info.allocations.abi).size;\n      const childPointer = {\n        location,\n        start: position,\n        length: memberSize\n      };\n      decodedMembers.push({\n        name,\n        value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n          abiPointerBase: startPosition\n        }))\n        //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n      });\n\n      position += memberSize;\n    }\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: decodedMembers\n    };\n  }();\n}","map":{"version":3,"mappings":"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","names":["debug","decodeAbi","dataType","pointer","info","options","Format","Types","isReferenceType","typeClass","dynamic","allocations","abi","error","strictAbiMode","decodeAbiReferenceByAddress","decodeAbiReferenceStatic","Basic","Decode","decodeBasic","exports","strict","abiPointerBase","base","lengthOverride","state","location","undefined","rawValue","rawValueAsBN","Conversion","toBN","rawValueAsNumber","toNumber","kind","pointerAsBN","errors_1","type","startPosition","size","staticPointer","start","length","lengthAsBN","rawLength","Evm","Utils","WORD_SIZE","gtn","dataLength","childPointer","Bytes","decodeBytes","baseSize","baseType","decodedChildren","index","push","value","decodeAbiStructByPosition","decodeAbiTupleByPosition","typeLocation","typeId","id","structAllocation","allowRetry","decodedMembers","members","memberAllocation","memberPointer","memberName","name","memberType","specifyLocation","position","memberTypes","memberSize"],"sourceRoot":"","sources":["../../../../lib/abi-data/decode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}