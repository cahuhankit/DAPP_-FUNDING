{"ast":null,"code":"import { tuple } from './tuple.js';\nimport { uniqueArray } from './uniqueArray.js';\nimport { restrictedIntegerArbitraryBuilder } from './_internals/builders/RestrictedIntegerArbitraryBuilder.js';\nimport { maxGeneratedLengthFromSizeForArbitrary, MaxLengthUpperBound } from './_internals/helpers/MaxLengthFromMinLength.js';\nfunction extractMaxIndex(indexesAndValues) {\n  let maxIndex = -1;\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n  }\n  return maxIndex;\n}\nfunction arrayFromItems(length, indexesAndValues) {\n  const array = Array(length);\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    const it = indexesAndValues[index];\n    if (it[0] < length) array[it[0]] = it[1];\n  }\n  return array;\n}\nexport function sparseArray(arb) {\n  let constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    size,\n    minNumElements = 0,\n    maxLength = MaxLengthUpperBound,\n    maxNumElements = maxLength,\n    noTrailingHole,\n    depthIdentifier\n  } = constraints;\n  const maxGeneratedNumElements = maxGeneratedLengthFromSizeForArbitrary(size, minNumElements, maxNumElements, constraints.maxNumElements !== undefined);\n  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size, maxGeneratedNumElements, maxLength, constraints.maxLength !== undefined);\n  if (minNumElements > maxLength) {\n    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);\n  }\n  if (minNumElements > maxNumElements) {\n    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);\n  }\n  const resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n  const resultedSizeMaxNumElements = constraints.maxNumElements !== undefined || size !== undefined ? size : '=';\n  const maxGeneratedIndexAuthorized = Math.max(maxGeneratedLength - 1, 0);\n  const maxIndexAuthorized = Math.max(maxLength - 1, 0);\n  const sparseArrayNoTrailingHole = uniqueArray(tuple(restrictedIntegerArbitraryBuilder(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {\n    size: resultedSizeMaxNumElements,\n    minLength: minNumElements,\n    maxLength: resultedMaxNumElements,\n    selector: item => item[0],\n    depthIdentifier\n  }).map(items => {\n    const lastIndex = extractMaxIndex(items);\n    return arrayFromItems(lastIndex + 1, items);\n  }, value => {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n    if (noTrailingHole && value.length !== 0 && !(value.length - 1 in value)) {\n      throw new Error('No trailing hole');\n    }\n    return Object.entries(value).map(entry => [Number(entry[0]), entry[1]]);\n  });\n  if (noTrailingHole || maxLength === minNumElements) {\n    return sparseArrayNoTrailingHole;\n  }\n  return tuple(sparseArrayNoTrailingHole, restrictedIntegerArbitraryBuilder(minNumElements, maxGeneratedLength, maxLength)).map(data => {\n    const sparse = data[0];\n    const targetLength = data[1];\n    if (sparse.length >= targetLength) {\n      return sparse;\n    }\n    const longerSparse = sparse.slice();\n    longerSparse.length = targetLength;\n    return longerSparse;\n  }, value => {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n    return [value, value.length];\n  });\n}","map":{"version":3,"names":["tuple","uniqueArray","restrictedIntegerArbitraryBuilder","maxGeneratedLengthFromSizeForArbitrary","MaxLengthUpperBound","extractMaxIndex","indexesAndValues","maxIndex","index","length","Math","max","arrayFromItems","array","Array","it","sparseArray","arb","constraints","size","minNumElements","maxLength","maxNumElements","noTrailingHole","depthIdentifier","maxGeneratedNumElements","undefined","maxGeneratedLength","Error","resultedMaxNumElements","min","resultedSizeMaxNumElements","maxGeneratedIndexAuthorized","maxIndexAuthorized","sparseArrayNoTrailingHole","minLength","selector","item","map","items","lastIndex","value","isArray","Object","entries","entry","Number","data","sparse","targetLength","longerSparse","slice"],"sources":["C:/Users/ankit/Desktop/FUND/funding/node_modules/fast-check/lib/esm/arbitrary/sparseArray.js"],"sourcesContent":["import { tuple } from './tuple.js';\nimport { uniqueArray } from './uniqueArray.js';\nimport { restrictedIntegerArbitraryBuilder } from './_internals/builders/RestrictedIntegerArbitraryBuilder.js';\nimport { maxGeneratedLengthFromSizeForArbitrary, MaxLengthUpperBound, } from './_internals/helpers/MaxLengthFromMinLength.js';\nfunction extractMaxIndex(indexesAndValues) {\n    let maxIndex = -1;\n    for (let index = 0; index !== indexesAndValues.length; ++index) {\n        maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n    }\n    return maxIndex;\n}\nfunction arrayFromItems(length, indexesAndValues) {\n    const array = Array(length);\n    for (let index = 0; index !== indexesAndValues.length; ++index) {\n        const it = indexesAndValues[index];\n        if (it[0] < length)\n            array[it[0]] = it[1];\n    }\n    return array;\n}\nexport function sparseArray(arb, constraints = {}) {\n    const { size, minNumElements = 0, maxLength = MaxLengthUpperBound, maxNumElements = maxLength, noTrailingHole, depthIdentifier, } = constraints;\n    const maxGeneratedNumElements = maxGeneratedLengthFromSizeForArbitrary(size, minNumElements, maxNumElements, constraints.maxNumElements !== undefined);\n    const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size, maxGeneratedNumElements, maxLength, constraints.maxLength !== undefined);\n    if (minNumElements > maxLength) {\n        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);\n    }\n    if (minNumElements > maxNumElements) {\n        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);\n    }\n    const resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n    const resultedSizeMaxNumElements = constraints.maxNumElements !== undefined || size !== undefined ? size : '=';\n    const maxGeneratedIndexAuthorized = Math.max(maxGeneratedLength - 1, 0);\n    const maxIndexAuthorized = Math.max(maxLength - 1, 0);\n    const sparseArrayNoTrailingHole = uniqueArray(tuple(restrictedIntegerArbitraryBuilder(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {\n        size: resultedSizeMaxNumElements,\n        minLength: minNumElements,\n        maxLength: resultedMaxNumElements,\n        selector: (item) => item[0],\n        depthIdentifier,\n    }).map((items) => {\n        const lastIndex = extractMaxIndex(items);\n        return arrayFromItems(lastIndex + 1, items);\n    }, (value) => {\n        if (!Array.isArray(value)) {\n            throw new Error('Not supported entry type');\n        }\n        if (noTrailingHole && value.length !== 0 && !(value.length - 1 in value)) {\n            throw new Error('No trailing hole');\n        }\n        return Object.entries(value).map((entry) => [Number(entry[0]), entry[1]]);\n    });\n    if (noTrailingHole || maxLength === minNumElements) {\n        return sparseArrayNoTrailingHole;\n    }\n    return tuple(sparseArrayNoTrailingHole, restrictedIntegerArbitraryBuilder(minNumElements, maxGeneratedLength, maxLength)).map((data) => {\n        const sparse = data[0];\n        const targetLength = data[1];\n        if (sparse.length >= targetLength) {\n            return sparse;\n        }\n        const longerSparse = sparse.slice();\n        longerSparse.length = targetLength;\n        return longerSparse;\n    }, (value) => {\n        if (!Array.isArray(value)) {\n            throw new Error('Not supported entry type');\n        }\n        return [value, value.length];\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}