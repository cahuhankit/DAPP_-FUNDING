{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isMoreSpecific = exports.isMoreSpecificMultiple = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:priority\");\nconst Format = __importStar(require(\"../format\"));\nconst utils_1 = require(\"./utils\");\n//is input 1 more specific than input 2? (nonstrict)\nfunction isMoreSpecificMultiple(types1, types2, userDefinedTypes) {\n  //just wrap the types in tuples and defer to isMoreSpecific()\n  const combinedType1 = {\n    typeClass: \"tuple\",\n    memberTypes: types1\n  };\n  const combinedType2 = {\n    typeClass: \"tuple\",\n    memberTypes: types2\n  };\n  return isMoreSpecific(combinedType1, combinedType2, userDefinedTypes, true);\n  //that last flag is so we ignore variable names at top level\n}\n\nexports.isMoreSpecificMultiple = isMoreSpecificMultiple;\n//is input 1 more specific than input 2?\n//(this is nonstrict)\nfunction isMoreSpecific(type1, type2, userDefinedTypes) {\n  let ignoreComponentNames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  //udvts get priority of underlying type!\n  if (type1.typeClass === \"userDefinedValueType\") {\n    type1 = getUnderlyingType(type1, userDefinedTypes);\n  }\n  if (type2.typeClass === \"userDefinedValueType\") {\n    type2 = getUnderlyingType(type2, userDefinedTypes);\n  }\n  const typeClasses = [[\"options\"], [\"array\"], [\"struct\", \"tuple\"], [\"address\", \"contract\"], [\"bytes\"], [\"function\"], [\"uint\", \"int\", \"fixed\", \"ufixed\"], [\"enum\"], [\"string\"], [\"bool\"]];\n  //for each type, what's the first one it counts as?\n  const index1 = typeClasses.findIndex(classes => classes.includes(type1.typeClass));\n  const index2 = typeClasses.findIndex(classes => classes.includes(type2.typeClass));\n  //NOTE: I am assuming neither will be -1!\n  //If either is, something has gone very wrong!\n  if (index1 < index2) {\n    return true;\n  } else if (index2 < index1) {\n    return false;\n  }\n  //otherwise, indices are equal, defer to tiebreaker\n  switch (type1.typeClass) {\n    case \"options\":\n      return isMoreSpecificOptions(type1, type2);\n    case \"address\":\n    case \"contract\":\n      return isMoreSpecificAddress(type1, type2);\n    case \"function\":\n      return isMoreSpecificFunction(\n      //we haven't actually checked visibility, so we'll have to coerce\n      type1, type2, userDefinedTypes);\n    case \"array\":\n      return isMoreSpecificArray(type1, type2, userDefinedTypes);\n    case \"bytes\":\n      return isMoreSpecificBytes(type1, type2);\n    case \"uint\":\n    case \"int\":\n    case \"fixed\":\n    case \"ufixed\":\n      return isMoreSpecificNumeric(type1, type2);\n    case \"enum\":\n      return isMoreSpecificEnum(type1, type2);\n    case \"string\":\n      return isMoreSpecificString(type1, type2);\n    case \"struct\":\n    case \"tuple\":\n      return isMoreSpecificTuple(type1, type2, userDefinedTypes, ignoreComponentNames);\n    case \"bool\":\n      return isMoreSpecificBool(type1, type2);\n  }\n}\nexports.isMoreSpecific = isMoreSpecific;\nfunction isMoreSpecificAddress(type1, type2) {\n  //address payable more specific than address\n  //contract types more specific than address\n  //*payable* contract types more specific than address payable\n  if (type1.typeClass === \"address\" && type2.typeClass === \"address\") {\n    if (type1.kind === \"specific\" && type2.kind === \"specific\") {\n      return type1.payable || !type2.payable;\n    } else if (type2.kind === \"general\") {\n      //specific is more specific than general :P\n      return true;\n    }\n  }\n  if (type1.typeClass === \"contract\" && type2.typeClass === \"contract\") {\n    if (type1.kind === \"native\" && type2.kind === \"native\") {\n      return type1.id === type2.id;\n    } //foreign contract types will always be incomparable, I guess?\n    //(they shouldn't come up here anyway)\n  }\n\n  if (type1.typeClass === \"contract\" && type2.typeClass === \"address\") {\n    return type2.kind === \"general\" || type2.kind === \"specific\" && !type2.payable || type2.kind === \"specific\" && type1.payable;\n  }\n  return false; //otherwise\n}\n\nfunction isMoreSpecificBytes(type1, type2) {\n  //static more specific than dynamic, with shorter\n  //lengths more specific than longer ones\n  return type1.kind === \"dynamic\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"static\" && type1.length <= type2.length;\n}\nfunction isMoreSpecificNumeric(type1, type2) {\n  return (0, utils_1.maxValue)(type1).lte((0, utils_1.maxValue)(type2)) && (0, utils_1.minValue)(type1).gte((0, utils_1.minValue)(type2)) && (0, utils_1.places)(type1) <= (0, utils_1.places)(type2) &&\n  //note: I don't know whether this final bit is actually necessary\n  //since we don't actually know yet whether fixedNx0 will be legal\n  !((type1.typeClass === \"fixed\" || type1.typeClass === \"ufixed\") && (type2.typeClass === \"int\" || type2.typeClass === \"uint\"));\n}\nfunction isMoreSpecificEnum(type1, type2) {\n  //different enum types are incomparable\n  return type1.id === type2.id;\n}\nfunction isMoreSpecificString(_type1, _type2) {\n  //only one string type\n  return true;\n}\nfunction isMoreSpecificArray(type1, type2, userDefinedTypes) {\n  //static is more specific than dynamic, but\n  //different static lengths are incomparable\n  const moreSpecificLength = type1.kind === \"dynamic\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"static\" && type1.length.eq(type2.length);\n  //length and types must both be more specific\n  return moreSpecificLength && isMoreSpecific(type1.baseType, type2.baseType, userDefinedTypes);\n}\nfunction isMoreSpecificFunction(type1, type2, userDefinedTypes) {\n  switch (type2.kind) {\n    case \"general\":\n      return true;\n    case \"specific\":\n      switch (type1.kind) {\n        case \"general\":\n          return false;\n        case \"specific\":\n          //now: if they're both specific...\n          //(this case doesn't really matter, but let's do it anyway)\n          if (!isMutabilityMoreSpecific(type1.mutability, type2.mutability)) {\n            return false;\n          }\n          if (type1.outputParameterTypes.length !== type2.outputParameterTypes.length) {\n            return false;\n          }\n          for (let i = 0; i < type1.outputParameterTypes.length; i++) {\n            if (!isMoreSpecific(type1.outputParameterTypes[i], type2.outputParameterTypes[i], userDefinedTypes)) {\n              return false;\n            }\n          }\n          if (type1.inputParameterTypes.length !== type2.inputParameterTypes.length) {\n            return false;\n          }\n          for (let i = 0; i < type1.inputParameterTypes.length; i++) {\n            if (!isMoreSpecific(\n            //swapped for contravariance, I guess...?\n            type2.inputParameterTypes[i], type1.inputParameterTypes[i], userDefinedTypes)) {\n              return false;\n            }\n          }\n          return true;\n      }\n  }\n}\nfunction isMutabilityMoreSpecific(mutability1, mutability2) {\n  //pure <= view <= nonpayable, payable <= nonpayable\n  return mutability1 === mutability2 || mutability1 === \"pure\" && mutability2 !== \"payable\" || mutability2 === \"nonpayable\";\n}\nfunction isMoreSpecificTuple(type1, type2, userDefinedTypes) {\n  let ignoreComponentNames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  debug(\"type1: %O\", type1);\n  debug(\"type2: %O\", type2);\n  const fullType1 = Format.Types.fullType(type1, userDefinedTypes);\n  const fullType2 = Format.Types.fullType(type2, userDefinedTypes);\n  const types1 = fullType1.memberTypes.map(member => member.type);\n  const types2 = fullType2.memberTypes.map(member => member.type);\n  //lengths must match\n  if (types1.length !== types2.length) {\n    return false;\n  }\n  //individual types must satisfy isMoreSpecific\n  for (let i = 0; i < types1.length; i++) {\n    //note we do *not* pass along the ignoreComponentNames flag\n    if (!isMoreSpecific(types1[i], types2[i], userDefinedTypes)) {\n      return false;\n    }\n  }\n  if (!ignoreComponentNames) {\n    debug(\"checking by name\");\n    //if this flag is not set, *and* the component names match,\n    //(and all exist)\n    //then compare by component names in addition to by position\n    let names1 = fullType1.memberTypes.map(member => member.name);\n    let names2 = fullType2.memberTypes.map(member => member.name);\n    //we just created these via a map so it's OK to sort in-place\n    names1.sort();\n    names2.sort();\n    let namesEqual = true;\n    for (let i = 0; i < names1.length; i++) {\n      if (!names1[i] || !names2[i] || names1[i] !== names2[i]) {\n        namesEqual = false;\n        break;\n      }\n    }\n    if (namesEqual) {\n      debug(\"names equal\");\n      for (let i = 0; i < types1.length; i++) {\n        const type1 = types1[i];\n        const name = fullType1.memberTypes[i].name;\n        const type2 = fullType2.memberTypes.find(_ref => {\n          let {\n            name: name2\n          } = _ref;\n          return name2 === name;\n        }).type;\n        debug(\"name: %s\", name);\n        debug(\"type1: %O\", type1);\n        debug(\"type2: %O\", type2);\n        if (!isMoreSpecific(type1, type2, userDefinedTypes)) {\n          debug(\"returning false\");\n          return false;\n        }\n      }\n      debug(\"name check ok\");\n    }\n  }\n  return true;\n  //I was going to make structs more specific than their underlying\n  //tuples, and different equivalent structs incomparable, but I\n  //couldn't find a good way to do that, so whatever, they're all\n  //just equivalent, it won't come up\n}\n\nfunction isMoreSpecificOptions(_type1, _type2) {\n  //only one options type\n  return true;\n}\nfunction isMoreSpecificBool(_type1, _type2) {\n  //only one boolean type\n  return true;\n}\nfunction getUnderlyingType(udvtType, userDefinedTypes) {\n  return Format.Types.fullType(udvtType, userDefinedTypes).underlyingType;\n}","map":{"version":3,"mappings":"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","names":["debug","isMoreSpecificMultiple","types1","types2","userDefinedTypes","combinedType1","typeClass","memberTypes","combinedType2","isMoreSpecific","exports","type1","type2","ignoreComponentNames","getUnderlyingType","typeClasses","index1","findIndex","classes","includes","index2","isMoreSpecificOptions","isMoreSpecificAddress","isMoreSpecificFunction","isMoreSpecificArray","isMoreSpecificBytes","isMoreSpecificNumeric","isMoreSpecificEnum","isMoreSpecificString","isMoreSpecificTuple","isMoreSpecificBool","kind","payable","id","length","lte","gte","_type1","_type2","moreSpecificLength","eq","baseType","isMutabilityMoreSpecific","mutability","outputParameterTypes","i","inputParameterTypes","mutability1","mutability2","fullType1","Format","Types","fullType","fullType2","map","member","type","names1","name","names2","sort","namesEqual","find","name2","udvtType","underlyingType"],"sourceRoot":"","sources":["../../../lib/wrap/priority.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}